(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/animations'), require('@angular/core'), require('rxjs'), require('@angular/common'), require('@angular/cdk/a11y'), require('@angular/cdk/coercion'), require('@angular/cdk/overlay'), require('@angular/cdk/bidi'), require('@angular/cdk/keycodes'), require('@angular/cdk/portal'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@ncstate/sat-popover', ['exports', '@angular/animations', '@angular/core', 'rxjs', '@angular/common', '@angular/cdk/a11y', '@angular/cdk/coercion', '@angular/cdk/overlay', '@angular/cdk/bidi', '@angular/cdk/keycodes', '@angular/cdk/portal', 'rxjs/operators'], factory) :
    (factory((global.ncstate = global.ncstate || {}, global.ncstate['sat-popover'] = {}),global.ng.animations,global.ng.core,global.rxjs,global.ng.common,global.ng.cdk.a11y,global.ng.cdk.coercion,global.ng.cdk.overlay,global.ng.cdk.bidi,global.ng.cdk.keycodes,global.ng.cdk.portal,global.rxjs.operators));
}(this, (function (exports,animations,core,rxjs,common,a11y,coercion,overlay,bidi,keycodes,portal,operators) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var transformPopover = animations.trigger('transformPopover', [
        animations.transition(':enter', [
            animations.style({ opacity: 0, transform: 'scale(0.3)' }),
            animations.animate('{{openTransition}}', animations.style({ opacity: 1, transform: 'scale(1)' }))
        ]),
        animations.transition(':leave', [
            animations.animate('{{closeTransition}}', animations.style({ opacity: 0, transform: 'scale(0.5)' }))
        ])
    ]);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var NotificationAction = {
        /** Popover should open. */
        OPEN: 0,
        /** Popover should close. */
        CLOSE: 1,
        /** Popover should toggle open or closed. */
        TOGGLE: 2,
        /** Popover has new target positions. */
        REPOSITION: 3,
        /** Popover needs new configuration. */
        UPDATE_CONFIG: 4,
        /** Popover should realign itself to the anchor.  */
        REALIGN: 5,
    };
    NotificationAction[NotificationAction.OPEN] = 'OPEN';
    NotificationAction[NotificationAction.CLOSE] = 'CLOSE';
    NotificationAction[NotificationAction.TOGGLE] = 'TOGGLE';
    NotificationAction[NotificationAction.REPOSITION] = 'REPOSITION';
    NotificationAction[NotificationAction.UPDATE_CONFIG] = 'UPDATE_CONFIG';
    NotificationAction[NotificationAction.REALIGN] = 'REALIGN';
    /**
     * Event object for dispatching to anchoring service.
     */
    var /**
     * Event object for dispatching to anchoring service.
     */ PopoverNotification = /** @class */ (function () {
        function PopoverNotification(action, value) {
            this.action = action;
            this.value = value;
        }
        return PopoverNotification;
    }());
    var PopoverNotificationService = /** @class */ (function () {
        function PopoverNotificationService() {
            this.store = new rxjs.Subject();
        }
        /** Dispatch a notification to all subscribers. */
        /**
         * Dispatch a notification to all subscribers.
         * @param {?} notification
         * @return {?}
         */
        PopoverNotificationService.prototype.dispatch = /**
         * Dispatch a notification to all subscribers.
         * @param {?} notification
         * @return {?}
         */
            function (notification) {
                this.store.next(notification);
            };
        /** Stream of notification events. */
        /**
         * Stream of notification events.
         * @return {?}
         */
        PopoverNotificationService.prototype.events = /**
         * Stream of notification events.
         * @return {?}
         */
            function () {
                return this.store.asObservable();
            };
        /** Complete event stream. */
        /**
         * Complete event stream.
         * @return {?}
         */
        PopoverNotificationService.prototype.dispose = /**
         * Complete event stream.
         * @return {?}
         */
            function () {
                this.store.complete();
            };
        PopoverNotificationService.decorators = [
            { type: core.Injectable }
        ];
        return PopoverNotificationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var VALID_SCROLL = [
        'noop',
        'block',
        'reposition',
        'close'
    ];
    /** @type {?} */
    var VALID_HORIZ_ALIGN = [
        'before',
        'start',
        'center',
        'end',
        'after'
    ];
    /** @type {?} */
    var VALID_VERT_ALIGN = [
        'above',
        'start',
        'center',
        'end',
        'below'
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function getInvalidPopoverError() {
        return Error('SatPopoverAnchor must be provided an SatPopover component instance.');
    }
    /**
     * @return {?}
     */
    function getUnanchoredPopoverError() {
        return Error('SatPopover is not anchored to any SatPopoverAnchor.');
    }
    /**
     * @param {?} alignment
     * @return {?}
     */
    function getInvalidHorizontalAlignError(alignment) {
        return Error(generateGenericError('horizontalAlign/xAlign', alignment, VALID_HORIZ_ALIGN));
    }
    /**
     * @param {?} alignment
     * @return {?}
     */
    function getInvalidVerticalAlignError(alignment) {
        return Error(generateGenericError('verticalAlign/yAlign', alignment, VALID_VERT_ALIGN));
    }
    /**
     * @param {?} strategy
     * @return {?}
     */
    function getInvalidScrollStrategyError(strategy) {
        return Error(generateGenericError('scrollStrategy', strategy, VALID_SCROLL));
    }
    /**
     * @param {?} apiName
     * @param {?} invalid
     * @param {?} valid
     * @return {?}
     */
    function generateGenericError(apiName, invalid, valid) {
        return "Invalid " + apiName + ": '" + invalid + "'. Valid options are " +
            (valid.map(function (v) { return "'" + v + "'"; }).join(', ') + ".");
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    // See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
    /** @type {?} */
    var DEFAULT_TRANSITION = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';
    var SatPopover = /** @class */ (function () {
        function SatPopover(_focusTrapFactory, _document) {
            this._focusTrapFactory = _focusTrapFactory;
            this._document = _document;
            this._horizontalAlign = 'center';
            this._verticalAlign = 'center';
            this._forceAlignment = false;
            this._lockAlignment = false;
            this._autoFocus = true;
            this._autoFocusOverride = true;
            this._restoreFocus = true;
            this._restoreFocusOverride = true;
            this._scrollStrategy = 'reposition';
            this._hasBackdrop = false;
            this._interactiveClose = true;
            this._openTransition = DEFAULT_TRANSITION;
            this._closeTransition = DEFAULT_TRANSITION;
            /**
             * Optional backdrop class.
             */
            this.backdropClass = '';
            /**
             * Emits when the popover is opened.
             */
            this.opened = new core.EventEmitter();
            /**
             * Emits when the popover is closed.
             */
            this.closed = new core.EventEmitter();
            /**
             * Emits when the popover has finished opening.
             */
            this.afterOpen = new core.EventEmitter();
            /**
             * Emits when the popover has finished closing.
             */
            this.afterClose = new core.EventEmitter();
            /**
             * Emits when the backdrop is clicked.
             */
            this.backdropClicked = new core.EventEmitter();
            /**
             * Emits when a keydown event is targeted to this popover's overlay.
             */
            this.overlayKeydown = new core.EventEmitter();
            /**
             * Classes to be added to the popover for setting the correct transform origin.
             */
            this._classList = {};
            /**
             * Whether the popover is presently open.
             */
            this._open = false;
        }
        Object.defineProperty(SatPopover.prototype, "horizontalAlign", {
            /** Alignment of the popover on the horizontal axis. */
            get: /**
             * Alignment of the popover on the horizontal axis.
             * @return {?}
             */ function () { return this._horizontalAlign; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._validateHorizontalAlign(val);
                if (this._horizontalAlign !== val) {
                    this._horizontalAlign = val;
                    this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "xAlign", {
            /** Alignment of the popover on the x axis. Alias for `horizontalAlign`. */
            get: /**
             * Alignment of the popover on the x axis. Alias for `horizontalAlign`.
             * @return {?}
             */ function () { return this.horizontalAlign; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this.horizontalAlign = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "verticalAlign", {
            /** Alignment of the popover on the vertical axis. */
            get: /**
             * Alignment of the popover on the vertical axis.
             * @return {?}
             */ function () { return this._verticalAlign; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._validateVerticalAlign(val);
                if (this._verticalAlign !== val) {
                    this._verticalAlign = val;
                    this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "yAlign", {
            /** Alignment of the popover on the y axis. Alias for `verticalAlign`. */
            get: /**
             * Alignment of the popover on the y axis. Alias for `verticalAlign`.
             * @return {?}
             */ function () { return this.verticalAlign; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this.verticalAlign = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "forceAlignment", {
            /** Whether the popover always opens with the specified alignment. */
            get: /**
             * Whether the popover always opens with the specified alignment.
             * @return {?}
             */ function () { return this._forceAlignment; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                /** @type {?} */
                var coercedVal = coercion.coerceBooleanProperty(val);
                if (this._forceAlignment !== coercedVal) {
                    this._forceAlignment = coercedVal;
                    this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "lockAlignment", {
            /**
             * Whether the popover's alignment is locked after opening. This prevents the popover
             * from changing its alignement when scrolling or changing the size of the viewport.
             */
            get: /**
             * Whether the popover's alignment is locked after opening. This prevents the popover
             * from changing its alignement when scrolling or changing the size of the viewport.
             * @return {?}
             */ function () { return this._lockAlignment; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                /** @type {?} */
                var coercedVal = coercion.coerceBooleanProperty(val);
                if (this._lockAlignment !== coercedVal) {
                    this._lockAlignment = coercion.coerceBooleanProperty(val);
                    this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "autoFocus", {
            /** Whether the first focusable element should be focused on open. */
            get: /**
             * Whether the first focusable element should be focused on open.
             * @return {?}
             */ function () { return this._autoFocus && this._autoFocusOverride; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._autoFocus = coercion.coerceBooleanProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "restoreFocus", {
            /** Whether the popover should return focus to the previously focused element after closing. */
            get: /**
             * Whether the popover should return focus to the previously focused element after closing.
             * @return {?}
             */ function () { return this._restoreFocus && this._restoreFocusOverride; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._restoreFocus = coercion.coerceBooleanProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "scrollStrategy", {
            /** How the popover should handle scrolling. */
            get: /**
             * How the popover should handle scrolling.
             * @return {?}
             */ function () { return this._scrollStrategy; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._validateScrollStrategy(val);
                if (this._scrollStrategy !== val) {
                    this._scrollStrategy = val;
                    this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "hasBackdrop", {
            /** Whether the popover should have a backdrop (includes closing on click). */
            get: /**
             * Whether the popover should have a backdrop (includes closing on click).
             * @return {?}
             */ function () { return this._hasBackdrop; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._hasBackdrop = coercion.coerceBooleanProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "interactiveClose", {
            /** Whether the popover should close when the user clicks the backdrop or presses ESC. */
            get: /**
             * Whether the popover should close when the user clicks the backdrop or presses ESC.
             * @return {?}
             */ function () { return this._interactiveClose; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._interactiveClose = coercion.coerceBooleanProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "openTransition", {
            /** Custom transition to use while opening. */
            get: /**
             * Custom transition to use while opening.
             * @return {?}
             */ function () { return this._openTransition; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (val) {
                    this._openTransition = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SatPopover.prototype, "closeTransition", {
            /** Custom transition to use while closing. */
            get: /**
             * Custom transition to use while closing.
             * @return {?}
             */ function () { return this._closeTransition; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (val) {
                    this._closeTransition = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SatPopover.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._setAlignmentClasses();
            };
        /**
         * @return {?}
         */
        SatPopover.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._notifications) {
                    this._notifications.dispose();
                }
            };
        /** Open this popover. */
        /**
         * Open this popover.
         * @param {?=} options
         * @return {?}
         */
        SatPopover.prototype.open = /**
         * Open this popover.
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                if (options === void 0) {
                    options = {};
                }
                /** @type {?} */
                var notification = new PopoverNotification(NotificationAction.OPEN, options);
                this._dispatchActionNotification(notification);
            };
        /** Close this popover. */
        /**
         * Close this popover.
         * @param {?=} value
         * @return {?}
         */
        SatPopover.prototype.close = /**
         * Close this popover.
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var notification = new PopoverNotification(NotificationAction.CLOSE, value);
                this._dispatchActionNotification(notification);
            };
        /** Toggle this popover open or closed. */
        /**
         * Toggle this popover open or closed.
         * @return {?}
         */
        SatPopover.prototype.toggle = /**
         * Toggle this popover open or closed.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var notification = new PopoverNotification(NotificationAction.TOGGLE);
                this._dispatchActionNotification(notification);
            };
        /** Realign the popover to the anchor. */
        /**
         * Realign the popover to the anchor.
         * @return {?}
         */
        SatPopover.prototype.realign = /**
         * Realign the popover to the anchor.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var notification = new PopoverNotification(NotificationAction.REALIGN);
                this._dispatchActionNotification(notification);
            };
        /** Gets whether the popover is presently open. */
        /**
         * Gets whether the popover is presently open.
         * @return {?}
         */
        SatPopover.prototype.isOpen = /**
         * Gets whether the popover is presently open.
         * @return {?}
         */
            function () {
                return this._open;
            };
        /** Gets an animation config with customized (or default) transition values. */
        /**
         * Gets an animation config with customized (or default) transition values.
         * @return {?}
         */
        SatPopover.prototype._getAnimation = /**
         * Gets an animation config with customized (or default) transition values.
         * @return {?}
         */
            function () {
                return {
                    value: 'visible',
                    params: { openTransition: this.openTransition, closeTransition: this.closeTransition }
                };
            };
        /** Callback for when the popover is finished animating in or out. */
        /**
         * Callback for when the popover is finished animating in or out.
         * @param {?} event
         * @return {?}
         */
        SatPopover.prototype._onAnimationDone = /**
         * Callback for when the popover is finished animating in or out.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.toState === 'visible') {
                    this._trapFocus();
                    this.afterOpen.emit();
                }
                else if (event.toState === 'void') {
                    this._restoreFocusAndDestroyTrap();
                    this.afterClose.emit();
                }
            };
        /** Apply alignment classes based on alignment inputs. */
        /**
         * Apply alignment classes based on alignment inputs.
         * @param {?=} horizAlign
         * @param {?=} vertAlign
         * @return {?}
         */
        SatPopover.prototype._setAlignmentClasses = /**
         * Apply alignment classes based on alignment inputs.
         * @param {?=} horizAlign
         * @param {?=} vertAlign
         * @return {?}
         */
            function (horizAlign, vertAlign) {
                if (horizAlign === void 0) {
                    horizAlign = this.horizontalAlign;
                }
                if (vertAlign === void 0) {
                    vertAlign = this.verticalAlign;
                }
                this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';
                this._classList['sat-popover-after'] = horizAlign === 'after' || horizAlign === 'start';
                this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';
                this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';
                this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';
            };
        /** Move the focus inside the focus trap and remember where to return later. */
        /**
         * Move the focus inside the focus trap and remember where to return later.
         * @return {?}
         */
        SatPopover.prototype._trapFocus = /**
         * Move the focus inside the focus trap and remember where to return later.
         * @return {?}
         */
            function () {
                this._savePreviouslyFocusedElement();
                // There won't be a focus trap element if the close animation starts before open finishes
                if (!this._focusTrapElement) {
                    return;
                }
                if (!this._focusTrap && this._focusTrapElement) {
                    this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
                }
                if (this.autoFocus) {
                    this._focusTrap.focusInitialElementWhenReady();
                }
            };
        /** Restore focus to the element focused before the popover opened. Also destroy trap. */
        /**
         * Restore focus to the element focused before the popover opened. Also destroy trap.
         * @return {?}
         */
        SatPopover.prototype._restoreFocusAndDestroyTrap = /**
         * Restore focus to the element focused before the popover opened. Also destroy trap.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var toFocus = this._previouslyFocusedElement;
                // Must check active element is focusable for IE sake
                if (toFocus && 'focus' in toFocus && this.restoreFocus) {
                    this._previouslyFocusedElement.focus();
                }
                this._previouslyFocusedElement = null;
                if (this._focusTrap) {
                    this._focusTrap.destroy();
                    this._focusTrap = undefined;
                }
            };
        /** Save a reference to the element focused before the popover was opened. */
        /**
         * Save a reference to the element focused before the popover was opened.
         * @return {?}
         */
        SatPopover.prototype._savePreviouslyFocusedElement = /**
         * Save a reference to the element focused before the popover was opened.
         * @return {?}
         */
            function () {
                if (this._document) {
                    this._previouslyFocusedElement = ( /** @type {?} */(this._document.activeElement));
                }
            };
        /** Dispatch a notification to the notification service, if possible. */
        /**
         * Dispatch a notification to the notification service, if possible.
         * @param {?} notification
         * @return {?}
         */
        SatPopover.prototype._dispatchConfigNotification = /**
         * Dispatch a notification to the notification service, if possible.
         * @param {?} notification
         * @return {?}
         */
            function (notification) {
                if (this._notifications) {
                    this._notifications.dispatch(notification);
                }
            };
        /** Dispatch a notification to the notification service and throw if unable to. */
        /**
         * Dispatch a notification to the notification service and throw if unable to.
         * @param {?} notification
         * @return {?}
         */
        SatPopover.prototype._dispatchActionNotification = /**
         * Dispatch a notification to the notification service and throw if unable to.
         * @param {?} notification
         * @return {?}
         */
            function (notification) {
                if (!this._notifications) {
                    throw getUnanchoredPopoverError();
                }
                this._notifications.dispatch(notification);
            };
        /** Throws an error if the alignment is not a valid horizontalAlign. */
        /**
         * Throws an error if the alignment is not a valid horizontalAlign.
         * @param {?} pos
         * @return {?}
         */
        SatPopover.prototype._validateHorizontalAlign = /**
         * Throws an error if the alignment is not a valid horizontalAlign.
         * @param {?} pos
         * @return {?}
         */
            function (pos) {
                if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
                    throw getInvalidHorizontalAlignError(pos);
                }
            };
        /** Throws an error if the alignment is not a valid verticalAlign. */
        /**
         * Throws an error if the alignment is not a valid verticalAlign.
         * @param {?} pos
         * @return {?}
         */
        SatPopover.prototype._validateVerticalAlign = /**
         * Throws an error if the alignment is not a valid verticalAlign.
         * @param {?} pos
         * @return {?}
         */
            function (pos) {
                if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
                    throw getInvalidVerticalAlignError(pos);
                }
            };
        /** Throws an error if the scroll strategy is not a valid strategy. */
        /**
         * Throws an error if the scroll strategy is not a valid strategy.
         * @param {?} strategy
         * @return {?}
         */
        SatPopover.prototype._validateScrollStrategy = /**
         * Throws an error if the scroll strategy is not a valid strategy.
         * @param {?} strategy
         * @return {?}
         */
            function (strategy) {
                if (VALID_SCROLL.indexOf(strategy) === -1) {
                    throw getInvalidScrollStrategyError(strategy);
                }
            };
        SatPopover.decorators = [
            { type: core.Component, args: [{
                        selector: 'sat-popover',
                        encapsulation: core.ViewEncapsulation.None,
                        animations: [transformPopover],
                        template: "<ng-template>\n  <div class=\"sat-popover-container\"\n      #focusTrapElement\n      [ngClass]=\"_classList\"\n      [@transformPopover]=\"_getAnimation()\"\n      (@transformPopover.done)=\"_onAnimationDone($event)\">\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n",
                        styles: [".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}.sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}.sat-popover-container.sat-popover-center.sat-popover-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.sat-popover-container.sat-popover-center.sat-popover-below{-webkit-transform-origin:center top;transform-origin:center top}.sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}.sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}"]
                    }] }
        ];
        /** @nocollapse */
        SatPopover.ctorParameters = function () {
            return [
                { type: a11y.FocusTrapFactory },
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
            ];
        };
        SatPopover.propDecorators = {
            horizontalAlign: [{ type: core.Input }],
            xAlign: [{ type: core.Input }],
            verticalAlign: [{ type: core.Input }],
            yAlign: [{ type: core.Input }],
            forceAlignment: [{ type: core.Input }],
            lockAlignment: [{ type: core.Input }],
            autoFocus: [{ type: core.Input }],
            restoreFocus: [{ type: core.Input }],
            scrollStrategy: [{ type: core.Input }],
            hasBackdrop: [{ type: core.Input }],
            interactiveClose: [{ type: core.Input }],
            openTransition: [{ type: core.Input }],
            closeTransition: [{ type: core.Input }],
            backdropClass: [{ type: core.Input }],
            opened: [{ type: core.Output }],
            closed: [{ type: core.Output }],
            afterOpen: [{ type: core.Output }],
            afterClose: [{ type: core.Output }],
            backdropClicked: [{ type: core.Output }],
            overlayKeydown: [{ type: core.Output }],
            _templateRef: [{ type: core.ViewChild, args: [core.TemplateRef,] }],
            _focusTrapElement: [{ type: core.ViewChild, args: ['focusTrapElement',] }]
        };
        return SatPopover;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SatPopoverAnchoringService = /** @class */ (function () {
        function SatPopoverAnchoringService(_overlay, _ngZone, _dir) {
            this._overlay = _overlay;
            this._ngZone = _ngZone;
            this._dir = _dir;
            /**
             * Emits when the popover is opened.
             */
            this.popoverOpened = new rxjs.Subject();
            /**
             * Emits when the popover is closed.
             */
            this.popoverClosed = new rxjs.Subject();
            /**
             * Whether the popover is presently open.
             */
            this._popoverOpen = false;
            /**
             * Emits when the service is destroyed.
             */
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // Destroy popover before terminating subscriptions so that any resulting
                // detachments update 'closed state'
                this._destroyPopover();
                // Terminate subscriptions
                if (this._notificationsSubscription) {
                    this._notificationsSubscription.unsubscribe();
                }
                if (this._positionChangeSubscription) {
                    this._positionChangeSubscription.unsubscribe();
                }
                this._onDestroy.next();
                this._onDestroy.complete();
                this.popoverOpened.complete();
                this.popoverClosed.complete();
            };
        /** Anchor a popover instance to a view and connection element. */
        /**
         * Anchor a popover instance to a view and connection element.
         * @param {?} popover
         * @param {?} viewContainerRef
         * @param {?} anchor
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.anchor = /**
         * Anchor a popover instance to a view and connection element.
         * @param {?} popover
         * @param {?} viewContainerRef
         * @param {?} anchor
         * @return {?}
         */
            function (popover, viewContainerRef, anchor) {
                // Destroy any previous popovers
                this._destroyPopover();
                // Assign local refs
                this._popover = popover;
                this._viewContainerRef = viewContainerRef;
                this._anchor = anchor;
                // Provide notification service as a communication channel between popover and anchor.
                // Then subscribe to notifications to take appropriate actions.
                this._popover._notifications = this._notifications = new PopoverNotificationService();
                this._subscribeToNotifications();
            };
        /** Gets whether the popover is presently open. */
        /**
         * Gets whether the popover is presently open.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.isPopoverOpen = /**
         * Gets whether the popover is presently open.
         * @return {?}
         */
            function () {
                return this._popoverOpen;
            };
        /** Toggles the popover between the open and closed states. */
        /**
         * Toggles the popover between the open and closed states.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.togglePopover = /**
         * Toggles the popover between the open and closed states.
         * @return {?}
         */
            function () {
                return this._popoverOpen ? this.closePopover() : this.openPopover();
            };
        /** Opens the popover. */
        /**
         * Opens the popover.
         * @param {?=} options
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.openPopover = /**
         * Opens the popover.
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                if (options === void 0) {
                    options = {};
                }
                if (!this._popoverOpen) {
                    this._applyOpenOptions(options);
                    this._createOverlay();
                    this._subscribeToBackdrop();
                    this._subscribeToEscape();
                    this._subscribeToDetachments();
                    this._saveOpenedState();
                }
            };
        /** Closes the popover. */
        /**
         * Closes the popover.
         * @param {?=} value
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.closePopover = /**
         * Closes the popover.
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                if (this._overlayRef) {
                    this._saveClosedState(value);
                    this._overlayRef.detach();
                }
            };
        /** Realign the popover to the anchor. */
        /**
         * Realign the popover to the anchor.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.realignPopoverToAnchor = /**
         * Realign the popover to the anchor.
         * @return {?}
         */
            function () {
                if (this._overlayRef) {
                    /** @type {?} */
                    var config = this._overlayRef.getConfig();
                    /** @type {?} */
                    var strategy = ( /** @type {?} */(config.positionStrategy));
                    strategy.reapplyLastPosition();
                }
            };
        /** Get a reference to the anchor element. */
        /**
         * Get a reference to the anchor element.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype.getAnchorElement = /**
         * Get a reference to the anchor element.
         * @return {?}
         */
            function () {
                return this._anchor;
            };
        /** Apply behavior properties on the popover based on the open options. */
        /**
         * Apply behavior properties on the popover based on the open options.
         * @param {?} options
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._applyOpenOptions = /**
         * Apply behavior properties on the popover based on the open options.
         * @param {?} options
         * @return {?}
         */
            function (options) {
                // Only override restoreFocus as `false` if the option is explicitly `false`
                /** @type {?} */
                var restoreFocus = options.restoreFocus !== false;
                this._popover._restoreFocusOverride = restoreFocus;
                // Only override autoFocus as `false` if the option is explicitly `false`
                /** @type {?} */
                var autoFocus = options.autoFocus !== false;
                this._popover._autoFocusOverride = autoFocus;
            };
        /** Create an overlay to be attached to the portal. */
        /**
         * Create an overlay to be attached to the portal.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._createOverlay = /**
         * Create an overlay to be attached to the portal.
         * @return {?}
         */
            function () {
                // Create overlay if it doesn't yet exist
                if (!this._overlayRef) {
                    this._portal = new portal.TemplatePortal(this._popover._templateRef, this._viewContainerRef);
                    /** @type {?} */
                    var popoverConfig = {
                        horizontalAlign: this._popover.horizontalAlign,
                        verticalAlign: this._popover.verticalAlign,
                        hasBackdrop: this._popover.hasBackdrop,
                        backdropClass: this._popover.backdropClass,
                        scrollStrategy: this._popover.scrollStrategy,
                        forceAlignment: this._popover.forceAlignment,
                        lockAlignment: this._popover.lockAlignment,
                    };
                    /** @type {?} */
                    var overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
                    this._subscribeToPositionChanges(( /** @type {?} */(overlayConfig.positionStrategy)));
                    this._overlayRef = this._overlay.create(overlayConfig);
                }
                // Actually open the popover
                this._overlayRef.attach(this._portal);
                return this._overlayRef;
            };
        /** Removes the popover from the DOM. Does NOT update open state. */
        /**
         * Removes the popover from the DOM. Does NOT update open state.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._destroyPopover = /**
         * Removes the popover from the DOM. Does NOT update open state.
         * @return {?}
         */
            function () {
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._overlayRef = null;
                }
            };
        /**
         * Destroys the popover immediately if it is closed, or waits until it
         * has been closed to destroy it.
         */
        /**
         * Destroys the popover immediately if it is closed, or waits until it
         * has been closed to destroy it.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._destroyPopoverOnceClosed = /**
         * Destroys the popover immediately if it is closed, or waits until it
         * has been closed to destroy it.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.isPopoverOpen() && this._overlayRef) {
                    this._overlayRef.detachments().pipe(operators.take(1), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this._destroyPopover(); });
                }
                else {
                    this._destroyPopover();
                }
            };
        /**
         * Call appropriate anchor method when an event is dispatched through
         * the notification service.
         */
        /**
         * Call appropriate anchor method when an event is dispatched through
         * the notification service.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._subscribeToNotifications = /**
         * Call appropriate anchor method when an event is dispatched through
         * the notification service.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._notificationsSubscription) {
                    this._notificationsSubscription.unsubscribe();
                }
                this._notificationsSubscription = this._notifications.events()
                    .subscribe(function (event) {
                    switch (event.action) {
                        case NotificationAction.OPEN:
                            _this.openPopover(event.value);
                            break;
                        case NotificationAction.CLOSE:
                            _this.closePopover(event.value);
                            break;
                        case NotificationAction.TOGGLE:
                            _this.togglePopover();
                            break;
                        case NotificationAction.REPOSITION:
                        // TODO: When the overlay's position can be dynamically changed, do not destroy
                        case NotificationAction.UPDATE_CONFIG:
                            _this._destroyPopoverOnceClosed();
                            break;
                        case NotificationAction.REALIGN:
                            _this.realignPopoverToAnchor();
                            break;
                    }
                });
            };
        /** Close popover when backdrop is clicked. */
        /**
         * Close popover when backdrop is clicked.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._subscribeToBackdrop = /**
         * Close popover when backdrop is clicked.
         * @return {?}
         */
            function () {
                var _this = this;
                this._overlayRef
                    .backdropClick()
                    .pipe(operators.tap(function () { return _this._popover.backdropClicked.emit(); }), operators.filter(function () { return _this._popover.interactiveClose; }), operators.takeUntil(this.popoverClosed), operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this.closePopover(); });
            };
        /** Close popover when escape keydown event occurs. */
        /**
         * Close popover when escape keydown event occurs.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._subscribeToEscape = /**
         * Close popover when escape keydown event occurs.
         * @return {?}
         */
            function () {
                var _this = this;
                this._overlayRef
                    .keydownEvents()
                    .pipe(operators.tap(function (event) { return _this._popover.overlayKeydown.emit(event); }), operators.filter(function (event) { return event.keyCode === keycodes.ESCAPE; }), operators.filter(function () { return _this._popover.interactiveClose; }), operators.takeUntil(this.popoverClosed), operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this.closePopover(); });
            };
        /** Set state back to closed when detached. */
        /**
         * Set state back to closed when detached.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._subscribeToDetachments = /**
         * Set state back to closed when detached.
         * @return {?}
         */
            function () {
                var _this = this;
                this._overlayRef
                    .detachments()
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this._saveClosedState(); });
            };
        /** Save the opened state of the popover and emit. */
        /**
         * Save the opened state of the popover and emit.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._saveOpenedState = /**
         * Save the opened state of the popover and emit.
         * @return {?}
         */
            function () {
                if (!this._popoverOpen) {
                    this._popover._open = this._popoverOpen = true;
                    this.popoverOpened.next();
                    this._popover.opened.emit();
                }
            };
        /** Save the closed state of the popover and emit. */
        /**
         * Save the closed state of the popover and emit.
         * @param {?=} value
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._saveClosedState = /**
         * Save the closed state of the popover and emit.
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                if (this._popoverOpen) {
                    this._popover._open = this._popoverOpen = false;
                    this.popoverClosed.next(value);
                    this._popover.closed.emit(value);
                }
            };
        /** Gets the text direction of the containing app. */
        /**
         * Gets the text direction of the containing app.
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._getDirection = /**
         * Gets the text direction of the containing app.
         * @return {?}
         */
            function () {
                return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
            };
        /** Create and return a config for creating the overlay. */
        /**
         * Create and return a config for creating the overlay.
         * @param {?} config
         * @param {?} anchor
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._getOverlayConfig = /**
         * Create and return a config for creating the overlay.
         * @param {?} config
         * @param {?} anchor
         * @return {?}
         */
            function (config, anchor) {
                return new overlay.OverlayConfig({
                    positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor),
                    hasBackdrop: config.hasBackdrop,
                    backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
                    scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
                    direction: this._getDirection(),
                });
            };
        /**
         * Listen to changes in the position of the overlay and set the correct alignment classes,
         * ensuring that the animation origin is correct, even with a fallback position.
         */
        /**
         * Listen to changes in the position of the overlay and set the correct alignment classes,
         * ensuring that the animation origin is correct, even with a fallback position.
         * @param {?} position
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._subscribeToPositionChanges = /**
         * Listen to changes in the position of the overlay and set the correct alignment classes,
         * ensuring that the animation origin is correct, even with a fallback position.
         * @param {?} position
         * @return {?}
         */
            function (position) {
                var _this = this;
                if (this._positionChangeSubscription) {
                    this._positionChangeSubscription.unsubscribe();
                }
                this._positionChangeSubscription = position.positionChanges
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (change) {
                    // Position changes may occur outside the Angular zone
                    _this._ngZone.run(function () {
                        _this._popover._setAlignmentClasses(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
                    });
                });
            };
        /** Map a scroll strategy string type to an instance of a scroll strategy. */
        /**
         * Map a scroll strategy string type to an instance of a scroll strategy.
         * @param {?} strategy
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._getScrollStrategyInstance = /**
         * Map a scroll strategy string type to an instance of a scroll strategy.
         * @param {?} strategy
         * @return {?}
         */
            function (strategy) {
                switch (strategy) {
                    case 'block':
                        return this._overlay.scrollStrategies.block();
                    case 'reposition':
                        return this._overlay.scrollStrategies.reposition();
                    case 'close':
                        return this._overlay.scrollStrategies.close();
                    case 'noop':
                    default:
                        return this._overlay.scrollStrategies.noop();
                }
            };
        /** Create and return a position strategy based on config provided to the component instance. */
        /**
         * Create and return a position strategy based on config provided to the component instance.
         * @param {?} horizontalTarget
         * @param {?} verticalTarget
         * @param {?} forceAlignment
         * @param {?} lockAlignment
         * @param {?} anchor
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._getPositionStrategy = /**
         * Create and return a position strategy based on config provided to the component instance.
         * @param {?} horizontalTarget
         * @param {?} verticalTarget
         * @param {?} forceAlignment
         * @param {?} lockAlignment
         * @param {?} anchor
         * @return {?}
         */
            function (horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
                // Attach the overlay at the preferred position
                /** @type {?} */
                var targetPosition = getPosition(horizontalTarget, verticalTarget);
                /** @type {?} */
                var positions = [targetPosition];
                /** @type {?} */
                var strategy = this._overlay.position()
                    .flexibleConnectedTo(anchor)
                    .withFlexibleDimensions(false)
                    .withPush(false)
                    .withViewportMargin(0)
                    .withLockedPosition(lockAlignment);
                // Unless the alignment is forced, add fallbacks based on the preferred positions
                if (!forceAlignment) {
                    /** @type {?} */
                    var fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
                    positions.push.apply(positions, __spread(fallbacks));
                }
                return strategy.withPositions(positions);
            };
        /** Get fallback positions based around target alignments. */
        /**
         * Get fallback positions based around target alignments.
         * @param {?} hTarget
         * @param {?} vTarget
         * @return {?}
         */
        SatPopoverAnchoringService.prototype._getFallbacks = /**
         * Get fallback positions based around target alignments.
         * @param {?} hTarget
         * @param {?} vTarget
         * @return {?}
         */
            function (hTarget, vTarget) {
                // Determine if the target alignments overlap the anchor
                /** @type {?} */
                var horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
                /** @type {?} */
                var verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
                // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
                // cover the anchor
                /** @type {?} */
                var possibleHorizontalAlignments = horizontalOverlapAllowed ?
                    ['before', 'start', 'center', 'end', 'after'] :
                    ['before', 'after'];
                /** @type {?} */
                var possibleVerticalAlignments = verticalOverlapAllowed ?
                    ['above', 'start', 'center', 'end', 'below'] :
                    ['above', 'below'];
                // Create fallbacks for each allowed prioritized fallback alignment combo
                /** @type {?} */
                var fallbacks = [];
                prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach(function (h) {
                    prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach(function (v) {
                        fallbacks.push(getPosition(h, v));
                    });
                });
                // Remove the first item since it will be the target alignment and isn't considered a fallback
                return fallbacks.slice(1, fallbacks.length);
            };
        SatPopoverAnchoringService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SatPopoverAnchoringService.ctorParameters = function () {
            return [
                { type: overlay.Overlay },
                { type: core.NgZone },
                { type: bidi.Directionality, decorators: [{ type: core.Optional }] }
            ];
        };
        return SatPopoverAnchoringService;
    }());
    /**
     * Helper function to get a cdk position pair from SatPopover alignments.
     * @param {?} h
     * @param {?} v
     * @return {?}
     */
    function getPosition(h, v) {
        var _a = getHorizontalConnectionPosPair(h), originX = _a.originX, overlayX = _a.overlayX;
        var _b = getVerticalConnectionPosPair(v), originY = _b.originY, overlayY = _b.overlayY;
        return new overlay.ConnectionPositionPair({ originX: originX, originY: originY }, { overlayX: overlayX, overlayY: overlayY });
    }
    /**
     * Helper function to convert an overlay connection position to equivalent popover alignment.
     * @param {?} h
     * @return {?}
     */
    function getHorizontalPopoverAlignment(h) {
        if (h === 'start') {
            return 'after';
        }
        if (h === 'end') {
            return 'before';
        }
        return 'center';
    }
    /**
     * Helper function to convert an overlay connection position to equivalent popover alignment.
     * @param {?} v
     * @return {?}
     */
    function getVerticalPopoverAlignment(v) {
        if (v === 'top') {
            return 'below';
        }
        if (v === 'bottom') {
            return 'above';
        }
        return 'center';
    }
    /**
     * Helper function to convert alignment to origin/overlay position pair.
     * @param {?} h
     * @return {?}
     */
    function getHorizontalConnectionPosPair(h) {
        switch (h) {
            case 'before':
                return { originX: 'start', overlayX: 'end' };
            case 'start':
                return { originX: 'start', overlayX: 'start' };
            case 'end':
                return { originX: 'end', overlayX: 'end' };
            case 'after':
                return { originX: 'end', overlayX: 'start' };
            default:
                return { originX: 'center', overlayX: 'center' };
        }
    }
    /**
     * Helper function to convert alignment to origin/overlay position pair.
     * @param {?} v
     * @return {?}
     */
    function getVerticalConnectionPosPair(v) {
        switch (v) {
            case 'above':
                return { originY: 'top', overlayY: 'bottom' };
            case 'start':
                return { originY: 'top', overlayY: 'top' };
            case 'end':
                return { originY: 'bottom', overlayY: 'bottom' };
            case 'below':
                return { originY: 'bottom', overlayY: 'top' };
            default:
                return { originY: 'center', overlayY: 'center' };
        }
    }
    /**
     * Helper function that takes an ordered array options and returns a reorderded
     * array around the target item. e.g.:
     *
     * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
     *
     * return: [3, 4, 2, 5, 1, 6, 7]
     * @template T
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    function prioritizeAroundTarget(target, options) {
        /** @type {?} */
        var targetIndex = options.indexOf(target);
        // Set the first item to be the target
        /** @type {?} */
        var reordered = [target];
        // Make left and right stacks where the highest priority item is last
        /** @type {?} */
        var left = options.slice(0, targetIndex);
        /** @type {?} */
        var right = options.slice(targetIndex + 1, options.length).reverse();
        // Alternate between stacks until one is empty
        while (left.length && right.length) {
            reordered.push(right.pop());
            reordered.push(left.pop());
        }
        // Flush out right side
        while (right.length) {
            reordered.push(right.pop());
        }
        // Flush out left side
        while (left.length) {
            reordered.push(left.pop());
        }
        return reordered;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SatPopoverAnchor = /** @class */ (function () {
        function SatPopoverAnchor(_elementRef, _viewContainerRef, _anchoring) {
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            this._anchoring = _anchoring;
            /**
             * Emits when the popover is opened.
             */
            this.popoverOpened = new core.EventEmitter();
            /**
             * Emits when the popover is closed.
             */
            this.popoverClosed = new core.EventEmitter();
            /**
             * Emits when the directive is destroyed.
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(SatPopoverAnchor.prototype, "attachedPopover", {
            /** Reference to the popover instance. */
            get: /**
             * Reference to the popover instance.
             * @return {?}
             */ function () { return this._attachedPopover; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._validateAttachedPopover(value);
                this._attachedPopover = value;
                // Anchor the popover to the element ref
                this._anchoring.anchor(this.attachedPopover, this._viewContainerRef, this._elementRef);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SatPopoverAnchor.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Re-emit open and close events
                /** @type {?} */
                var opened$ = this._anchoring.popoverOpened
                    .pipe(operators.tap(function () { return _this.popoverOpened.emit(); }));
                /** @type {?} */
                var closed$ = this._anchoring.popoverClosed
                    .pipe(operators.tap(function (value) { return _this.popoverClosed.emit(value); }));
                rxjs.merge(opened$, closed$).pipe(operators.takeUntil(this._onDestroy)).subscribe();
            };
        /**
         * @return {?}
         */
        SatPopoverAnchor.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Gets whether the popover is presently open. */
        /**
         * Gets whether the popover is presently open.
         * @return {?}
         */
        SatPopoverAnchor.prototype.isPopoverOpen = /**
         * Gets whether the popover is presently open.
         * @return {?}
         */
            function () {
                return this._anchoring.isPopoverOpen();
            };
        /** Toggles the popover between the open and closed states. */
        /**
         * Toggles the popover between the open and closed states.
         * @return {?}
         */
        SatPopoverAnchor.prototype.togglePopover = /**
         * Toggles the popover between the open and closed states.
         * @return {?}
         */
            function () {
                this._anchoring.togglePopover();
            };
        /** Opens the popover. */
        /**
         * Opens the popover.
         * @param {?=} options
         * @return {?}
         */
        SatPopoverAnchor.prototype.openPopover = /**
         * Opens the popover.
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                if (options === void 0) {
                    options = {};
                }
                this._anchoring.openPopover(options);
            };
        /** Closes the popover. */
        /**
         * Closes the popover.
         * @param {?=} value
         * @return {?}
         */
        SatPopoverAnchor.prototype.closePopover = /**
         * Closes the popover.
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                this._anchoring.closePopover(value);
            };
        /** Realign the popover to the anchor. */
        /**
         * Realign the popover to the anchor.
         * @return {?}
         */
        SatPopoverAnchor.prototype.realignPopover = /**
         * Realign the popover to the anchor.
         * @return {?}
         */
            function () {
                this._anchoring.realignPopoverToAnchor();
            };
        /** Get a reference to the anchor element. */
        /**
         * Get a reference to the anchor element.
         * @return {?}
         */
        SatPopoverAnchor.prototype.getElement = /**
         * Get a reference to the anchor element.
         * @return {?}
         */
            function () {
                return this._elementRef;
            };
        /** Throws an error if the popover instance is not provided. */
        /**
         * Throws an error if the popover instance is not provided.
         * @param {?} popover
         * @return {?}
         */
        SatPopoverAnchor.prototype._validateAttachedPopover = /**
         * Throws an error if the popover instance is not provided.
         * @param {?} popover
         * @return {?}
         */
            function (popover) {
                if (!popover || !(popover instanceof SatPopover)) {
                    throw getInvalidPopoverError();
                }
            };
        SatPopoverAnchor.decorators = [
            { type: core.Directive, args: [{
                        selector: '[satPopoverAnchorFor]',
                        exportAs: 'satPopoverAnchor',
                        providers: [SatPopoverAnchoringService],
                    },] }
        ];
        /** @nocollapse */
        SatPopoverAnchor.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ViewContainerRef },
                { type: SatPopoverAnchoringService }
            ];
        };
        SatPopoverAnchor.propDecorators = {
            attachedPopover: [{ type: core.Input, args: ['satPopoverAnchorFor',] }],
            popoverOpened: [{ type: core.Output }],
            popoverClosed: [{ type: core.Output }]
        };
        return SatPopoverAnchor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SatPopoverHoverDirective = /** @class */ (function () {
        function SatPopoverHoverDirective(anchor) {
            this.anchor = anchor;
            this._satPopoverHover = 0;
            /**
             * Emits when the directive is destroyed.
             */
            this._onDestroy = new rxjs.Subject();
            /**
             * Emits when the user's mouse enters the element.
             */
            this._onMouseEnter = new rxjs.Subject();
            /**
             * Emits when the user's mouse leaves the element.
             */
            this._onMouseLeave = new rxjs.Subject();
        }
        Object.defineProperty(SatPopoverHoverDirective.prototype, "satPopoverHover", {
            /**
             * Amount of time to delay (ms) after hovering starts before
             * the popover opens. Defaults to 0ms.
             */
            get: /**
             * Amount of time to delay (ms) after hovering starts before
             * the popover opens. Defaults to 0ms.
             * @return {?}
             */ function () { return this._satPopoverHover; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._satPopoverHover = coercion.coerceNumberProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SatPopoverHoverDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Whenever the user hovers this host element, delay the configured
                // amount of time and open the popover. Terminate if the mouse leaves
                // the host element before the delay is complete.
                this._onMouseEnter
                    .pipe(operators.switchMap(function () {
                    return rxjs.of(null).pipe(operators.delay(_this._satPopoverHover || 0), operators.takeUntil(_this._onMouseLeave));
                }), operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this.anchor.openPopover(); });
            };
        /**
         * @return {?}
         */
        SatPopoverHoverDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        SatPopoverHoverDirective.prototype.showPopover = /**
         * @return {?}
         */
            function () {
                this._onMouseEnter.next();
            };
        /**
         * @return {?}
         */
        SatPopoverHoverDirective.prototype.closePopover = /**
         * @return {?}
         */
            function () {
                this._onMouseLeave.next();
                this.anchor.closePopover();
            };
        SatPopoverHoverDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[satPopoverHover]'
                    },] }
        ];
        /** @nocollapse */
        SatPopoverHoverDirective.ctorParameters = function () {
            return [
                { type: SatPopoverAnchor }
            ];
        };
        SatPopoverHoverDirective.propDecorators = {
            satPopoverHover: [{ type: core.Input }],
            showPopover: [{ type: core.HostListener, args: ['mouseenter',] }],
            closePopover: [{ type: core.HostListener, args: ['mouseleave',] }]
        };
        return SatPopoverHoverDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SatPopoverModule = /** @class */ (function () {
        function SatPopoverModule() {
        }
        SatPopoverModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            a11y.A11yModule,
                            bidi.BidiModule,
                        ],
                        declarations: [
                            SatPopover,
                            SatPopoverAnchor,
                            SatPopoverHoverDirective,
                        ],
                        exports: [
                            SatPopover,
                            SatPopoverAnchor,
                            SatPopoverHoverDirective,
                            bidi.BidiModule,
                        ]
                    },] }
        ];
        return SatPopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    exports.SatPopoverModule = SatPopoverModule;
    exports.SatPopoverAnchor = SatPopoverAnchor;
    exports.SatPopoverAnchoringService = SatPopoverAnchoringService;
    exports.SatPopover = SatPopover;
    exports.SatPopoverHoverDirective = SatPopoverHoverDirective;
    exports.a = transformPopover;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmNzdGF0ZS1zYXQtcG9wb3Zlci51bWQuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci5hbmltYXRpb25zLnRzIiwibmc6Ly9AbmNzdGF0ZS9zYXQtcG9wb3Zlci9wb3BvdmVyL25vdGlmaWNhdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AbmNzdGF0ZS9zYXQtcG9wb3Zlci9wb3BvdmVyL3R5cGVzLnRzIiwibmc6Ly9AbmNzdGF0ZS9zYXQtcG9wb3Zlci9wb3BvdmVyL3BvcG92ZXIuZXJyb3JzLnRzIiwibmc6Ly9AbmNzdGF0ZS9zYXQtcG9wb3Zlci9wb3BvdmVyL3BvcG92ZXIuY29tcG9uZW50LnRzIiwibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIm5nOi8vQG5jc3RhdGUvc2F0LXBvcG92ZXIvcG9wb3Zlci9wb3BvdmVyLWFuY2hvcmluZy5zZXJ2aWNlLnRzIiwibmc6Ly9AbmNzdGF0ZS9zYXQtcG9wb3Zlci9wb3BvdmVyL3BvcG92ZXItYW5jaG9yLmRpcmVjdGl2ZS50cyIsIm5nOi8vQG5jc3RhdGUvc2F0LXBvcG92ZXIvcG9wb3Zlci9wb3BvdmVyLWhvdmVyLmRpcmVjdGl2ZS50cyIsIm5nOi8vQG5jc3RhdGUvc2F0LXBvcG92ZXIvcG9wb3Zlci9wb3BvdmVyLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICB0cmlnZ2VyLFxuICBzdGF0ZSxcbiAgc3R5bGUsXG4gIGFuaW1hdGUsXG4gIHRyYW5zaXRpb24sXG4gIEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YVxufSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybVBvcG92ZXI6IEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSA9IHRyaWdnZXIoJ3RyYW5zZm9ybVBvcG92ZXInLCBbXG4gIHRyYW5zaXRpb24oJzplbnRlcicsIFtcbiAgICBzdHlsZSh7b3BhY2l0eTogMCwgdHJhbnNmb3JtOiAnc2NhbGUoMC4zKSd9KSxcbiAgICBhbmltYXRlKCd7e29wZW5UcmFuc2l0aW9ufX0nLFxuICAgICAgc3R5bGUoe29wYWNpdHk6IDEsIHRyYW5zZm9ybTogJ3NjYWxlKDEpJ30pKVxuICBdKSxcbiAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xuICAgIGFuaW1hdGUoJ3t7Y2xvc2VUcmFuc2l0aW9ufX0nLFxuICAgICAgc3R5bGUoe29wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDAuNSknfSkpXG4gIF0pXG5dKTtcbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuLyoqIEVudW1lcmF0ZWQgYWN0aW9ucyBmb3IgYSBwb3BvdmVyIHRvIHBlcmZvcm0uICovXG5leHBvcnQgZW51bSBOb3RpZmljYXRpb25BY3Rpb24ge1xuICAvKiogUG9wb3ZlciBzaG91bGQgb3Blbi4gKi9cbiAgT1BFTixcbiAgLyoqIFBvcG92ZXIgc2hvdWxkIGNsb3NlLiAqL1xuICBDTE9TRSxcbiAgLyoqIFBvcG92ZXIgc2hvdWxkIHRvZ2dsZSBvcGVuIG9yIGNsb3NlZC4gKi9cbiAgVE9HR0xFLFxuICAvKiogUG9wb3ZlciBoYXMgbmV3IHRhcmdldCBwb3NpdGlvbnMuICovXG4gIFJFUE9TSVRJT04sXG4gIC8qKiBQb3BvdmVyIG5lZWRzIG5ldyBjb25maWd1cmF0aW9uLiAqL1xuICBVUERBVEVfQ09ORklHLFxuICAvKiogUG9wb3ZlciBzaG91bGQgcmVhbGlnbiBpdHNlbGYgdG8gdGhlIGFuY2hvci4gICovXG4gIFJFQUxJR04sXG59XG5cbi8qKiBFdmVudCBvYmplY3QgZm9yIGRpc3BhdGNoaW5nIHRvIGFuY2hvcmluZyBzZXJ2aWNlLiAqL1xuZXhwb3J0IGNsYXNzIFBvcG92ZXJOb3RpZmljYXRpb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICAvKiogQWN0aW9uIHRvIHBlcmZvcm0uICovXG4gICAgcHVibGljIGFjdGlvbjogTm90aWZpY2F0aW9uQWN0aW9uLFxuICAgIC8qKiBPcHRpb25hbCBwYXlsb2FkLiAqL1xuICAgIHB1YmxpYyB2YWx1ZT86IGFueVxuICApIHsgfVxufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2Uge1xuXG4gIHByaXZhdGUgc3RvcmUgPSBuZXcgU3ViamVjdDxQb3BvdmVyTm90aWZpY2F0aW9uPigpO1xuXG4gIC8qKiBEaXNwYXRjaCBhIG5vdGlmaWNhdGlvbiB0byBhbGwgc3Vic2NyaWJlcnMuICovXG4gIGRpc3BhdGNoKG5vdGlmaWNhdGlvbjogUG9wb3Zlck5vdGlmaWNhdGlvbikge1xuICAgIHRoaXMuc3RvcmUubmV4dChub3RpZmljYXRpb24pO1xuICB9XG5cbiAgLyoqIFN0cmVhbSBvZiBub3RpZmljYXRpb24gZXZlbnRzLiAqL1xuICBldmVudHMoKTogT2JzZXJ2YWJsZTxQb3BvdmVyTm90aWZpY2F0aW9uPiB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKiogQ29tcGxldGUgZXZlbnQgc3RyZWFtLiAqL1xuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcmUuY29tcGxldGUoKTtcbiAgfVxuXG59XG4iLCJleHBvcnQgdHlwZSBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3kgPSAnbm9vcCcgfCAnYmxvY2snIHwgJ3JlcG9zaXRpb24nIHwgJ2Nsb3NlJztcbmV4cG9ydCBjb25zdCBWQUxJRF9TQ1JPTEw6IFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneVtdID0gW1xuICAnbm9vcCcsXG4gICdibG9jaycsXG4gICdyZXBvc2l0aW9uJyxcbiAgJ2Nsb3NlJ1xuXTtcblxuZXhwb3J0IHR5cGUgU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbiA9ICdiZWZvcmUnIHwgJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgfCAnYWZ0ZXInO1xuZXhwb3J0IGNvbnN0IFZBTElEX0hPUklaX0FMSUdOOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduW10gPSBbXG4gICdiZWZvcmUnLFxuICAnc3RhcnQnLFxuICAnY2VudGVyJyxcbiAgJ2VuZCcsXG4gICdhZnRlcidcbl07XG5cbmV4cG9ydCB0eXBlIFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduID0gJ2Fib3ZlJyAgfCAnc3RhcnQnIHwgJ2NlbnRlcicgfCAnZW5kJyB8ICdiZWxvdyc7XG5leHBvcnQgY29uc3QgVkFMSURfVkVSVF9BTElHTjogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ25bXSA9IFtcbiAgJ2Fib3ZlJyxcbiAgJ3N0YXJ0JyxcbiAgJ2NlbnRlcicsXG4gICdlbmQnLFxuICAnYmVsb3cnXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNhdFBvcG92ZXJPcGVuT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCByZXR1cm4gZm9jdXMgdG8gdGhlIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IGFmdGVyXG4gICAqIGNsb3NpbmcuIERlZmF1bHRzIHRvIHRydWUuXG4gICAqL1xuICByZXN0b3JlRm9jdXM/OiBib29sZWFuO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBzaG91bGQgYmUgZm9jdXNlZCBvbiBvcGVuLiBEZWZhdWx0cyB0byB0cnVlLiAqL1xuICBhdXRvRm9jdXM/OiBib29sZWFuO1xufVxuIiwiaW1wb3J0IHsgVkFMSURfSE9SSVpfQUxJR04sIFZBTElEX1ZFUlRfQUxJR04sIFZBTElEX1NDUk9MTCB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW52YWxpZFBvcG92ZXJFcnJvcigpOiBFcnJvciB7XG4gIHJldHVybiBFcnJvcignU2F0UG9wb3ZlckFuY2hvciBtdXN0IGJlIHByb3ZpZGVkIGFuIFNhdFBvcG92ZXIgY29tcG9uZW50IGluc3RhbmNlLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5hbmNob3JlZFBvcG92ZXJFcnJvcigpOiBFcnJvciB7XG4gIHJldHVybiBFcnJvcignU2F0UG9wb3ZlciBpcyBub3QgYW5jaG9yZWQgdG8gYW55IFNhdFBvcG92ZXJBbmNob3IuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnZhbGlkSG9yaXpvbnRhbEFsaWduRXJyb3IoYWxpZ25tZW50KTogRXJyb3Ige1xuICByZXR1cm4gRXJyb3IoZ2VuZXJhdGVHZW5lcmljRXJyb3IoJ2hvcml6b250YWxBbGlnbi94QWxpZ24nLCBhbGlnbm1lbnQsIFZBTElEX0hPUklaX0FMSUdOKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnZhbGlkVmVydGljYWxBbGlnbkVycm9yKGFsaWdubWVudCk6IEVycm9yIHtcbiAgcmV0dXJuIEVycm9yKGdlbmVyYXRlR2VuZXJpY0Vycm9yKCd2ZXJ0aWNhbEFsaWduL3lBbGlnbicsIGFsaWdubWVudCwgVkFMSURfVkVSVF9BTElHTikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW52YWxpZFNjcm9sbFN0cmF0ZWd5RXJyb3Ioc3RyYXRlZ3kpOiBFcnJvciB7XG4gIHJldHVybiBFcnJvcihnZW5lcmF0ZUdlbmVyaWNFcnJvcignc2Nyb2xsU3RyYXRlZ3knLCBzdHJhdGVneSwgVkFMSURfU0NST0xMKSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlR2VuZXJpY0Vycm9yKGFwaU5hbWU6IHN0cmluZywgaW52YWxpZDogYW55LCB2YWxpZDogc3RyaW5nW10pOiBzdHJpbmcge1xuICByZXR1cm4gYEludmFsaWQgJHthcGlOYW1lfTogJyR7aW52YWxpZH0nLiBWYWxpZCBvcHRpb25zIGFyZSBgICtcbiAgICBgJHt2YWxpZC5tYXAodiA9PiBgJyR7dn0nYCkuam9pbignLCAnKX0uYDtcbn1cbiIsImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBUZW1wbGF0ZVJlZixcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEZvY3VzVHJhcCwgRm9jdXNUcmFwRmFjdG9yeSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5cbmltcG9ydCB7IHRyYW5zZm9ybVBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXIuYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICBOb3RpZmljYXRpb25BY3Rpb24sXG4gIFBvcG92ZXJOb3RpZmljYXRpb24sXG4gIFBvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlLFxufSBmcm9tICcuL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7XG4gIGdldFVuYW5jaG9yZWRQb3BvdmVyRXJyb3IsXG4gIGdldEludmFsaWRIb3Jpem9udGFsQWxpZ25FcnJvcixcbiAgZ2V0SW52YWxpZFZlcnRpY2FsQWxpZ25FcnJvcixcbiAgZ2V0SW52YWxpZFNjcm9sbFN0cmF0ZWd5RXJyb3IsXG59IGZyb20gJy4vcG9wb3Zlci5lcnJvcnMnO1xuaW1wb3J0IHtcbiAgU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5LFxuICBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbiAgVkFMSURfU0NST0xMLFxuICBWQUxJRF9IT1JJWl9BTElHTixcbiAgVkFMSURfVkVSVF9BTElHTixcbiAgU2F0UG9wb3Zlck9wZW5PcHRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcblxuLy8gU2VlIGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLyMuMjUsLjgsLjI1LDEgZm9yIHJlZmVyZW5jZS5cbmNvbnN0IERFRkFVTFRfVFJBTlNJVElPTiAgPSAnMjAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSknO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdzYXQtcG9wb3ZlcicsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGFuaW1hdGlvbnM6IFt0cmFuc2Zvcm1Qb3BvdmVyXSxcbiAgc3R5bGVVcmxzOiBbJy4vcG9wb3Zlci5jb21wb25lbnQuc2NzcyddLFxuICB0ZW1wbGF0ZVVybDogJy4vcG9wb3Zlci5jb21wb25lbnQuaHRtbCcsXG59KVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXIgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgaG9yaXpvbnRhbCBheGlzLiAqL1xuICBASW5wdXQoKVxuICBnZXQgaG9yaXpvbnRhbEFsaWduKCkgeyByZXR1cm4gdGhpcy5faG9yaXpvbnRhbEFsaWduOyB9XG4gIHNldCBob3Jpem9udGFsQWxpZ24odmFsOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduKSB7XG4gICAgdGhpcy5fdmFsaWRhdGVIb3Jpem9udGFsQWxpZ24odmFsKTtcbiAgICBpZiAodGhpcy5faG9yaXpvbnRhbEFsaWduICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuX2hvcml6b250YWxBbGlnbiA9IHZhbDtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OKSk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2hvcml6b250YWxBbGlnbjogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbiA9ICdjZW50ZXInO1xuXG4gIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIHggYXhpcy4gQWxpYXMgZm9yIGBob3Jpem9udGFsQWxpZ25gLiAqL1xuICBASW5wdXQoKVxuICBnZXQgeEFsaWduKCkgeyByZXR1cm4gdGhpcy5ob3Jpem9udGFsQWxpZ247IH1cbiAgc2V0IHhBbGlnbih2YWw6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24pIHsgdGhpcy5ob3Jpem9udGFsQWxpZ24gPSB2YWw7IH1cblxuICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB2ZXJ0aWNhbCBheGlzLiAqL1xuICBASW5wdXQoKVxuICBnZXQgdmVydGljYWxBbGlnbigpIHsgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsQWxpZ247IH1cbiAgc2V0IHZlcnRpY2FsQWxpZ24odmFsOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbikge1xuICAgIHRoaXMuX3ZhbGlkYXRlVmVydGljYWxBbGlnbih2YWwpO1xuICAgIGlmICh0aGlzLl92ZXJ0aWNhbEFsaWduICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuX3ZlcnRpY2FsQWxpZ24gPSB2YWw7XG4gICAgICB0aGlzLl9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uUkVQT1NJVElPTikpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF92ZXJ0aWNhbEFsaWduOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbiA9ICdjZW50ZXInO1xuXG4gIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIHkgYXhpcy4gQWxpYXMgZm9yIGB2ZXJ0aWNhbEFsaWduYC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHlBbGlnbigpIHsgcmV0dXJuIHRoaXMudmVydGljYWxBbGlnbjsgfVxuICBzZXQgeUFsaWduKHZhbDogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24pIHsgdGhpcy52ZXJ0aWNhbEFsaWduID0gdmFsOyB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgYWx3YXlzIG9wZW5zIHdpdGggdGhlIHNwZWNpZmllZCBhbGlnbm1lbnQuICovXG4gIEBJbnB1dCgpXG4gIGdldCBmb3JjZUFsaWdubWVudCgpIHsgcmV0dXJuIHRoaXMuX2ZvcmNlQWxpZ25tZW50OyB9XG4gIHNldCBmb3JjZUFsaWdubWVudCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBjb2VyY2VkVmFsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gICAgaWYgKHRoaXMuX2ZvcmNlQWxpZ25tZW50ICE9PSBjb2VyY2VkVmFsKSB7XG4gICAgICB0aGlzLl9mb3JjZUFsaWdubWVudCA9IGNvZXJjZWRWYWw7XG4gICAgICB0aGlzLl9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uUkVQT1NJVElPTikpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9mb3JjZUFsaWdubWVudCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwb3BvdmVyJ3MgYWxpZ25tZW50IGlzIGxvY2tlZCBhZnRlciBvcGVuaW5nLiBUaGlzIHByZXZlbnRzIHRoZSBwb3BvdmVyXG4gICAqIGZyb20gY2hhbmdpbmcgaXRzIGFsaWduZW1lbnQgd2hlbiBzY3JvbGxpbmcgb3IgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgQElucHV0KClcbiAgZ2V0IGxvY2tBbGlnbm1lbnQoKSB7IHJldHVybiB0aGlzLl9sb2NrQWxpZ25tZW50OyB9XG4gIHNldCBsb2NrQWxpZ25tZW50KHZhbDogYm9vbGVhbikge1xuICAgIGNvbnN0IGNvZXJjZWRWYWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICBpZiAodGhpcy5fbG9ja0FsaWdubWVudCAhPT0gY29lcmNlZFZhbCkge1xuICAgICAgdGhpcy5fbG9ja0FsaWdubWVudCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlJFUE9TSVRJT04pKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfbG9ja0FsaWdubWVudCA9IGZhbHNlO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBzaG91bGQgYmUgZm9jdXNlZCBvbiBvcGVuLiAqL1xuICBASW5wdXQoKVxuICBnZXQgYXV0b0ZvY3VzKCkgeyByZXR1cm4gdGhpcy5fYXV0b0ZvY3VzICYmIHRoaXMuX2F1dG9Gb2N1c092ZXJyaWRlOyB9XG4gIHNldCBhdXRvRm9jdXModmFsOiBib29sZWFuKSB7XG4gICAgdGhpcy5fYXV0b0ZvY3VzID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gIH1cbiAgcHJpdmF0ZSBfYXV0b0ZvY3VzID0gdHJ1ZTtcbiAgX2F1dG9Gb2N1c092ZXJyaWRlID0gdHJ1ZTtcblxuIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCByZXR1cm4gZm9jdXMgdG8gdGhlIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IGFmdGVyIGNsb3NpbmcuICovXG4gQElucHV0KClcbiAgZ2V0IHJlc3RvcmVGb2N1cygpIHsgcmV0dXJuIHRoaXMuX3Jlc3RvcmVGb2N1cyAmJiB0aGlzLl9yZXN0b3JlRm9jdXNPdmVycmlkZTsgfVxuICBzZXQgcmVzdG9yZUZvY3VzKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX3Jlc3RvcmVGb2N1cyA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICB9XG4gIHByaXZhdGUgX3Jlc3RvcmVGb2N1cyA9IHRydWU7XG4gIF9yZXN0b3JlRm9jdXNPdmVycmlkZSA9IHRydWU7XG5cbiAgLyoqIEhvdyB0aGUgcG9wb3ZlciBzaG91bGQgaGFuZGxlIHNjcm9sbGluZy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHNjcm9sbFN0cmF0ZWd5KCkgeyByZXR1cm4gdGhpcy5fc2Nyb2xsU3RyYXRlZ3k7IH1cbiAgc2V0IHNjcm9sbFN0cmF0ZWd5KHZhbDogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5KSB7XG4gICAgdGhpcy5fdmFsaWRhdGVTY3JvbGxTdHJhdGVneSh2YWwpO1xuICAgIGlmICh0aGlzLl9zY3JvbGxTdHJhdGVneSAhPT0gdmFsKSB7XG4gICAgICB0aGlzLl9zY3JvbGxTdHJhdGVneSA9IHZhbDtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5VUERBVEVfQ09ORklHKSk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5OiBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3kgPSAncmVwb3NpdGlvbic7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgc2hvdWxkIGhhdmUgYSBiYWNrZHJvcCAoaW5jbHVkZXMgY2xvc2luZyBvbiBjbGljaykuICovXG4gIEBJbnB1dCgpXG4gIGdldCBoYXNCYWNrZHJvcCgpIHsgcmV0dXJuIHRoaXMuX2hhc0JhY2tkcm9wOyB9XG4gIHNldCBoYXNCYWNrZHJvcCh2YWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9oYXNCYWNrZHJvcCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICB9XG4gIHByaXZhdGUgX2hhc0JhY2tkcm9wID0gZmFsc2U7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgc2hvdWxkIGNsb3NlIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBiYWNrZHJvcCBvciBwcmVzc2VzIEVTQy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGludGVyYWN0aXZlQ2xvc2UoKSB7IHJldHVybiB0aGlzLl9pbnRlcmFjdGl2ZUNsb3NlOyB9XG4gIHNldCBpbnRlcmFjdGl2ZUNsb3NlKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX2ludGVyYWN0aXZlQ2xvc2UgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgfVxuICBwcml2YXRlIF9pbnRlcmFjdGl2ZUNsb3NlID0gdHJ1ZTtcblxuICAvKiogQ3VzdG9tIHRyYW5zaXRpb24gdG8gdXNlIHdoaWxlIG9wZW5pbmcuICovXG4gIEBJbnB1dCgpXG4gIGdldCBvcGVuVHJhbnNpdGlvbigpIHsgcmV0dXJuIHRoaXMuX29wZW5UcmFuc2l0aW9uOyB9XG4gIHNldCBvcGVuVHJhbnNpdGlvbih2YWw6IHN0cmluZykge1xuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMuX29wZW5UcmFuc2l0aW9uID0gdmFsO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9vcGVuVHJhbnNpdGlvbiA9IERFRkFVTFRfVFJBTlNJVElPTjtcblxuICAvKiogQ3VzdG9tIHRyYW5zaXRpb24gdG8gdXNlIHdoaWxlIGNsb3NpbmcuICovXG4gIEBJbnB1dCgpXG4gIGdldCBjbG9zZVRyYW5zaXRpb24oKSB7IHJldHVybiB0aGlzLl9jbG9zZVRyYW5zaXRpb247IH1cbiAgc2V0IGNsb3NlVHJhbnNpdGlvbih2YWw6IHN0cmluZykge1xuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMuX2Nsb3NlVHJhbnNpdGlvbiA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfY2xvc2VUcmFuc2l0aW9uID0gREVGQVVMVF9UUkFOU0lUSU9OO1xuXG4gIC8qKiBPcHRpb25hbCBiYWNrZHJvcCBjbGFzcy4gKi9cbiAgQElucHV0KCkgYmFja2Ryb3BDbGFzcyA9ICcnO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIG9wZW5lZC4gKi9cbiAgQE91dHB1dCgpIG9wZW5lZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQuICovXG4gIEBPdXRwdXQoKSBjbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBoYXMgZmluaXNoZWQgb3BlbmluZy4gKi9cbiAgQE91dHB1dCgpIGFmdGVyT3BlbiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBoYXMgZmluaXNoZWQgY2xvc2luZy4gKi9cbiAgQE91dHB1dCgpIGFmdGVyQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIGJhY2tkcm9wIGlzIGNsaWNrZWQuICovXG4gIEBPdXRwdXQoKSBiYWNrZHJvcENsaWNrZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gYSBrZXlkb3duIGV2ZW50IGlzIHRhcmdldGVkIHRvIHRoaXMgcG9wb3ZlcidzIG92ZXJsYXkuICovXG4gIEBPdXRwdXQoKSBvdmVybGF5S2V5ZG93biA9IG5ldyBFdmVudEVtaXR0ZXI8S2V5Ym9hcmRFdmVudD4oKTtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRlbXBsYXRlIHNvIGl0IGNhbiBiZSBwbGFjZWQgd2l0aGluIGEgcG9ydGFsLiAqL1xuICBAVmlld0NoaWxkKFRlbXBsYXRlUmVmKSBfdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqIENsYXNzZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHBvcG92ZXIgZm9yIHNldHRpbmcgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIG9yaWdpbi4gKi9cbiAgX2NsYXNzTGlzdDogYW55ID0ge307XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIF9vcGVuID0gZmFsc2U7XG5cbiAgLyoqIEluc3RhbmNlIG9mIG5vdGlmaWNhdGlvbiBzZXJ2aWNlLiBXaWxsIGJlIHVuZGVmaW5lZCB1bnRpbCBhdHRhY2hlZCB0byBhbiBhbmNob3IuICovXG4gIF9ub3RpZmljYXRpb25zOiBQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZTtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRvIGJ1aWxkIGEgZm9jdXMgdHJhcCBhcm91bmQuICovXG4gIEBWaWV3Q2hpbGQoJ2ZvY3VzVHJhcEVsZW1lbnQnKVxuICBwcml2YXRlIF9mb2N1c1RyYXBFbGVtZW50OiBFbGVtZW50UmVmO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBiZWZvcmUgb3BlbmluZy4gKi9cbiAgcHJpdmF0ZSBfcHJldmlvdXNseUZvY3VzZWRFbGVtZW50OiBIVE1MRWxlbWVudDtcblxuICAvKiogUmVmZXJlbmNlIHRvIGEgZm9jdXMgdHJhcCBhcm91bmQgdGhlIHBvcG92ZXIuICovXG4gIHByaXZhdGUgX2ZvY3VzVHJhcDogRm9jdXNUcmFwO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2ZvY3VzVHJhcEZhY3Rvcnk6IEZvY3VzVHJhcEZhY3RvcnksXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueVxuICApIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX3NldEFsaWdubWVudENsYXNzZXMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9ub3RpZmljYXRpb25zKSB7XG4gICAgICB0aGlzLl9ub3RpZmljYXRpb25zLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKiogT3BlbiB0aGlzIHBvcG92ZXIuICovXG4gIG9wZW4ob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zID0ge30pOiB2b2lkIHtcbiAgICBjb25zdCBub3RpZmljYXRpb24gPSBuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uT1BFTiwgb3B0aW9ucyk7XG4gICAgdGhpcy5fZGlzcGF0Y2hBY3Rpb25Ob3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIC8qKiBDbG9zZSB0aGlzIHBvcG92ZXIuICovXG4gIGNsb3NlKHZhbHVlPzogYW55KTogdm9pZCB7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLkNMT1NFLCB2YWx1ZSk7XG4gICAgdGhpcy5fZGlzcGF0Y2hBY3Rpb25Ob3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIC8qKiBUb2dnbGUgdGhpcyBwb3BvdmVyIG9wZW4gb3IgY2xvc2VkLiAqL1xuICB0b2dnbGUoKTogdm9pZCB7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlRPR0dMRSk7XG4gICAgdGhpcy5fZGlzcGF0Y2hBY3Rpb25Ob3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIC8qKiBSZWFsaWduIHRoZSBwb3BvdmVyIHRvIHRoZSBhbmNob3IuICovXG4gIHJlYWxpZ24oKTogdm9pZCB7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlJFQUxJR04pO1xuICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvKiogR2V0cyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBpc09wZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX29wZW47XG4gIH1cblxuICAvKiogR2V0cyBhbiBhbmltYXRpb24gY29uZmlnIHdpdGggY3VzdG9taXplZCAob3IgZGVmYXVsdCkgdHJhbnNpdGlvbiB2YWx1ZXMuICovXG4gIF9nZXRBbmltYXRpb24oKTogeyB2YWx1ZTogYW55LCBwYXJhbXM6IGFueSB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6ICd2aXNpYmxlJyxcbiAgICAgIHBhcmFtczogeyBvcGVuVHJhbnNpdGlvbjogdGhpcy5vcGVuVHJhbnNpdGlvbiwgY2xvc2VUcmFuc2l0aW9uOiB0aGlzLmNsb3NlVHJhbnNpdGlvbiB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBDYWxsYmFjayBmb3Igd2hlbiB0aGUgcG9wb3ZlciBpcyBmaW5pc2hlZCBhbmltYXRpbmcgaW4gb3Igb3V0LiAqL1xuICBfb25BbmltYXRpb25Eb25lKGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xuICAgIGlmIChldmVudC50b1N0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgIHRoaXMuX3RyYXBGb2N1cygpO1xuICAgICAgdGhpcy5hZnRlck9wZW4uZW1pdCgpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ3ZvaWQnKSB7XG4gICAgICB0aGlzLl9yZXN0b3JlRm9jdXNBbmREZXN0cm95VHJhcCgpO1xuICAgICAgdGhpcy5hZnRlckNsb3NlLmVtaXQoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQXBwbHkgYWxpZ25tZW50IGNsYXNzZXMgYmFzZWQgb24gYWxpZ25tZW50IGlucHV0cy4gKi9cbiAgX3NldEFsaWdubWVudENsYXNzZXMoaG9yaXpBbGlnbiA9IHRoaXMuaG9yaXpvbnRhbEFsaWduLCB2ZXJ0QWxpZ24gPSB0aGlzLnZlcnRpY2FsQWxpZ24pIHtcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ3NhdC1wb3BvdmVyLWJlZm9yZSddID0gaG9yaXpBbGlnbiA9PT0gJ2JlZm9yZScgfHwgaG9yaXpBbGlnbiA9PT0gJ2VuZCc7XG4gICAgdGhpcy5fY2xhc3NMaXN0WydzYXQtcG9wb3Zlci1hZnRlciddICA9IGhvcml6QWxpZ24gPT09ICdhZnRlcicgfHwgaG9yaXpBbGlnbiA9PT0gJ3N0YXJ0JztcblxuICAgIHRoaXMuX2NsYXNzTGlzdFsnc2F0LXBvcG92ZXItYWJvdmUnXSA9IHZlcnRBbGlnbiA9PT0gJ2Fib3ZlJyB8fCB2ZXJ0QWxpZ24gPT09ICdlbmQnO1xuICAgIHRoaXMuX2NsYXNzTGlzdFsnc2F0LXBvcG92ZXItYmVsb3cnXSA9IHZlcnRBbGlnbiA9PT0gJ2JlbG93JyB8fCB2ZXJ0QWxpZ24gPT09ICdzdGFydCc7XG5cbiAgICB0aGlzLl9jbGFzc0xpc3RbJ3NhdC1wb3BvdmVyLWNlbnRlciddID0gaG9yaXpBbGlnbiA9PT0gJ2NlbnRlcicgfHwgdmVydEFsaWduID09PSAnY2VudGVyJztcbiAgfVxuXG4gIC8qKiBNb3ZlIHRoZSBmb2N1cyBpbnNpZGUgdGhlIGZvY3VzIHRyYXAgYW5kIHJlbWVtYmVyIHdoZXJlIHRvIHJldHVybiBsYXRlci4gKi9cbiAgcHJpdmF0ZSBfdHJhcEZvY3VzKCk6IHZvaWQge1xuICAgIHRoaXMuX3NhdmVQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKTtcblxuICAgIC8vIFRoZXJlIHdvbid0IGJlIGEgZm9jdXMgdHJhcCBlbGVtZW50IGlmIHRoZSBjbG9zZSBhbmltYXRpb24gc3RhcnRzIGJlZm9yZSBvcGVuIGZpbmlzaGVzXG4gICAgaWYgKCF0aGlzLl9mb2N1c1RyYXBFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwRWxlbWVudCkge1xuICAgICAgdGhpcy5fZm9jdXNUcmFwID0gdGhpcy5fZm9jdXNUcmFwRmFjdG9yeS5jcmVhdGUodGhpcy5fZm9jdXNUcmFwRWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hdXRvRm9jdXMpIHtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcC5mb2N1c0luaXRpYWxFbGVtZW50V2hlblJlYWR5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFJlc3RvcmUgZm9jdXMgdG8gdGhlIGVsZW1lbnQgZm9jdXNlZCBiZWZvcmUgdGhlIHBvcG92ZXIgb3BlbmVkLiBBbHNvIGRlc3Ryb3kgdHJhcC4gKi9cbiAgcHJpdmF0ZSBfcmVzdG9yZUZvY3VzQW5kRGVzdHJveVRyYXAoKTogdm9pZCB7XG4gICAgY29uc3QgdG9Gb2N1cyA9IHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudDtcblxuICAgIC8vIE11c3QgY2hlY2sgYWN0aXZlIGVsZW1lbnQgaXMgZm9jdXNhYmxlIGZvciBJRSBzYWtlXG4gICAgaWYgKHRvRm9jdXMgJiYgJ2ZvY3VzJyBpbiB0b0ZvY3VzICYmIHRoaXMucmVzdG9yZUZvY3VzKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX2ZvY3VzVHJhcCkge1xuICAgICAgdGhpcy5fZm9jdXNUcmFwLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKiogU2F2ZSBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBmb2N1c2VkIGJlZm9yZSB0aGUgcG9wb3ZlciB3YXMgb3BlbmVkLiAqL1xuICBwcml2YXRlIF9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xuICAgICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudDtcbiAgICB9XG4gIH1cblxuICAvKiogRGlzcGF0Y2ggYSBub3RpZmljYXRpb24gdG8gdGhlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlLCBpZiBwb3NzaWJsZS4gKi9cbiAgcHJpdmF0ZSBfZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obm90aWZpY2F0aW9uOiBQb3BvdmVyTm90aWZpY2F0aW9uKSB7XG4gICAgaWYgKHRoaXMuX25vdGlmaWNhdGlvbnMpIHtcbiAgICAgIHRoaXMuX25vdGlmaWNhdGlvbnMuZGlzcGF0Y2gobm90aWZpY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKiogRGlzcGF0Y2ggYSBub3RpZmljYXRpb24gdG8gdGhlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlIGFuZCB0aHJvdyBpZiB1bmFibGUgdG8uICovXG4gIHByaXZhdGUgX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogUG9wb3Zlck5vdGlmaWNhdGlvbikge1xuICAgIGlmICghdGhpcy5fbm90aWZpY2F0aW9ucykge1xuICAgICAgdGhyb3cgZ2V0VW5hbmNob3JlZFBvcG92ZXJFcnJvcigpO1xuICAgIH1cblxuICAgIHRoaXMuX25vdGlmaWNhdGlvbnMuZGlzcGF0Y2gobm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIC8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGFsaWdubWVudCBpcyBub3QgYSB2YWxpZCBob3Jpem9udGFsQWxpZ24uICovXG4gIHByaXZhdGUgX3ZhbGlkYXRlSG9yaXpvbnRhbEFsaWduKHBvczogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbik6IHZvaWQge1xuICAgIGlmIChWQUxJRF9IT1JJWl9BTElHTi5pbmRleE9mKHBvcykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBnZXRJbnZhbGlkSG9yaXpvbnRhbEFsaWduRXJyb3IocG9zKTtcbiAgICB9XG4gIH1cblxuICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBhbGlnbm1lbnQgaXMgbm90IGEgdmFsaWQgdmVydGljYWxBbGlnbi4gKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdGVWZXJ0aWNhbEFsaWduKHBvczogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24pOiB2b2lkIHtcbiAgICBpZiAoVkFMSURfVkVSVF9BTElHTi5pbmRleE9mKHBvcykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBnZXRJbnZhbGlkVmVydGljYWxBbGlnbkVycm9yKHBvcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgc2Nyb2xsIHN0cmF0ZWd5IGlzIG5vdCBhIHZhbGlkIHN0cmF0ZWd5LiAqL1xuICBwcml2YXRlIF92YWxpZGF0ZVNjcm9sbFN0cmF0ZWd5KHN0cmF0ZWd5OiBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3kpOiB2b2lkIHtcbiAgICBpZiAoVkFMSURfU0NST0xMLmluZGV4T2Yoc3RyYXRlZ3kpID09PSAtMSkge1xuICAgICAgdGhyb3cgZ2V0SW52YWxpZFNjcm9sbFN0cmF0ZWd5RXJyb3Ioc3RyYXRlZ3kpO1xuICAgIH1cbiAgfVxufVxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsImltcG9ydCB7XG4gIEVsZW1lbnRSZWYsXG4gIEluamVjdGFibGUsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIsXG4gIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSxcbiAgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsXG4gIE92ZXJsYXksXG4gIE92ZXJsYXlDb25maWcsXG4gIE92ZXJsYXlSZWYsXG4gIFNjcm9sbFN0cmF0ZWd5LFxuICBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MsXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5LCBEaXJlY3Rpb259IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwsIHRha2UsIGZpbHRlciwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBTYXRQb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbiAgU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5LFxuICBTYXRQb3BvdmVyT3Blbk9wdGlvbnMsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5pbXBvcnQgeyBQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZSwgTm90aWZpY2F0aW9uQWN0aW9uIH0gZnJvbSAnLi9ub3RpZmljYXRpb24uc2VydmljZSc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBwcm92aWRlZCBieSB0aGUgcG9wb3ZlciBmb3IgdGhlIGFuY2hvcmluZyBzZXJ2aWNlXG4gKiB0byBidWlsZCB0aGUgY29ycmVjdCBvdmVybGF5IGNvbmZpZy5cbiAqL1xuaW50ZXJmYWNlIFBvcG92ZXJDb25maWcge1xuICBob3Jpem9udGFsQWxpZ246IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ247XG4gIHZlcnRpY2FsQWxpZ246IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduO1xuICBoYXNCYWNrZHJvcDogYm9vbGVhbjtcbiAgYmFja2Ryb3BDbGFzczogc3RyaW5nO1xuICBzY3JvbGxTdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5O1xuICBmb3JjZUFsaWdubWVudDogYm9vbGVhbjtcbiAgbG9ja0FsaWdubWVudDogYm9vbGVhbjtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIHBvcG92ZXJPcGVuZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgcG9wb3ZlckNsb3NlZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSBjb250YWluaW5nIHRoZSBwb3BvdmVyIGNvbXBvbmVudC4gKi9cbiAgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHBvcG92ZXIuICovXG4gIHByaXZhdGUgX3BvcG92ZXI6IFNhdFBvcG92ZXI7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdmlldyBjb250YWluZXIgZm9yIHRoZSBwb3BvdmVyIHRlbXBsYXRlLiAqL1xuICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGFuY2hvciBlbGVtZW50LiAqL1xuICBwcml2YXRlIF9hbmNob3I6IEVsZW1lbnRSZWY7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byBhIHRlbXBsYXRlIHBvcnRhbCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGF0dGFjaGVkLiAqL1xuICBwcml2YXRlIF9wb3J0YWw6IFRlbXBsYXRlUG9ydGFsPGFueT47XG5cbiAgLyoqIENvbW11bmljYXRpb25zIGNoYW5uZWwgd2l0aCB0aGUgcG9wb3Zlci4gKi9cbiAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uczogUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2U7XG5cbiAgLyoqIFNpbmdsZSBzdWJzY3JpcHRpb24gdG8gbm90aWZpY2F0aW9ucyBzZXJ2aWNlIGV2ZW50cy4gKi9cbiAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKiBTaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHBvc2l0aW9uIGNoYW5nZXMuICovXG4gIHByaXZhdGUgX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIHByaXZhdGUgX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHNlcnZpY2UgaXMgZGVzdHJveWVkLiAqL1xuICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyOiBEaXJlY3Rpb25hbGl0eVxuICApIHsgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIC8vIERlc3Ryb3kgcG9wb3ZlciBiZWZvcmUgdGVybWluYXRpbmcgc3Vic2NyaXB0aW9ucyBzbyB0aGF0IGFueSByZXN1bHRpbmdcbiAgICAvLyBkZXRhY2htZW50cyB1cGRhdGUgJ2Nsb3NlZCBzdGF0ZSdcbiAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgLy8gVGVybWluYXRlIHN1YnNjcmlwdGlvbnNcbiAgICBpZiAodGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG5cbiAgICB0aGlzLnBvcG92ZXJPcGVuZWQuY29tcGxldGUoKTtcbiAgICB0aGlzLnBvcG92ZXJDbG9zZWQuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBBbmNob3IgYSBwb3BvdmVyIGluc3RhbmNlIHRvIGEgdmlldyBhbmQgY29ubmVjdGlvbiBlbGVtZW50LiAqL1xuICBhbmNob3IocG9wb3ZlcjogU2F0UG9wb3Zlciwgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgYW5jaG9yOiBFbGVtZW50UmVmKTogdm9pZCB7XG4gICAgLy8gRGVzdHJveSBhbnkgcHJldmlvdXMgcG9wb3ZlcnNcbiAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgLy8gQXNzaWduIGxvY2FsIHJlZnNcbiAgICB0aGlzLl9wb3BvdmVyID0gcG9wb3ZlcjtcbiAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICB0aGlzLl9hbmNob3IgPSBhbmNob3I7XG5cbiAgICAvLyBQcm92aWRlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlIGFzIGEgY29tbXVuaWNhdGlvbiBjaGFubmVsIGJldHdlZW4gcG9wb3ZlciBhbmQgYW5jaG9yLlxuICAgIC8vIFRoZW4gc3Vic2NyaWJlIHRvIG5vdGlmaWNhdGlvbnMgdG8gdGFrZSBhcHByb3ByaWF0ZSBhY3Rpb25zLlxuICAgIHRoaXMuX3BvcG92ZXIuX25vdGlmaWNhdGlvbnMgPSB0aGlzLl9ub3RpZmljYXRpb25zID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlKCk7XG4gICAgdGhpcy5fc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zKCk7XG4gIH1cblxuICAvKiogR2V0cyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBpc1BvcG92ZXJPcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9wb3BvdmVyT3BlbjtcbiAgfVxuXG4gIC8qKiBUb2dnbGVzIHRoZSBwb3BvdmVyIGJldHdlZW4gdGhlIG9wZW4gYW5kIGNsb3NlZCBzdGF0ZXMuICovXG4gIHRvZ2dsZVBvcG92ZXIoKTogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuID8gdGhpcy5jbG9zZVBvcG92ZXIoKSA6IHRoaXMub3BlblBvcG92ZXIoKTtcbiAgfVxuXG4gIC8qKiBPcGVucyB0aGUgcG9wb3Zlci4gKi9cbiAgb3BlblBvcG92ZXIob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zID0ge30pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICB0aGlzLl9hcHBseU9wZW5PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9CYWNrZHJvcCgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9Fc2NhcGUoKTtcbiAgICAgIHRoaXMuX3N1YnNjcmliZVRvRGV0YWNobWVudHMoKTtcbiAgICAgIHRoaXMuX3NhdmVPcGVuZWRTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDbG9zZXMgdGhlIHBvcG92ZXIuICovXG4gIGNsb3NlUG9wb3Zlcih2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9zYXZlQ2xvc2VkU3RhdGUodmFsdWUpO1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICB9XG4gIH1cblxuICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICByZWFsaWduUG9wb3ZlclRvQW5jaG9yKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLl9vdmVybGF5UmVmLmdldENvbmZpZygpO1xuICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb25maWcucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgICBzdHJhdGVneS5yZWFwcGx5TGFzdFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuICovXG4gIGdldEFuY2hvckVsZW1lbnQoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgfVxuXG4gIC8qKiBBcHBseSBiZWhhdmlvciBwcm9wZXJ0aWVzIG9uIHRoZSBwb3BvdmVyIGJhc2VkIG9uIHRoZSBvcGVuIG9wdGlvbnMuICovXG4gIHByaXZhdGUgX2FwcGx5T3Blbk9wdGlvbnMob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zKTogdm9pZCB7XG4gICAgLy8gT25seSBvdmVycmlkZSByZXN0b3JlRm9jdXMgYXMgYGZhbHNlYCBpZiB0aGUgb3B0aW9uIGlzIGV4cGxpY2l0bHkgYGZhbHNlYFxuICAgIGNvbnN0IHJlc3RvcmVGb2N1cyA9IG9wdGlvbnMucmVzdG9yZUZvY3VzICE9PSBmYWxzZTtcbiAgICB0aGlzLl9wb3BvdmVyLl9yZXN0b3JlRm9jdXNPdmVycmlkZSA9IHJlc3RvcmVGb2N1cztcblxuICAgIC8vIE9ubHkgb3ZlcnJpZGUgYXV0b0ZvY3VzIGFzIGBmYWxzZWAgaWYgdGhlIG9wdGlvbiBpcyBleHBsaWNpdGx5IGBmYWxzZWBcbiAgICBjb25zdCBhdXRvRm9jdXMgPSBvcHRpb25zLmF1dG9Gb2N1cyAhPT0gZmFsc2U7XG4gICAgdGhpcy5fcG9wb3Zlci5fYXV0b0ZvY3VzT3ZlcnJpZGUgPSBhdXRvRm9jdXM7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuIG92ZXJsYXkgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHBvcnRhbC4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcbiAgICAvLyBDcmVhdGUgb3ZlcmxheSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX3BvcG92ZXIuX3RlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcblxuICAgICAgY29uc3QgcG9wb3ZlckNvbmZpZyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbEFsaWduOiB0aGlzLl9wb3BvdmVyLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5fcG9wb3Zlci52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBoYXNCYWNrZHJvcDogdGhpcy5fcG9wb3Zlci5oYXNCYWNrZHJvcCxcbiAgICAgICAgYmFja2Ryb3BDbGFzczogdGhpcy5fcG9wb3Zlci5iYWNrZHJvcENsYXNzLFxuICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fcG9wb3Zlci5zY3JvbGxTdHJhdGVneSxcbiAgICAgICAgZm9yY2VBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgIGxvY2tBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIubG9ja0FsaWdubWVudCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKHBvcG92ZXJDb25maWcsIHRoaXMuX2FuY2hvcik7XG5cbiAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKFxuICAgICAgICBvdmVybGF5Q29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgICApO1xuXG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheUNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgb3BlbiB0aGUgcG9wb3ZlclxuICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gIH1cblxuXG4gIC8qKiBSZW1vdmVzIHRoZSBwb3BvdmVyIGZyb20gdGhlIERPTS4gRG9lcyBOT1QgdXBkYXRlIG9wZW4gc3RhdGUuICovXG4gIHByaXZhdGUgX2Rlc3Ryb3lQb3BvdmVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcG9wb3ZlciBpbW1lZGlhdGVseSBpZiBpdCBpcyBjbG9zZWQsIG9yIHdhaXRzIHVudGlsIGl0XG4gICAqIGhhcyBiZWVuIGNsb3NlZCB0byBkZXN0cm95IGl0LlxuICAgKi9cbiAgcHJpdmF0ZSBfZGVzdHJveVBvcG92ZXJPbmNlQ2xvc2VkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzUG9wb3Zlck9wZW4oKSAmJiB0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaG1lbnRzKCkucGlwZShcbiAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2Rlc3Ryb3lQb3BvdmVyKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGFwcHJvcHJpYXRlIGFuY2hvciBtZXRob2Qgd2hlbiBhbiBldmVudCBpcyBkaXNwYXRjaGVkIHRocm91Z2hcbiAgICogdGhlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlLlxuICAgKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbiA9IHRoaXMuX25vdGlmaWNhdGlvbnMuZXZlbnRzKClcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmFjdGlvbikge1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLk9QRU46XG4gICAgICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLkNMT1NFOlxuICAgICAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoZXZlbnQudmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBOb3RpZmljYXRpb25BY3Rpb24uVE9HR0xFOlxuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3BvdmVyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OOlxuICAgICAgICAgICAgLy8gVE9ETzogV2hlbiB0aGUgb3ZlcmxheSdzIHBvc2l0aW9uIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkLCBkbyBub3QgZGVzdHJveVxuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLlVQREFURV9DT05GSUc6XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95UG9wb3Zlck9uY2VDbG9zZWQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLlJFQUxJR046XG4gICAgICAgICAgICB0aGlzLnJlYWxpZ25Qb3BvdmVyVG9BbmNob3IoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBDbG9zZSBwb3BvdmVyIHdoZW4gYmFja2Ryb3AgaXMgY2xpY2tlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcCgpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuYmFja2Ryb3BDbGljaygpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKCgpID0+IHRoaXMuX3BvcG92ZXIuYmFja2Ryb3BDbGlja2VkLmVtaXQoKSksXG4gICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl9wb3BvdmVyLmludGVyYWN0aXZlQ2xvc2UpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyQ2xvc2VkKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2VQb3BvdmVyKCkpO1xuICB9XG5cbiAgLyoqIENsb3NlIHBvcG92ZXIgd2hlbiBlc2NhcGUga2V5ZG93biBldmVudCBvY2N1cnMuICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvRXNjYXBlKCk6IHZvaWQge1xuICAgIHRoaXMuX292ZXJsYXlSZWZcbiAgICAgIC5rZXlkb3duRXZlbnRzKClcbiAgICAgIC5waXBlKFxuICAgICAgICB0YXAoZXZlbnQgPT4gdGhpcy5fcG9wb3Zlci5vdmVybGF5S2V5ZG93bi5lbWl0KGV2ZW50KSksXG4gICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudC5rZXlDb2RlID09PSBFU0NBUEUpLFxuICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fcG9wb3Zlci5pbnRlcmFjdGl2ZUNsb3NlKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMucG9wb3ZlckNsb3NlZCksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlUG9wb3ZlcigpKTtcbiAgfVxuXG4gIC8qKiBTZXQgc3RhdGUgYmFjayB0byBjbG9zZWQgd2hlbiBkZXRhY2hlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9EZXRhY2htZW50cygpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuZGV0YWNobWVudHMoKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3NhdmVDbG9zZWRTdGF0ZSgpKTtcbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVPcGVuZWRTdGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICB0aGlzLl9wb3BvdmVyLl9vcGVuID0gdGhpcy5fcG9wb3Zlck9wZW4gPSB0cnVlO1xuXG4gICAgICB0aGlzLnBvcG92ZXJPcGVuZWQubmV4dCgpO1xuICAgICAgdGhpcy5fcG9wb3Zlci5vcGVuZWQuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBjbG9zZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVDbG9zZWRTdGF0ZSh2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wb3BvdmVyT3Blbikge1xuICAgICAgdGhpcy5fcG9wb3Zlci5fb3BlbiA9IHRoaXMuX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgICAgIHRoaXMucG9wb3ZlckNsb3NlZC5uZXh0KHZhbHVlKTtcbiAgICAgIHRoaXMuX3BvcG92ZXIuY2xvc2VkLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gIHByaXZhdGUgX2dldERpcmVjdGlvbigpOiBEaXJlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuZCByZXR1cm4gYSBjb25maWcgZm9yIGNyZWF0aW5nIHRoZSBvdmVybGF5LiAqL1xuICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnKGNvbmZpZzogUG9wb3ZlckNvbmZpZywgYW5jaG9yOiBFbGVtZW50UmVmKTogT3ZlcmxheUNvbmZpZyB7XG4gICAgcmV0dXJuIG5ldyBPdmVybGF5Q29uZmlnKHtcbiAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMuX2dldFBvc2l0aW9uU3RyYXRlZ3koXG4gICAgICAgIGNvbmZpZy5ob3Jpem9udGFsQWxpZ24sXG4gICAgICAgIGNvbmZpZy52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBjb25maWcuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgIGNvbmZpZy5sb2NrQWxpZ25tZW50LFxuICAgICAgICBhbmNob3IsXG4gICAgICApLFxuICAgICAgaGFzQmFja2Ryb3A6IGNvbmZpZy5oYXNCYWNrZHJvcCxcbiAgICAgIGJhY2tkcm9wQ2xhc3M6IGNvbmZpZy5iYWNrZHJvcENsYXNzIHx8ICdjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCcsXG4gICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZShjb25maWcuc2Nyb2xsU3RyYXRlZ3kpLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLl9nZXREaXJlY3Rpb24oKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldCB0aGUgY29ycmVjdCBhbGlnbm1lbnQgY2xhc3NlcyxcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYW5pbWF0aW9uIG9yaWdpbiBpcyBjb3JyZWN0LCBldmVuIHdpdGggYSBmYWxsYmFjayBwb3NpdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKHBvc2l0aW9uOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSBwb3NpdGlvbi5wb3NpdGlvbkNoYW5nZXNcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgICAvLyBQb3NpdGlvbiBjaGFuZ2VzIG1heSBvY2N1ciBvdXRzaWRlIHRoZSBBbmd1bGFyIHpvbmVcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcG9wb3Zlci5fc2V0QWxpZ25tZW50Q2xhc3NlcyhcbiAgICAgICAgICAgIGdldEhvcml6b250YWxQb3BvdmVyQWxpZ25tZW50KGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WCksXG4gICAgICAgICAgICBnZXRWZXJ0aWNhbFBvcG92ZXJBbGlnbm1lbnQoY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm92ZXJsYXlZKSxcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqIE1hcCBhIHNjcm9sbCBzdHJhdGVneSBzdHJpbmcgdHlwZSB0byBhbiBpbnN0YW5jZSBvZiBhIHNjcm9sbCBzdHJhdGVneS4gKi9cbiAgcHJpdmF0ZSBfZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZShzdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5KTogU2Nyb2xsU3RyYXRlZ3kge1xuICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5ibG9jaygpO1xuICAgICAgY2FzZSAncmVwb3NpdGlvbic6XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xuICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmNsb3NlKCk7XG4gICAgICBjYXNlICdub29wJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMubm9vcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDcmVhdGUgYW5kIHJldHVybiBhIHBvc2l0aW9uIHN0cmF0ZWd5IGJhc2VkIG9uIGNvbmZpZyBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLiAqL1xuICBwcml2YXRlIF9nZXRQb3NpdGlvblN0cmF0ZWd5KFxuICAgIGhvcml6b250YWxUYXJnZXQ6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gICAgdmVydGljYWxUYXJnZXQ6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduLFxuICAgIGZvcmNlQWxpZ25tZW50OiBib29sZWFuLFxuICAgIGxvY2tBbGlnbm1lbnQ6IGJvb2xlYW4sXG4gICAgYW5jaG9yOiBFbGVtZW50UmVmLFxuICApOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIC8vIEF0dGFjaCB0aGUgb3ZlcmxheSBhdCB0aGUgcHJlZmVycmVkIHBvc2l0aW9uXG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihob3Jpem9udGFsVGFyZ2V0LCB2ZXJ0aWNhbFRhcmdldCk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW3RhcmdldFBvc2l0aW9uXTtcblxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyhhbmNob3IpXG4gICAgICAud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSlcbiAgICAgIC53aXRoUHVzaChmYWxzZSlcbiAgICAgIC53aXRoVmlld3BvcnRNYXJnaW4oMClcbiAgICAgIC53aXRoTG9ja2VkUG9zaXRpb24obG9ja0FsaWdubWVudCk7XG5cbiAgICAvLyBVbmxlc3MgdGhlIGFsaWdubWVudCBpcyBmb3JjZWQsIGFkZCBmYWxsYmFja3MgYmFzZWQgb24gdGhlIHByZWZlcnJlZCBwb3NpdGlvbnNcbiAgICBpZiAoIWZvcmNlQWxpZ25tZW50KSB7XG4gICAgICBjb25zdCBmYWxsYmFja3MgPSB0aGlzLl9nZXRGYWxsYmFja3MoaG9yaXpvbnRhbFRhcmdldCwgdmVydGljYWxUYXJnZXQpO1xuICAgICAgcG9zaXRpb25zLnB1c2goLi4uZmFsbGJhY2tzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyYXRlZ3kud2l0aFBvc2l0aW9ucyhwb3NpdGlvbnMpO1xuICB9XG5cbiAgLyoqIEdldCBmYWxsYmFjayBwb3NpdGlvbnMgYmFzZWQgYXJvdW5kIHRhcmdldCBhbGlnbm1lbnRzLiAqL1xuICBwcml2YXRlIF9nZXRGYWxsYmFja3MoXG4gICAgaFRhcmdldDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbixcbiAgICB2VGFyZ2V0OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnblxuICApOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10ge1xuICAgIC8vIERldGVybWluZSBpZiB0aGUgdGFyZ2V0IGFsaWdubWVudHMgb3ZlcmxhcCB0aGUgYW5jaG9yXG4gICAgY29uc3QgaG9yaXpvbnRhbE92ZXJsYXBBbGxvd2VkID0gaFRhcmdldCAhPT0gJ2JlZm9yZScgJiYgaFRhcmdldCAhPT0gJ2FmdGVyJztcbiAgICBjb25zdCB2ZXJ0aWNhbE92ZXJsYXBBbGxvd2VkID0gdlRhcmdldCAhPT0gJ2Fib3ZlJyAmJiB2VGFyZ2V0ICE9PSAnYmVsb3cnO1xuXG4gICAgLy8gSWYgYSB0YXJnZXQgYWxpZ25tZW50IGRvZXNuJ3QgY292ZXIgdGhlIGFuY2hvciwgZG9uJ3QgbGV0IGFueSBvZiB0aGUgZmFsbGJhY2sgYWxpZ25tZW50c1xuICAgIC8vIGNvdmVyIHRoZSBhbmNob3JcbiAgICBjb25zdCBwb3NzaWJsZUhvcml6b250YWxBbGlnbm1lbnRzOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduW10gPVxuICAgICAgaG9yaXpvbnRhbE92ZXJsYXBBbGxvd2VkID9cbiAgICAgICAgWydiZWZvcmUnLCAnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCcsICdhZnRlciddIDpcbiAgICAgICAgWydiZWZvcmUnLCAnYWZ0ZXInXTtcbiAgICBjb25zdCBwb3NzaWJsZVZlcnRpY2FsQWxpZ25tZW50czogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ25bXSA9XG4gICAgICB2ZXJ0aWNhbE92ZXJsYXBBbGxvd2VkID9cbiAgICAgICAgWydhYm92ZScsICdzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2JlbG93J10gOlxuICAgICAgICBbJ2Fib3ZlJywgJ2JlbG93J107XG5cbiAgICAvLyBDcmVhdGUgZmFsbGJhY2tzIGZvciBlYWNoIGFsbG93ZWQgcHJpb3JpdGl6ZWQgZmFsbGJhY2sgYWxpZ25tZW50IGNvbWJvXG4gICAgY29uc3QgZmFsbGJhY2tzOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10gPSBbXTtcbiAgICBwcmlvcml0aXplQXJvdW5kVGFyZ2V0KGhUYXJnZXQsIHBvc3NpYmxlSG9yaXpvbnRhbEFsaWdubWVudHMpLmZvckVhY2goaCA9PiB7XG4gICAgICBwcmlvcml0aXplQXJvdW5kVGFyZ2V0KHZUYXJnZXQsIHBvc3NpYmxlVmVydGljYWxBbGlnbm1lbnRzKS5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBmYWxsYmFja3MucHVzaChnZXRQb3NpdGlvbihoLCB2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgaXRlbSBzaW5jZSBpdCB3aWxsIGJlIHRoZSB0YXJnZXQgYWxpZ25tZW50IGFuZCBpc24ndCBjb25zaWRlcmVkIGEgZmFsbGJhY2tcbiAgICByZXR1cm4gZmFsbGJhY2tzLnNsaWNlKDEsIGZhbGxiYWNrcy5sZW5ndGgpO1xuICB9XG5cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBjZGsgcG9zaXRpb24gcGFpciBmcm9tIFNhdFBvcG92ZXIgYWxpZ25tZW50cy4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKFxuICBoOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICB2OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbik6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIge1xuICBjb25zdCB7b3JpZ2luWCwgb3ZlcmxheVh9ID0gZ2V0SG9yaXpvbnRhbENvbm5lY3Rpb25Qb3NQYWlyKGgpO1xuICBjb25zdCB7b3JpZ2luWSwgb3ZlcmxheVl9ID0gZ2V0VmVydGljYWxDb25uZWN0aW9uUG9zUGFpcih2KTtcbiAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUG9zaXRpb25QYWlyKHtvcmlnaW5YLCBvcmlnaW5ZfSwge292ZXJsYXlYLCBvdmVybGF5WX0pO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQuICovXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsUG9wb3ZlckFsaWdubWVudChoOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyk6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24ge1xuICBpZiAoaCA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnYWZ0ZXInO1xuICB9XG5cbiAgaWYgKGggPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdiZWZvcmUnO1xuICB9XG5cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQuICovXG5mdW5jdGlvbiBnZXRWZXJ0aWNhbFBvcG92ZXJBbGlnbm1lbnQodjogVmVydGljYWxDb25uZWN0aW9uUG9zKTogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24ge1xuICBpZiAodiA9PT0gJ3RvcCcpIHtcbiAgICByZXR1cm4gJ2JlbG93JztcbiAgfVxuXG4gIGlmICh2ID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAnYWJvdmUnO1xuICB9XG5cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYWxpZ25tZW50IHRvIG9yaWdpbi9vdmVybGF5IHBvc2l0aW9uIHBhaXIuICovXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsQ29ubmVjdGlvblBvc1BhaXIoaDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbik6XG4gICAge29yaWdpblg6IEhvcml6b250YWxDb25uZWN0aW9uUG9zLCBvdmVybGF5WDogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3N9IHtcbiAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ3N0YXJ0Jywgb3ZlcmxheVg6ICdlbmQnfTtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICByZXR1cm4ge29yaWdpblg6ICdzdGFydCcsIG92ZXJsYXlYOiAnc3RhcnQnfTtcbiAgICBjYXNlICdlbmQnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnZW5kJywgb3ZlcmxheVg6ICdlbmQnfTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4ge29yaWdpblg6ICdlbmQnLCBvdmVybGF5WDogJ3N0YXJ0J307XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ2NlbnRlcicsIG92ZXJsYXlYOiAnY2VudGVyJ307XG4gIH1cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGFsaWdubWVudCB0byBvcmlnaW4vb3ZlcmxheSBwb3NpdGlvbiBwYWlyLiAqL1xuZnVuY3Rpb24gZ2V0VmVydGljYWxDb25uZWN0aW9uUG9zUGFpcih2OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbik6XG4gICAge29yaWdpblk6IFZlcnRpY2FsQ29ubmVjdGlvblBvcywgb3ZlcmxheVk6IFZlcnRpY2FsQ29ubmVjdGlvblBvc30ge1xuICBzd2l0Y2ggKHYpIHtcbiAgICBjYXNlICdhYm92ZSc6XG4gICAgICByZXR1cm4ge29yaWdpblk6ICd0b3AnLCBvdmVybGF5WTogJ2JvdHRvbSd9O1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHJldHVybiB7b3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlZOiAndG9wJ307XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWTogJ2JvdHRvbScsIG92ZXJsYXlZOiAnYm90dG9tJ307XG4gICAgY2FzZSAnYmVsb3cnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVk6ICd0b3AnfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnY2VudGVyJywgb3ZlcmxheVk6ICdjZW50ZXInfTtcbiAgfVxufVxuXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gb3JkZXJlZCBhcnJheSBvcHRpb25zIGFuZCByZXR1cm5zIGEgcmVvcmRlcmRlZFxuICogYXJyYXkgYXJvdW5kIHRoZSB0YXJnZXQgaXRlbS4gZS5nLjpcbiAqXG4gKiB0YXJnZXQ6IDM7IG9wdGlvbnM6IFsxLCAyLCAzLCA0LCA1LCA2LCA3XTtcbiAqXG4gKiByZXR1cm46IFszLCA0LCAyLCA1LCAxLCA2LCA3XVxuICovXG5mdW5jdGlvbiBwcmlvcml0aXplQXJvdW5kVGFyZ2V0PFQ+KHRhcmdldDogVCwgb3B0aW9uczogVFtdKTogVFtdIHtcbiAgY29uc3QgdGFyZ2V0SW5kZXggPSBvcHRpb25zLmluZGV4T2YodGFyZ2V0KTtcblxuICAvLyBTZXQgdGhlIGZpcnN0IGl0ZW0gdG8gYmUgdGhlIHRhcmdldFxuICBjb25zdCByZW9yZGVyZWQgPSBbdGFyZ2V0XTtcblxuICAvLyBNYWtlIGxlZnQgYW5kIHJpZ2h0IHN0YWNrcyB3aGVyZSB0aGUgaGlnaGVzdCBwcmlvcml0eSBpdGVtIGlzIGxhc3RcbiAgY29uc3QgbGVmdCA9IG9wdGlvbnMuc2xpY2UoMCwgdGFyZ2V0SW5kZXgpO1xuICBjb25zdCByaWdodCA9IG9wdGlvbnMuc2xpY2UodGFyZ2V0SW5kZXggKyAxLCBvcHRpb25zLmxlbmd0aCkucmV2ZXJzZSgpO1xuXG4gIC8vIEFsdGVybmF0ZSBiZXR3ZWVuIHN0YWNrcyB1bnRpbCBvbmUgaXMgZW1wdHlcbiAgd2hpbGUgKGxlZnQubGVuZ3RoICYmIHJpZ2h0Lmxlbmd0aCkge1xuICAgIHJlb3JkZXJlZC5wdXNoKHJpZ2h0LnBvcCgpKTtcbiAgICByZW9yZGVyZWQucHVzaChsZWZ0LnBvcCgpKTtcbiAgfVxuXG4gIC8vIEZsdXNoIG91dCByaWdodCBzaWRlXG4gIHdoaWxlIChyaWdodC5sZW5ndGgpIHtcbiAgICByZW9yZGVyZWQucHVzaChyaWdodC5wb3AoKSk7XG4gIH1cblxuICAvLyBGbHVzaCBvdXQgbGVmdCBzaWRlXG4gIHdoaWxlIChsZWZ0Lmxlbmd0aCkge1xuICAgIHJlb3JkZXJlZC5wdXNoKGxlZnQucG9wKCkpO1xuICB9XG5cbiAgcmV0dXJuIHJlb3JkZXJlZDtcbn1cbiIsImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25Jbml0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIG1lcmdlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgU2F0UG9wb3ZlciB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgZ2V0SW52YWxpZFBvcG92ZXJFcnJvciB9IGZyb20gJy4vcG9wb3Zlci5lcnJvcnMnO1xuaW1wb3J0IHsgU2F0UG9wb3ZlckFuY2hvcmluZ1NlcnZpY2UgfSBmcm9tICcuL3BvcG92ZXItYW5jaG9yaW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2F0UG9wb3Zlck9wZW5PcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tzYXRQb3BvdmVyQW5jaG9yRm9yXScsXG4gIGV4cG9ydEFzOiAnc2F0UG9wb3ZlckFuY2hvcicsXG4gIHByb3ZpZGVyczogW1NhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgU2F0UG9wb3ZlckFuY2hvciBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBwb3BvdmVyIGluc3RhbmNlLiAqL1xuICBASW5wdXQoJ3NhdFBvcG92ZXJBbmNob3JGb3InKVxuICBnZXQgYXR0YWNoZWRQb3BvdmVyKCkgeyByZXR1cm4gdGhpcy5fYXR0YWNoZWRQb3BvdmVyOyB9XG4gIHNldCBhdHRhY2hlZFBvcG92ZXIodmFsdWU6IFNhdFBvcG92ZXIpIHtcbiAgICB0aGlzLl92YWxpZGF0ZUF0dGFjaGVkUG9wb3Zlcih2YWx1ZSk7XG4gICAgdGhpcy5fYXR0YWNoZWRQb3BvdmVyID0gdmFsdWU7XG4gICAgLy8gQW5jaG9yIHRoZSBwb3BvdmVyIHRvIHRoZSBlbGVtZW50IHJlZlxuICAgIHRoaXMuX2FuY2hvcmluZy5hbmNob3IodGhpcy5hdHRhY2hlZFBvcG92ZXIsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYsIHRoaXMuX2VsZW1lbnRSZWYpO1xuICB9XG4gIHByaXZhdGUgX2F0dGFjaGVkUG9wb3ZlcjogU2F0UG9wb3ZlcjtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIEBPdXRwdXQoKSBwb3BvdmVyT3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgQE91dHB1dCgpIHBvcG92ZXJDbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZC4gKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHVibGljIF9hbmNob3Jpbmc6IFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlLFxuICApIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIC8vIFJlLWVtaXQgb3BlbiBhbmQgY2xvc2UgZXZlbnRzXG4gICAgY29uc3Qgb3BlbmVkJCA9IHRoaXMuX2FuY2hvcmluZy5wb3BvdmVyT3BlbmVkXG4gICAgICAucGlwZSh0YXAoKCkgPT4gdGhpcy5wb3BvdmVyT3BlbmVkLmVtaXQoKSkpO1xuICAgIGNvbnN0IGNsb3NlZCQgPSB0aGlzLl9hbmNob3JpbmcucG9wb3ZlckNsb3NlZFxuICAgICAgLnBpcGUodGFwKHZhbHVlID0+IHRoaXMucG9wb3ZlckNsb3NlZC5lbWl0KHZhbHVlKSkpO1xuICAgIG1lcmdlKG9wZW5lZCQsIGNsb3NlZCQpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBHZXRzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIGlzUG9wb3Zlck9wZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcmluZy5pc1BvcG92ZXJPcGVuKCk7XG4gIH1cblxuICAvKiogVG9nZ2xlcyB0aGUgcG9wb3ZlciBiZXR3ZWVuIHRoZSBvcGVuIGFuZCBjbG9zZWQgc3RhdGVzLiAqL1xuICB0b2dnbGVQb3BvdmVyKCk6IHZvaWQge1xuICAgIHRoaXMuX2FuY2hvcmluZy50b2dnbGVQb3BvdmVyKCk7XG4gIH1cblxuICAvKiogT3BlbnMgdGhlIHBvcG92ZXIuICovXG4gIG9wZW5Qb3BvdmVyKG9wdGlvbnM6IFNhdFBvcG92ZXJPcGVuT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgdGhpcy5fYW5jaG9yaW5nLm9wZW5Qb3BvdmVyKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqIENsb3NlcyB0aGUgcG9wb3Zlci4gKi9cbiAgY2xvc2VQb3BvdmVyKHZhbHVlPzogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fYW5jaG9yaW5nLmNsb3NlUG9wb3Zlcih2YWx1ZSk7XG4gIH1cblxuICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICByZWFsaWduUG9wb3ZlcigpOiB2b2lkIHtcbiAgICB0aGlzLl9hbmNob3JpbmcucmVhbGlnblBvcG92ZXJUb0FuY2hvcigpO1xuICB9XG5cbiAgLyoqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuICovXG4gIGdldEVsZW1lbnQoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWY7XG4gIH1cblxuICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwb3BvdmVyIGluc3RhbmNlIGlzIG5vdCBwcm92aWRlZC4gKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdGVBdHRhY2hlZFBvcG92ZXIocG9wb3ZlcjogU2F0UG9wb3Zlcik6IHZvaWQge1xuICAgIGlmICghcG9wb3ZlciB8fCAhKHBvcG92ZXIgaW5zdGFuY2VvZiBTYXRQb3BvdmVyKSkge1xuICAgICAgdGhyb3cgZ2V0SW52YWxpZFBvcG92ZXJFcnJvcigpO1xuICAgIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29lcmNlTnVtYmVyUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgb2YsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlbGF5LCBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgU2F0UG9wb3ZlckFuY2hvciB9IGZyb20gJy4vcG9wb3Zlci1hbmNob3IuZGlyZWN0aXZlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3NhdFBvcG92ZXJIb3Zlcl0nXG59KVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJIb3ZlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSAobXMpIGFmdGVyIGhvdmVyaW5nIHN0YXJ0cyBiZWZvcmVcbiAgICogdGhlIHBvcG92ZXIgb3BlbnMuIERlZmF1bHRzIHRvIDBtcy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBzYXRQb3BvdmVySG92ZXIoKSB7IHJldHVybiB0aGlzLl9zYXRQb3BvdmVySG92ZXI7IH1cbiAgc2V0IHNhdFBvcG92ZXJIb3Zlcih2YWw6IG51bWJlcikge1xuICAgIHRoaXMuX3NhdFBvcG92ZXJIb3ZlciA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbCk7XG4gIH1cbiAgcHJpdmF0ZSBfc2F0UG9wb3ZlckhvdmVyID0gMDtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZC4gKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3QoKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGVudGVycyB0aGUgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfb25Nb3VzZUVudGVyID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGxlYXZlcyB0aGUgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfb25Nb3VzZUxlYXZlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgYW5jaG9yOiBTYXRQb3BvdmVyQW5jaG9yKSB7IH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgLy8gV2hlbmV2ZXIgdGhlIHVzZXIgaG92ZXJzIHRoaXMgaG9zdCBlbGVtZW50LCBkZWxheSB0aGUgY29uZmlndXJlZFxuICAgIC8vIGFtb3VudCBvZiB0aW1lIGFuZCBvcGVuIHRoZSBwb3BvdmVyLiBUZXJtaW5hdGUgaWYgdGhlIG1vdXNlIGxlYXZlc1xuICAgIC8vIHRoZSBob3N0IGVsZW1lbnQgYmVmb3JlIHRoZSBkZWxheSBpcyBjb21wbGV0ZS5cbiAgICB0aGlzLl9vbk1vdXNlRW50ZXJcbiAgICAgIC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvZihudWxsKS5waXBlKFxuICAgICAgICAgICAgZGVsYXkodGhpcy5fc2F0UG9wb3ZlckhvdmVyIHx8IDApLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uTW91c2VMZWF2ZSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmFuY2hvci5vcGVuUG9wb3ZlcigpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJylcbiAgc2hvd1BvcG92ZXIoKSB7XG4gICAgdGhpcy5fb25Nb3VzZUVudGVyLm5leHQoKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKVxuICBjbG9zZVBvcG92ZXIoKSB7XG4gICAgdGhpcy5fb25Nb3VzZUxlYXZlLm5leHQoKTtcbiAgICB0aGlzLmFuY2hvci5jbG9zZVBvcG92ZXIoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBPdmVybGF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQTExeU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IEJpZGlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5cbmltcG9ydCB7IFNhdFBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFNhdFBvcG92ZXJBbmNob3IgfSBmcm9tICcuL3BvcG92ZXItYW5jaG9yLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTYXRQb3BvdmVySG92ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3BvcG92ZXItaG92ZXIuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBPdmVybGF5TW9kdWxlLFxuICAgIEExMXlNb2R1bGUsXG4gICAgQmlkaU1vZHVsZSxcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbXG4gICAgU2F0UG9wb3ZlcixcbiAgICBTYXRQb3BvdmVyQW5jaG9yLFxuICAgIFNhdFBvcG92ZXJIb3ZlckRpcmVjdGl2ZSxcbiAgXSxcbiAgZXhwb3J0czogW1xuICAgIFNhdFBvcG92ZXIsXG4gICAgU2F0UG9wb3ZlckFuY2hvcixcbiAgICBTYXRQb3BvdmVySG92ZXJEaXJlY3RpdmUsXG4gICAgQmlkaU1vZHVsZSxcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBTYXRQb3BvdmVyTW9kdWxlIHsgfVxuIl0sIm5hbWVzIjpbInRyaWdnZXIiLCJ0cmFuc2l0aW9uIiwic3R5bGUiLCJhbmltYXRlIiwiU3ViamVjdCIsIkluamVjdGFibGUiLCJFdmVudEVtaXR0ZXIiLCJjb2VyY2VCb29sZWFuUHJvcGVydHkiLCJDb21wb25lbnQiLCJWaWV3RW5jYXBzdWxhdGlvbiIsIkZvY3VzVHJhcEZhY3RvcnkiLCJPcHRpb25hbCIsIkluamVjdCIsIkRPQ1VNRU5UIiwiSW5wdXQiLCJPdXRwdXQiLCJWaWV3Q2hpbGQiLCJUZW1wbGF0ZVJlZiIsIlRlbXBsYXRlUG9ydGFsIiwidGFrZSIsInRha2VVbnRpbCIsInRhcCIsImZpbHRlciIsIkVTQ0FQRSIsIk92ZXJsYXlDb25maWciLCJPdmVybGF5IiwiTmdab25lIiwiRGlyZWN0aW9uYWxpdHkiLCJDb25uZWN0aW9uUG9zaXRpb25QYWlyIiwibWVyZ2UiLCJEaXJlY3RpdmUiLCJFbGVtZW50UmVmIiwiVmlld0NvbnRhaW5lclJlZiIsImNvZXJjZU51bWJlclByb3BlcnR5Iiwic3dpdGNoTWFwIiwib2YiLCJkZWxheSIsIkhvc3RMaXN0ZW5lciIsIk5nTW9kdWxlIiwiQ29tbW9uTW9kdWxlIiwiT3ZlcmxheU1vZHVsZSIsIkExMXlNb2R1bGUiLCJCaWRpTW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFTQSxRQUFhLGdCQUFnQixHQUE2QkEsa0JBQU8sQ0FBQyxrQkFBa0IsRUFBRTtRQUNwRkMscUJBQVUsQ0FBQyxRQUFRLEVBQUU7WUFDbkJDLGdCQUFLLENBQUMsRUFBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUMsQ0FBQztZQUM1Q0Msa0JBQU8sQ0FBQyxvQkFBb0Is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