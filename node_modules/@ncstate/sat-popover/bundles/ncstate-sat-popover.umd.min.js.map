{"version":3,"sources":["ng://@ncstate/sat-popover/popover/popover.animations.ts","ng://@ncstate/sat-popover/popover/notification.service.ts","ng://@ncstate/sat-popover/popover/types.ts","ng://@ncstate/sat-popover/popover/popover.errors.ts","ng://@ncstate/sat-popover/popover/popover.component.ts","node_modules/tslib/tslib.es6.js","ng://@ncstate/sat-popover/popover/popover-anchoring.service.ts","ng://@ncstate/sat-popover/popover/popover-anchor.directive.ts","ng://@ncstate/sat-popover/popover/popover-hover.directive.ts","ng://@ncstate/sat-popover/popover/popover.module.ts"],"names":["transformPopover","trigger","transition","style","opacity","transform","animate","OPEN","CLOSE","TOGGLE","REPOSITION","UPDATE_CONFIG","REALIGN","action","value","this","PopoverNotificationService","store","Subject","prototype","dispatch","notification","next","events","asObservable","dispose","complete","Injectable","VALID_SCROLL","VALID_HORIZ_ALIGN","VALID_VERT_ALIGN","generateGenericError","apiName","invalid","valid","map","v","join","DEFAULT_TRANSITION","SatPopover","_focusTrapFactory","_document","_horizontalAlign","_verticalAlign","_forceAlignment","_lockAlignment","_autoFocus","_autoFocusOverride","_restoreFocus","_restoreFocusOverride","_scrollStrategy","_hasBackdrop","_interactiveClose","_openTransition","_closeTransition","backdropClass","opened","EventEmitter","closed","afterOpen","afterClose","backdropClicked","overlayKeydown","_classList","_open","Object","defineProperty","val","_validateHorizontalAlign","_dispatchConfigNotification","PopoverNotification","NotificationAction","horizontalAlign","_validateVerticalAlign","verticalAlign","coercedVal","coerceBooleanProperty","_validateScrollStrategy","ngOnInit","_setAlignmentClasses","ngOnDestroy","_notifications","open","options","_dispatchActionNotification","close","toggle","realign","isOpen","_getAnimation","params","openTransition","closeTransition","_onAnimationDone","event","toState","_trapFocus","emit","_restoreFocusAndDestroyTrap","horizAlign","vertAlign","_savePreviouslyFocusedElement","_focusTrapElement","_focusTrap","create","nativeElement","autoFocus","focusInitialElementWhenReady","toFocus","_previouslyFocusedElement","restoreFocus","focus","destroy","undefined","Error","pos","indexOf","strategy","Component","args","selector","encapsulation","ViewEncapsulation","None","animations","template","FocusTrapFactory","Optional","type","Inject","DOCUMENT","Input","Output","ViewChild","TemplateRef","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","done","push","error","SatPopoverAnchoringService","_overlay","_ngZone","_dir","popoverOpened","popoverClosed","_popoverOpen","_onDestroy","_destroyPopover","_notificationsSubscription","unsubscribe","_positionChangeSubscription","anchor","popover","viewContainerRef","_popover","_viewContainerRef","_anchor","_subscribeToNotifications","isPopoverOpen","togglePopover","closePopover","openPopover","_applyOpenOptions","_createOverlay","_subscribeToBackdrop","_subscribeToEscape","_subscribeToDetachments","_saveOpenedState","_overlayRef","_saveClosedState","detach","realignPopoverToAnchor","getConfig","reapplyLastPosition","getAnchorElement","_portal","TemplatePortal","_templateRef","popoverConfig","hasBackdrop","scrollStrategy","forceAlignment","lockAlignment","overlayConfig","_getOverlayConfig","_subscribeToPositionChanges","attach","_destroyPopoverOnceClosed","_this","detachments","pipe","take","takeUntil","subscribe","backdropClick","tap","filter","interactiveClose","keydownEvents","keyCode","ESCAPE","_getDirection","config","OverlayConfig","positionStrategy","_getPositionStrategy","_getScrollStrategyInstance","direction","position","positionChanges","change","run","h","getHorizontalPopoverAlignment","connectionPair","overlayX","getVerticalPopoverAlignment","overlayY","scrollStrategies","block","reposition","noop","horizontalTarget","verticalTarget","positions","getPosition","flexibleConnectedTo","withFlexibleDimensions","withPush","withViewportMargin","withLockedPosition","fallbacks","_getFallbacks","apply","arguments","length","concat","__spread","withPositions","hTarget","vTarget","possibleVerticalAlignments","prioritizeAroundTarget","forEach","slice","Overlay","NgZone","Directionality","decorators","_a","originX","getHorizontalConnectionPosPair","_b","originY","getVerticalConnectionPosPair","ConnectionPositionPair","target","targetIndex","reordered","left","right","reverse","pop","SatPopoverAnchor","_elementRef","_anchoring","_attachedPopover","_validateAttachedPopover","attachedPopover","opened$","closed$","merge","realignPopover","getElement","Directive","exportAs","providers","ElementRef","ViewContainerRef","SatPopoverHoverDirective","_satPopoverHover","_onMouseEnter","_onMouseLeave","coerceNumberProperty","ngAfterViewInit","switchMap","of","delay","showPopover","HostListener","SatPopoverModule","NgModule","imports","CommonModule","OverlayModule","A11yModule","BidiModule","declarations","exports"],"mappings":"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","sourcesContent":["import {\n  trigger,\n  state,\n  style,\n  animate,\n  transition,\n  AnimationTriggerMetadata\n} from '@angular/animations';\n\nexport const transformPopover: AnimationTriggerMetadata = trigger('transformPopover', [\n  transition(':enter', [\n    style({opacity: 0, transform: 'scale(0.3)'}),\n    animate('{{openTransition}}',\n      style({opacity: 1, transform: 'scale(1)'}))\n  ]),\n  transition(':leave', [\n    animate('{{closeTransition}}',\n      style({opacity: 0, transform: 'scale(0.5)'}))\n  ])\n]);\n","import { Injectable } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\n\n/** Enumerated actions for a popover to perform. */\nexport enum NotificationAction {\n  /** Popover should open. */\n  OPEN,\n  /** Popover should close. */\n  CLOSE,\n  /** Popover should toggle open or closed. */\n  TOGGLE,\n  /** Popover has new target positions. */\n  REPOSITION,\n  /** Popover needs new configuration. */\n  UPDATE_CONFIG,\n  /** Popover should realign itself to the anchor.  */\n  REALIGN,\n}\n\n/** Event object for dispatching to anchoring service. */\nexport class PopoverNotification {\n  constructor(\n    /** Action to perform. */\n    public action: NotificationAction,\n    /** Optional payload. */\n    public value?: any\n  ) { }\n}\n\n@Injectable()\nexport class PopoverNotificationService {\n\n  private store = new Subject<PopoverNotification>();\n\n  /** Dispatch a notification to all subscribers. */\n  dispatch(notification: PopoverNotification) {\n    this.store.next(notification);\n  }\n\n  /** Stream of notification events. */\n  events(): Observable<PopoverNotification> {\n    return this.store.asObservable();\n  }\n\n  /** Complete event stream. */\n  dispose(): void {\n    this.store.complete();\n  }\n\n}\n","export type SatPopoverScrollStrategy = 'noop' | 'block' | 'reposition' | 'close';\nexport const VALID_SCROLL: SatPopoverScrollStrategy[] = [\n  'noop',\n  'block',\n  'reposition',\n  'close'\n];\n\nexport type SatPopoverHorizontalAlign = 'before' | 'start' | 'center' | 'end' | 'after';\nexport const VALID_HORIZ_ALIGN: SatPopoverHorizontalAlign[] = [\n  'before',\n  'start',\n  'center',\n  'end',\n  'after'\n];\n\nexport type SatPopoverVerticalAlign = 'above'  | 'start' | 'center' | 'end' | 'below';\nexport const VALID_VERT_ALIGN: SatPopoverVerticalAlign[] = [\n  'above',\n  'start',\n  'center',\n  'end',\n  'below'\n];\n\nexport interface SatPopoverOpenOptions {\n  /**\n   * Whether the popover should return focus to the previously focused element after\n   * closing. Defaults to true.\n   */\n  restoreFocus?: boolean;\n\n  /** Whether the first focusable element should be focused on open. Defaults to true. */\n  autoFocus?: boolean;\n}\n","import { VALID_HORIZ_ALIGN, VALID_VERT_ALIGN, VALID_SCROLL } from './types';\n\nexport function getInvalidPopoverError(): Error {\n  return Error('SatPopoverAnchor must be provided an SatPopover component instance.');\n}\n\nexport function getUnanchoredPopoverError(): Error {\n  return Error('SatPopover is not anchored to any SatPopoverAnchor.');\n}\n\nexport function getInvalidHorizontalAlignError(alignment): Error {\n  return Error(generateGenericError('horizontalAlign/xAlign', alignment, VALID_HORIZ_ALIGN));\n}\n\nexport function getInvalidVerticalAlignError(alignment): Error {\n  return Error(generateGenericError('verticalAlign/yAlign', alignment, VALID_VERT_ALIGN));\n}\n\nexport function getInvalidScrollStrategyError(strategy): Error {\n  return Error(generateGenericError('scrollStrategy', strategy, VALID_SCROLL));\n}\n\nfunction generateGenericError(apiName: string, invalid: any, valid: string[]): string {\n  return `Invalid ${apiName}: '${invalid}'. Valid options are ` +\n    `${valid.map(v => `'${v}'`).join(', ')}.`;\n}\n","import {\n  Component,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  ViewChild,\n  ViewEncapsulation,\n  TemplateRef,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n} from '@angular/core';\nimport { AnimationEvent } from '@angular/animations';\nimport { DOCUMENT } from '@angular/common';\nimport { FocusTrap, FocusTrapFactory } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\n\nimport { transformPopover } from './popover.animations';\nimport {\n  NotificationAction,\n  PopoverNotification,\n  PopoverNotificationService,\n} from './notification.service';\nimport {\n  getUnanchoredPopoverError,\n  getInvalidHorizontalAlignError,\n  getInvalidVerticalAlignError,\n  getInvalidScrollStrategyError,\n} from './popover.errors';\nimport {\n  SatPopoverScrollStrategy,\n  SatPopoverHorizontalAlign,\n  SatPopoverVerticalAlign,\n  VALID_SCROLL,\n  VALID_HORIZ_ALIGN,\n  VALID_VERT_ALIGN,\n  SatPopoverOpenOptions,\n} from './types';\n\n// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.\nconst DEFAULT_TRANSITION  = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';\n\n@Component({\n  selector: 'sat-popover',\n  encapsulation: ViewEncapsulation.None,\n  animations: [transformPopover],\n  styleUrls: ['./popover.component.scss'],\n  templateUrl: './popover.component.html',\n})\nexport class SatPopover implements OnInit, OnDestroy {\n\n  /** Alignment of the popover on the horizontal axis. */\n  @Input()\n  get horizontalAlign() { return this._horizontalAlign; }\n  set horizontalAlign(val: SatPopoverHorizontalAlign) {\n    this._validateHorizontalAlign(val);\n    if (this._horizontalAlign !== val) {\n      this._horizontalAlign = val;\n      this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));\n    }\n  }\n  private _horizontalAlign: SatPopoverHorizontalAlign = 'center';\n\n  /** Alignment of the popover on the x axis. Alias for `horizontalAlign`. */\n  @Input()\n  get xAlign() { return this.horizontalAlign; }\n  set xAlign(val: SatPopoverHorizontalAlign) { this.horizontalAlign = val; }\n\n  /** Alignment of the popover on the vertical axis. */\n  @Input()\n  get verticalAlign() { return this._verticalAlign; }\n  set verticalAlign(val: SatPopoverVerticalAlign) {\n    this._validateVerticalAlign(val);\n    if (this._verticalAlign !== val) {\n      this._verticalAlign = val;\n      this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));\n    }\n  }\n  private _verticalAlign: SatPopoverVerticalAlign = 'center';\n\n  /** Alignment of the popover on the y axis. Alias for `verticalAlign`. */\n  @Input()\n  get yAlign() { return this.verticalAlign; }\n  set yAlign(val: SatPopoverVerticalAlign) { this.verticalAlign = val; }\n\n  /** Whether the popover always opens with the specified alignment. */\n  @Input()\n  get forceAlignment() { return this._forceAlignment; }\n  set forceAlignment(val: boolean) {\n    const coercedVal = coerceBooleanProperty(val);\n    if (this._forceAlignment !== coercedVal) {\n      this._forceAlignment = coercedVal;\n      this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));\n    }\n  }\n  private _forceAlignment = false;\n\n  /**\n   * Whether the popover's alignment is locked after opening. This prevents the popover\n   * from changing its alignement when scrolling or changing the size of the viewport.\n   */\n  @Input()\n  get lockAlignment() { return this._lockAlignment; }\n  set lockAlignment(val: boolean) {\n    const coercedVal = coerceBooleanProperty(val);\n    if (this._lockAlignment !== coercedVal) {\n      this._lockAlignment = coerceBooleanProperty(val);\n      this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));\n    }\n  }\n  private _lockAlignment = false;\n\n  /** Whether the first focusable element should be focused on open. */\n  @Input()\n  get autoFocus() { return this._autoFocus && this._autoFocusOverride; }\n  set autoFocus(val: boolean) {\n    this._autoFocus = coerceBooleanProperty(val);\n  }\n  private _autoFocus = true;\n  _autoFocusOverride = true;\n\n /** Whether the popover should return focus to the previously focused element after closing. */\n @Input()\n  get restoreFocus() { return this._restoreFocus && this._restoreFocusOverride; }\n  set restoreFocus(val: boolean) {\n    this._restoreFocus = coerceBooleanProperty(val);\n  }\n  private _restoreFocus = true;\n  _restoreFocusOverride = true;\n\n  /** How the popover should handle scrolling. */\n  @Input()\n  get scrollStrategy() { return this._scrollStrategy; }\n  set scrollStrategy(val: SatPopoverScrollStrategy) {\n    this._validateScrollStrategy(val);\n    if (this._scrollStrategy !== val) {\n      this._scrollStrategy = val;\n      this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));\n    }\n  }\n  private _scrollStrategy: SatPopoverScrollStrategy = 'reposition';\n\n  /** Whether the popover should have a backdrop (includes closing on click). */\n  @Input()\n  get hasBackdrop() { return this._hasBackdrop; }\n  set hasBackdrop(val: boolean) {\n    this._hasBackdrop = coerceBooleanProperty(val);\n  }\n  private _hasBackdrop = false;\n\n  /** Whether the popover should close when the user clicks the backdrop or presses ESC. */\n  @Input()\n  get interactiveClose() { return this._interactiveClose; }\n  set interactiveClose(val: boolean) {\n    this._interactiveClose = coerceBooleanProperty(val);\n  }\n  private _interactiveClose = true;\n\n  /** Custom transition to use while opening. */\n  @Input()\n  get openTransition() { return this._openTransition; }\n  set openTransition(val: string) {\n    if (val) {\n      this._openTransition = val;\n    }\n  }\n  private _openTransition = DEFAULT_TRANSITION;\n\n  /** Custom transition to use while closing. */\n  @Input()\n  get closeTransition() { return this._closeTransition; }\n  set closeTransition(val: string) {\n    if (val) {\n      this._closeTransition = val;\n    }\n  }\n  private _closeTransition = DEFAULT_TRANSITION;\n\n  /** Optional backdrop class. */\n  @Input() backdropClass = '';\n\n  /** Emits when the popover is opened. */\n  @Output() opened = new EventEmitter<void>();\n\n  /** Emits when the popover is closed. */\n  @Output() closed = new EventEmitter<any>();\n\n  /** Emits when the popover has finished opening. */\n  @Output() afterOpen = new EventEmitter<void>();\n\n  /** Emits when the popover has finished closing. */\n  @Output() afterClose = new EventEmitter<void>();\n\n  /** Emits when the backdrop is clicked. */\n  @Output() backdropClicked = new EventEmitter<void>();\n\n  /** Emits when a keydown event is targeted to this popover's overlay. */\n  @Output() overlayKeydown = new EventEmitter<KeyboardEvent>();\n\n  /** Reference to template so it can be placed within a portal. */\n  @ViewChild(TemplateRef) _templateRef: TemplateRef<any>;\n\n  /** Classes to be added to the popover for setting the correct transform origin. */\n  _classList: any = {};\n\n  /** Whether the popover is presently open. */\n  _open = false;\n\n  /** Instance of notification service. Will be undefined until attached to an anchor. */\n  _notifications: PopoverNotificationService;\n\n  /** Reference to the element to build a focus trap around. */\n  @ViewChild('focusTrapElement')\n  private _focusTrapElement: ElementRef;\n\n  /** Reference to the element that was focused before opening. */\n  private _previouslyFocusedElement: HTMLElement;\n\n  /** Reference to a focus trap around the popover. */\n  private _focusTrap: FocusTrap;\n\n  constructor(\n    private _focusTrapFactory: FocusTrapFactory,\n    @Optional() @Inject(DOCUMENT) private _document: any\n  ) { }\n\n  ngOnInit() {\n    this._setAlignmentClasses();\n  }\n\n  ngOnDestroy() {\n    if (this._notifications) {\n      this._notifications.dispose();\n    }\n  }\n\n  /** Open this popover. */\n  open(options: SatPopoverOpenOptions = {}): void {\n    const notification = new PopoverNotification(NotificationAction.OPEN, options);\n    this._dispatchActionNotification(notification);\n  }\n\n  /** Close this popover. */\n  close(value?: any): void {\n    const notification = new PopoverNotification(NotificationAction.CLOSE, value);\n    this._dispatchActionNotification(notification);\n  }\n\n  /** Toggle this popover open or closed. */\n  toggle(): void {\n    const notification = new PopoverNotification(NotificationAction.TOGGLE);\n    this._dispatchActionNotification(notification);\n  }\n\n  /** Realign the popover to the anchor. */\n  realign(): void {\n    const notification = new PopoverNotification(NotificationAction.REALIGN);\n    this._dispatchActionNotification(notification);\n  }\n\n  /** Gets whether the popover is presently open. */\n  isOpen(): boolean {\n    return this._open;\n  }\n\n  /** Gets an animation config with customized (or default) transition values. */\n  _getAnimation(): { value: any, params: any } {\n    return {\n      value: 'visible',\n      params: { openTransition: this.openTransition, closeTransition: this.closeTransition }\n    };\n  }\n\n  /** Callback for when the popover is finished animating in or out. */\n  _onAnimationDone(event: AnimationEvent) {\n    if (event.toState === 'visible') {\n      this._trapFocus();\n      this.afterOpen.emit();\n    } else if (event.toState === 'void') {\n      this._restoreFocusAndDestroyTrap();\n      this.afterClose.emit();\n    }\n  }\n\n  /** Apply alignment classes based on alignment inputs. */\n  _setAlignmentClasses(horizAlign = this.horizontalAlign, vertAlign = this.verticalAlign) {\n    this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';\n    this._classList['sat-popover-after']  = horizAlign === 'after' || horizAlign === 'start';\n\n    this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';\n    this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';\n\n    this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';\n  }\n\n  /** Move the focus inside the focus trap and remember where to return later. */\n  private _trapFocus(): void {\n    this._savePreviouslyFocusedElement();\n\n    // There won't be a focus trap element if the close animation starts before open finishes\n    if (!this._focusTrapElement) {\n      return;\n    }\n\n    if (!this._focusTrap && this._focusTrapElement) {\n      this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);\n    }\n\n    if (this.autoFocus) {\n      this._focusTrap.focusInitialElementWhenReady();\n    }\n  }\n\n  /** Restore focus to the element focused before the popover opened. Also destroy trap. */\n  private _restoreFocusAndDestroyTrap(): void {\n    const toFocus = this._previouslyFocusedElement;\n\n    // Must check active element is focusable for IE sake\n    if (toFocus && 'focus' in toFocus && this.restoreFocus) {\n      this._previouslyFocusedElement.focus();\n    }\n\n    this._previouslyFocusedElement = null;\n\n    if (this._focusTrap) {\n      this._focusTrap.destroy();\n      this._focusTrap = undefined;\n    }\n  }\n\n  /** Save a reference to the element focused before the popover was opened. */\n  private _savePreviouslyFocusedElement(): void {\n    if (this._document) {\n      this._previouslyFocusedElement = this._document.activeElement as HTMLElement;\n    }\n  }\n\n  /** Dispatch a notification to the notification service, if possible. */\n  private _dispatchConfigNotification(notification: PopoverNotification) {\n    if (this._notifications) {\n      this._notifications.dispatch(notification);\n    }\n  }\n\n  /** Dispatch a notification to the notification service and throw if unable to. */\n  private _dispatchActionNotification(notification: PopoverNotification) {\n    if (!this._notifications) {\n      throw getUnanchoredPopoverError();\n    }\n\n    this._notifications.dispatch(notification);\n  }\n\n  /** Throws an error if the alignment is not a valid horizontalAlign. */\n  private _validateHorizontalAlign(pos: SatPopoverHorizontalAlign): void {\n    if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {\n      throw getInvalidHorizontalAlignError(pos);\n    }\n  }\n\n  /** Throws an error if the alignment is not a valid verticalAlign. */\n  private _validateVerticalAlign(pos: SatPopoverVerticalAlign): void {\n    if (VALID_VERT_ALIGN.indexOf(pos) === -1) {\n      throw getInvalidVerticalAlignError(pos);\n    }\n  }\n\n  /** Throws an error if the scroll strategy is not a valid strategy. */\n  private _validateScrollStrategy(strategy: SatPopoverScrollStrategy): void {\n    if (VALID_SCROLL.indexOf(strategy) === -1) {\n      throw getInvalidScrollStrategyError(strategy);\n    }\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\n  ElementRef,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  Optional,\n  ViewContainerRef\n} from '@angular/core';\nimport {\n  ConnectionPositionPair,\n  FlexibleConnectedPositionStrategy,\n  HorizontalConnectionPos,\n  Overlay,\n  OverlayConfig,\n  OverlayRef,\n  ScrollStrategy,\n  VerticalConnectionPos,\n} from '@angular/cdk/overlay';\nimport { Directionality, Direction} from '@angular/cdk/bidi';\nimport { ESCAPE } from '@angular/cdk/keycodes';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { Subscription, Subject } from 'rxjs';\nimport { takeUntil, take, filter, tap } from 'rxjs/operators';\n\nimport { SatPopover } from './popover.component';\nimport {\n  SatPopoverHorizontalAlign,\n  SatPopoverVerticalAlign,\n  SatPopoverScrollStrategy,\n  SatPopoverOpenOptions,\n} from './types';\n\nimport { PopoverNotificationService, NotificationAction } from './notification.service';\n\n/**\n * Configuration provided by the popover for the anchoring service\n * to build the correct overlay config.\n */\ninterface PopoverConfig {\n  horizontalAlign: SatPopoverHorizontalAlign;\n  verticalAlign: SatPopoverVerticalAlign;\n  hasBackdrop: boolean;\n  backdropClass: string;\n  scrollStrategy: SatPopoverScrollStrategy;\n  forceAlignment: boolean;\n  lockAlignment: boolean;\n}\n\n@Injectable()\nexport class SatPopoverAnchoringService implements OnDestroy {\n\n  /** Emits when the popover is opened. */\n  popoverOpened = new Subject<void>();\n\n  /** Emits when the popover is closed. */\n  popoverClosed = new Subject<void>();\n\n  /** Reference to the overlay containing the popover component. */\n  _overlayRef: OverlayRef;\n\n  /** Reference to the target popover. */\n  private _popover: SatPopover;\n\n  /** Reference to the view container for the popover template. */\n  private _viewContainerRef: ViewContainerRef;\n\n  /** Reference to the anchor element. */\n  private _anchor: ElementRef;\n\n  /** Reference to a template portal where the overlay will be attached. */\n  private _portal: TemplatePortal<any>;\n\n  /** Communications channel with the popover. */\n  private _notifications: PopoverNotificationService;\n\n  /** Single subscription to notifications service events. */\n  private _notificationsSubscription: Subscription;\n\n  /** Single subscription to position changes. */\n  private _positionChangeSubscription: Subscription;\n\n  /** Whether the popover is presently open. */\n  private _popoverOpen = false;\n\n  /** Emits when the service is destroyed. */\n  private _onDestroy = new Subject<void>();\n\n  constructor(\n    private _overlay: Overlay,\n    private _ngZone: NgZone,\n    @Optional() private _dir: Directionality\n  ) { }\n\n  ngOnDestroy() {\n    // Destroy popover before terminating subscriptions so that any resulting\n    // detachments update 'closed state'\n    this._destroyPopover();\n\n    // Terminate subscriptions\n    if (this._notificationsSubscription) {\n      this._notificationsSubscription.unsubscribe();\n    }\n    if (this._positionChangeSubscription) {\n      this._positionChangeSubscription.unsubscribe();\n    }\n    this._onDestroy.next();\n    this._onDestroy.complete();\n\n    this.popoverOpened.complete();\n    this.popoverClosed.complete();\n  }\n\n  /** Anchor a popover instance to a view and connection element. */\n  anchor(popover: SatPopover, viewContainerRef: ViewContainerRef, anchor: ElementRef): void {\n    // Destroy any previous popovers\n    this._destroyPopover();\n\n    // Assign local refs\n    this._popover = popover;\n    this._viewContainerRef = viewContainerRef;\n    this._anchor = anchor;\n\n    // Provide notification service as a communication channel between popover and anchor.\n    // Then subscribe to notifications to take appropriate actions.\n    this._popover._notifications = this._notifications = new PopoverNotificationService();\n    this._subscribeToNotifications();\n  }\n\n  /** Gets whether the popover is presently open. */\n  isPopoverOpen(): boolean {\n    return this._popoverOpen;\n  }\n\n  /** Toggles the popover between the open and closed states. */\n  togglePopover(): void {\n    return this._popoverOpen ? this.closePopover() : this.openPopover();\n  }\n\n  /** Opens the popover. */\n  openPopover(options: SatPopoverOpenOptions = {}): void {\n    if (!this._popoverOpen) {\n      this._applyOpenOptions(options);\n      this._createOverlay();\n      this._subscribeToBackdrop();\n      this._subscribeToEscape();\n      this._subscribeToDetachments();\n      this._saveOpenedState();\n    }\n  }\n\n  /** Closes the popover. */\n  closePopover(value?: any): void {\n    if (this._overlayRef) {\n      this._saveClosedState(value);\n      this._overlayRef.detach();\n    }\n  }\n\n  /** Realign the popover to the anchor. */\n  realignPopoverToAnchor(): void {\n    if (this._overlayRef) {\n      const config = this._overlayRef.getConfig();\n      const strategy = config.positionStrategy as FlexibleConnectedPositionStrategy;\n      strategy.reapplyLastPosition();\n    }\n  }\n\n  /** Get a reference to the anchor element. */\n  getAnchorElement(): ElementRef {\n    return this._anchor;\n  }\n\n  /** Apply behavior properties on the popover based on the open options. */\n  private _applyOpenOptions(options: SatPopoverOpenOptions): void {\n    // Only override restoreFocus as `false` if the option is explicitly `false`\n    const restoreFocus = options.restoreFocus !== false;\n    this._popover._restoreFocusOverride = restoreFocus;\n\n    // Only override autoFocus as `false` if the option is explicitly `false`\n    const autoFocus = options.autoFocus !== false;\n    this._popover._autoFocusOverride = autoFocus;\n  }\n\n  /** Create an overlay to be attached to the portal. */\n  private _createOverlay(): OverlayRef {\n    // Create overlay if it doesn't yet exist\n    if (!this._overlayRef) {\n      this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);\n\n      const popoverConfig = {\n        horizontalAlign: this._popover.horizontalAlign,\n        verticalAlign: this._popover.verticalAlign,\n        hasBackdrop: this._popover.hasBackdrop,\n        backdropClass: this._popover.backdropClass,\n        scrollStrategy: this._popover.scrollStrategy,\n        forceAlignment: this._popover.forceAlignment,\n        lockAlignment: this._popover.lockAlignment,\n      };\n\n      const overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);\n\n      this._subscribeToPositionChanges(\n        overlayConfig.positionStrategy as FlexibleConnectedPositionStrategy\n      );\n\n      this._overlayRef = this._overlay.create(overlayConfig);\n    }\n\n    // Actually open the popover\n    this._overlayRef.attach(this._portal);\n    return this._overlayRef;\n  }\n\n\n  /** Removes the popover from the DOM. Does NOT update open state. */\n  private _destroyPopover(): void {\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n  }\n\n  /**\n   * Destroys the popover immediately if it is closed, or waits until it\n   * has been closed to destroy it.\n   */\n  private _destroyPopoverOnceClosed(): void {\n    if (this.isPopoverOpen() && this._overlayRef) {\n      this._overlayRef.detachments().pipe(\n        take(1),\n        takeUntil(this._onDestroy)\n      ).subscribe(() => this._destroyPopover());\n    } else {\n      this._destroyPopover();\n    }\n  }\n\n  /**\n   * Call appropriate anchor method when an event is dispatched through\n   * the notification service.\n   */\n  private _subscribeToNotifications(): void {\n    if (this._notificationsSubscription) {\n      this._notificationsSubscription.unsubscribe();\n    }\n\n    this._notificationsSubscription = this._notifications.events()\n      .subscribe(event => {\n        switch (event.action) {\n          case NotificationAction.OPEN:\n            this.openPopover(event.value);\n            break;\n          case NotificationAction.CLOSE:\n            this.closePopover(event.value);\n            break;\n          case NotificationAction.TOGGLE:\n            this.togglePopover();\n            break;\n          case NotificationAction.REPOSITION:\n            // TODO: When the overlay's position can be dynamically changed, do not destroy\n          case NotificationAction.UPDATE_CONFIG:\n            this._destroyPopoverOnceClosed();\n            break;\n          case NotificationAction.REALIGN:\n            this.realignPopoverToAnchor();\n            break;\n        }\n      });\n  }\n\n  /** Close popover when backdrop is clicked. */\n  private _subscribeToBackdrop(): void {\n    this._overlayRef\n      .backdropClick()\n      .pipe(\n        tap(() => this._popover.backdropClicked.emit()),\n        filter(() => this._popover.interactiveClose),\n        takeUntil(this.popoverClosed),\n        takeUntil(this._onDestroy),\n      )\n      .subscribe(() => this.closePopover());\n  }\n\n  /** Close popover when escape keydown event occurs. */\n  private _subscribeToEscape(): void {\n    this._overlayRef\n      .keydownEvents()\n      .pipe(\n        tap(event => this._popover.overlayKeydown.emit(event)),\n        filter(event => event.keyCode === ESCAPE),\n        filter(() => this._popover.interactiveClose),\n        takeUntil(this.popoverClosed),\n        takeUntil(this._onDestroy),\n      )\n      .subscribe(() => this.closePopover());\n  }\n\n  /** Set state back to closed when detached. */\n  private _subscribeToDetachments(): void {\n    this._overlayRef\n      .detachments()\n      .pipe(takeUntil(this._onDestroy))\n      .subscribe(() => this._saveClosedState());\n  }\n\n  /** Save the opened state of the popover and emit. */\n  private _saveOpenedState(): void {\n    if (!this._popoverOpen) {\n      this._popover._open = this._popoverOpen = true;\n\n      this.popoverOpened.next();\n      this._popover.opened.emit();\n    }\n  }\n\n  /** Save the closed state of the popover and emit. */\n  private _saveClosedState(value?: any): void {\n    if (this._popoverOpen) {\n      this._popover._open = this._popoverOpen = false;\n\n      this.popoverClosed.next(value);\n      this._popover.closed.emit(value);\n    }\n  }\n\n  /** Gets the text direction of the containing app. */\n  private _getDirection(): Direction {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /** Create and return a config for creating the overlay. */\n  private _getOverlayConfig(config: PopoverConfig, anchor: ElementRef): OverlayConfig {\n    return new OverlayConfig({\n      positionStrategy: this._getPositionStrategy(\n        config.horizontalAlign,\n        config.verticalAlign,\n        config.forceAlignment,\n        config.lockAlignment,\n        anchor,\n      ),\n      hasBackdrop: config.hasBackdrop,\n      backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',\n      scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),\n      direction: this._getDirection(),\n    });\n  }\n\n  /**\n   * Listen to changes in the position of the overlay and set the correct alignment classes,\n   * ensuring that the animation origin is correct, even with a fallback position.\n   */\n  private _subscribeToPositionChanges(position: FlexibleConnectedPositionStrategy): void {\n    if (this._positionChangeSubscription) {\n      this._positionChangeSubscription.unsubscribe();\n    }\n\n    this._positionChangeSubscription = position.positionChanges\n      .pipe(takeUntil(this._onDestroy))\n      .subscribe(change => {\n        // Position changes may occur outside the Angular zone\n        this._ngZone.run(() => {\n          this._popover._setAlignmentClasses(\n            getHorizontalPopoverAlignment(change.connectionPair.overlayX),\n            getVerticalPopoverAlignment(change.connectionPair.overlayY),\n          );\n        });\n      });\n  }\n\n  /** Map a scroll strategy string type to an instance of a scroll strategy. */\n  private _getScrollStrategyInstance(strategy: SatPopoverScrollStrategy): ScrollStrategy {\n    switch (strategy) {\n      case 'block':\n        return this._overlay.scrollStrategies.block();\n      case 'reposition':\n        return this._overlay.scrollStrategies.reposition();\n      case 'close':\n        return this._overlay.scrollStrategies.close();\n      case 'noop':\n      default:\n        return this._overlay.scrollStrategies.noop();\n    }\n  }\n\n  /** Create and return a position strategy based on config provided to the component instance. */\n  private _getPositionStrategy(\n    horizontalTarget: SatPopoverHorizontalAlign,\n    verticalTarget: SatPopoverVerticalAlign,\n    forceAlignment: boolean,\n    lockAlignment: boolean,\n    anchor: ElementRef,\n  ): FlexibleConnectedPositionStrategy {\n    // Attach the overlay at the preferred position\n    const targetPosition = getPosition(horizontalTarget, verticalTarget);\n    const positions = [targetPosition];\n\n    const strategy = this._overlay.position()\n      .flexibleConnectedTo(anchor)\n      .withFlexibleDimensions(false)\n      .withPush(false)\n      .withViewportMargin(0)\n      .withLockedPosition(lockAlignment);\n\n    // Unless the alignment is forced, add fallbacks based on the preferred positions\n    if (!forceAlignment) {\n      const fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);\n      positions.push(...fallbacks);\n    }\n\n    return strategy.withPositions(positions);\n  }\n\n  /** Get fallback positions based around target alignments. */\n  private _getFallbacks(\n    hTarget: SatPopoverHorizontalAlign,\n    vTarget: SatPopoverVerticalAlign\n  ): ConnectionPositionPair[] {\n    // Determine if the target alignments overlap the anchor\n    const horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';\n    const verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';\n\n    // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments\n    // cover the anchor\n    const possibleHorizontalAlignments: SatPopoverHorizontalAlign[] =\n      horizontalOverlapAllowed ?\n        ['before', 'start', 'center', 'end', 'after'] :\n        ['before', 'after'];\n    const possibleVerticalAlignments: SatPopoverVerticalAlign[] =\n      verticalOverlapAllowed ?\n        ['above', 'start', 'center', 'end', 'below'] :\n        ['above', 'below'];\n\n    // Create fallbacks for each allowed prioritized fallback alignment combo\n    const fallbacks: ConnectionPositionPair[] = [];\n    prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach(h => {\n      prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach(v => {\n        fallbacks.push(getPosition(h, v));\n      });\n    });\n\n    // Remove the first item since it will be the target alignment and isn't considered a fallback\n    return fallbacks.slice(1, fallbacks.length);\n  }\n\n}\n\n/** Helper function to get a cdk position pair from SatPopover alignments. */\nfunction getPosition(\n  h: SatPopoverHorizontalAlign,\n  v: SatPopoverVerticalAlign,\n): ConnectionPositionPair {\n  const {originX, overlayX} = getHorizontalConnectionPosPair(h);\n  const {originY, overlayY} = getVerticalConnectionPosPair(v);\n  return new ConnectionPositionPair({originX, originY}, {overlayX, overlayY});\n}\n\n/** Helper function to convert an overlay connection position to equivalent popover alignment. */\nfunction getHorizontalPopoverAlignment(h: HorizontalConnectionPos): SatPopoverHorizontalAlign {\n  if (h === 'start') {\n    return 'after';\n  }\n\n  if (h === 'end') {\n    return 'before';\n  }\n\n  return 'center';\n}\n\n/** Helper function to convert an overlay connection position to equivalent popover alignment. */\nfunction getVerticalPopoverAlignment(v: VerticalConnectionPos): SatPopoverVerticalAlign {\n  if (v === 'top') {\n    return 'below';\n  }\n\n  if (v === 'bottom') {\n    return 'above';\n  }\n\n  return 'center';\n}\n\n/** Helper function to convert alignment to origin/overlay position pair. */\nfunction getHorizontalConnectionPosPair(h: SatPopoverHorizontalAlign):\n    {originX: HorizontalConnectionPos, overlayX: HorizontalConnectionPos} {\n  switch (h) {\n    case 'before':\n      return {originX: 'start', overlayX: 'end'};\n    case 'start':\n      return {originX: 'start', overlayX: 'start'};\n    case 'end':\n      return {originX: 'end', overlayX: 'end'};\n    case 'after':\n      return {originX: 'end', overlayX: 'start'};\n    default:\n      return {originX: 'center', overlayX: 'center'};\n  }\n}\n\n/** Helper function to convert alignment to origin/overlay position pair. */\nfunction getVerticalConnectionPosPair(v: SatPopoverVerticalAlign):\n    {originY: VerticalConnectionPos, overlayY: VerticalConnectionPos} {\n  switch (v) {\n    case 'above':\n      return {originY: 'top', overlayY: 'bottom'};\n    case 'start':\n      return {originY: 'top', overlayY: 'top'};\n    case 'end':\n      return {originY: 'bottom', overlayY: 'bottom'};\n    case 'below':\n      return {originY: 'bottom', overlayY: 'top'};\n    default:\n      return {originY: 'center', overlayY: 'center'};\n  }\n}\n\n\n/**\n * Helper function that takes an ordered array options and returns a reorderded\n * array around the target item. e.g.:\n *\n * target: 3; options: [1, 2, 3, 4, 5, 6, 7];\n *\n * return: [3, 4, 2, 5, 1, 6, 7]\n */\nfunction prioritizeAroundTarget<T>(target: T, options: T[]): T[] {\n  const targetIndex = options.indexOf(target);\n\n  // Set the first item to be the target\n  const reordered = [target];\n\n  // Make left and right stacks where the highest priority item is last\n  const left = options.slice(0, targetIndex);\n  const right = options.slice(targetIndex + 1, options.length).reverse();\n\n  // Alternate between stacks until one is empty\n  while (left.length && right.length) {\n    reordered.push(right.pop());\n    reordered.push(left.pop());\n  }\n\n  // Flush out right side\n  while (right.length) {\n    reordered.push(right.pop());\n  }\n\n  // Flush out left side\n  while (left.length) {\n    reordered.push(left.pop());\n  }\n\n  return reordered;\n}\n","import {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnInit,\n  OnDestroy,\n  Output,\n  ViewContainerRef\n} from '@angular/core';\nimport { Subject, merge } from 'rxjs';\nimport { tap, takeUntil } from 'rxjs/operators';\n\nimport { SatPopover } from './popover.component';\nimport { getInvalidPopoverError } from './popover.errors';\nimport { SatPopoverAnchoringService } from './popover-anchoring.service';\nimport { SatPopoverOpenOptions } from './types';\n\n@Directive({\n  selector: '[satPopoverAnchorFor]',\n  exportAs: 'satPopoverAnchor',\n  providers: [SatPopoverAnchoringService],\n})\nexport class SatPopoverAnchor implements OnInit, OnDestroy {\n\n  /** Reference to the popover instance. */\n  @Input('satPopoverAnchorFor')\n  get attachedPopover() { return this._attachedPopover; }\n  set attachedPopover(value: SatPopover) {\n    this._validateAttachedPopover(value);\n    this._attachedPopover = value;\n    // Anchor the popover to the element ref\n    this._anchoring.anchor(this.attachedPopover, this._viewContainerRef, this._elementRef);\n  }\n  private _attachedPopover: SatPopover;\n\n  /** Emits when the popover is opened. */\n  @Output() popoverOpened = new EventEmitter<void>();\n\n  /** Emits when the popover is closed. */\n  @Output() popoverClosed = new EventEmitter<any>();\n\n  /** Emits when the directive is destroyed. */\n  private _onDestroy = new Subject<void>();\n\n  constructor(\n    private _elementRef: ElementRef,\n    private _viewContainerRef: ViewContainerRef,\n    public _anchoring: SatPopoverAnchoringService,\n  ) { }\n\n  ngOnInit() {\n    // Re-emit open and close events\n    const opened$ = this._anchoring.popoverOpened\n      .pipe(tap(() => this.popoverOpened.emit()));\n    const closed$ = this._anchoring.popoverClosed\n      .pipe(tap(value => this.popoverClosed.emit(value)));\n    merge(opened$, closed$).pipe(takeUntil(this._onDestroy)).subscribe();\n  }\n\n  ngOnDestroy() {\n    this._onDestroy.next();\n    this._onDestroy.complete();\n  }\n\n  /** Gets whether the popover is presently open. */\n  isPopoverOpen(): boolean {\n    return this._anchoring.isPopoverOpen();\n  }\n\n  /** Toggles the popover between the open and closed states. */\n  togglePopover(): void {\n    this._anchoring.togglePopover();\n  }\n\n  /** Opens the popover. */\n  openPopover(options: SatPopoverOpenOptions = {}): void {\n    this._anchoring.openPopover(options);\n  }\n\n  /** Closes the popover. */\n  closePopover(value?: any): void {\n    this._anchoring.closePopover(value);\n  }\n\n  /** Realign the popover to the anchor. */\n  realignPopover(): void {\n    this._anchoring.realignPopoverToAnchor();\n  }\n\n  /** Get a reference to the anchor element. */\n  getElement(): ElementRef {\n    return this._elementRef;\n  }\n\n  /** Throws an error if the popover instance is not provided. */\n  private _validateAttachedPopover(popover: SatPopover): void {\n    if (!popover || !(popover instanceof SatPopover)) {\n      throw getInvalidPopoverError();\n    }\n  }\n\n}\n","import { AfterViewInit, Directive, HostListener, Input, OnDestroy } from '@angular/core';\nimport { coerceNumberProperty } from '@angular/cdk/coercion';\nimport { of, Subject } from 'rxjs';\nimport { delay, switchMap, takeUntil } from 'rxjs/operators';\n\nimport { SatPopoverAnchor } from './popover-anchor.directive';\n\n@Directive({\n  selector: '[satPopoverHover]'\n})\nexport class SatPopoverHoverDirective implements AfterViewInit, OnDestroy {\n  /**\n   * Amount of time to delay (ms) after hovering starts before\n   * the popover opens. Defaults to 0ms.\n   */\n  @Input()\n  get satPopoverHover() { return this._satPopoverHover; }\n  set satPopoverHover(val: number) {\n    this._satPopoverHover = coerceNumberProperty(val);\n  }\n  private _satPopoverHover = 0;\n\n  /** Emits when the directive is destroyed. */\n  private _onDestroy = new Subject();\n\n  /** Emits when the user's mouse enters the element. */\n  private _onMouseEnter = new Subject<void>();\n\n  /** Emits when the user's mouse leaves the element. */\n  private _onMouseLeave = new Subject<void>();\n\n  constructor(public anchor: SatPopoverAnchor) { }\n\n  ngAfterViewInit() {\n    // Whenever the user hovers this host element, delay the configured\n    // amount of time and open the popover. Terminate if the mouse leaves\n    // the host element before the delay is complete.\n    this._onMouseEnter\n      .pipe(\n        switchMap(() => {\n          return of(null).pipe(\n            delay(this._satPopoverHover || 0),\n            takeUntil(this._onMouseLeave),\n          );\n        }),\n        takeUntil(this._onDestroy),\n      )\n      .subscribe(() => this.anchor.openPopover());\n  }\n\n  ngOnDestroy() {\n    this._onDestroy.next();\n    this._onDestroy.complete();\n  }\n\n  @HostListener('mouseenter')\n  showPopover() {\n    this._onMouseEnter.next();\n  }\n\n  @HostListener('mouseleave')\n  closePopover() {\n    this._onMouseLeave.next();\n    this.anchor.closePopover();\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { OverlayModule } from '@angular/cdk/overlay';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport { BidiModule } from '@angular/cdk/bidi';\n\nimport { SatPopover } from './popover.component';\nimport { SatPopoverAnchor } from './popover-anchor.directive';\nimport { SatPopoverHoverDirective } from './popover-hover.directive';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    OverlayModule,\n    A11yModule,\n    BidiModule,\n  ],\n  declarations: [\n    SatPopover,\n    SatPopoverAnchor,\n    SatPopoverHoverDirective,\n  ],\n  exports: [\n    SatPopover,\n    SatPopoverAnchor,\n    SatPopoverHoverDirective,\n    BidiModule,\n  ]\n})\nexport class SatPopoverModule { }\n"]}