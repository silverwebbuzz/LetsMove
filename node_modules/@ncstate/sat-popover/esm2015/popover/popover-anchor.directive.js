/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, Input, Output, ViewContainerRef } from '@angular/core';
import { Subject, merge } from 'rxjs';
import { tap, takeUntil } from 'rxjs/operators';
import { SatPopover } from './popover.component';
import { getInvalidPopoverError } from './popover.errors';
import { SatPopoverAnchoringService } from './popover-anchoring.service';
export class SatPopoverAnchor {
    /**
     * @param {?} _elementRef
     * @param {?} _viewContainerRef
     * @param {?} _anchoring
     */
    constructor(_elementRef, _viewContainerRef, _anchoring) {
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._anchoring = _anchoring;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new EventEmitter();
        /**
         * Emits when the directive is destroyed.
         */
        this._onDestroy = new Subject();
    }
    /**
     * Reference to the popover instance.
     * @return {?}
     */
    get attachedPopover() { return this._attachedPopover; }
    /**
     * @param {?} value
     * @return {?}
     */
    set attachedPopover(value) {
        this._validateAttachedPopover(value);
        this._attachedPopover = value;
        // Anchor the popover to the element ref
        this._anchoring.anchor(this.attachedPopover, this._viewContainerRef, this._elementRef);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Re-emit open and close events
        /** @type {?} */
        const opened$ = this._anchoring.popoverOpened
            .pipe(tap(() => this.popoverOpened.emit()));
        /** @type {?} */
        const closed$ = this._anchoring.popoverClosed
            .pipe(tap(value => this.popoverClosed.emit(value)));
        merge(opened$, closed$).pipe(takeUntil(this._onDestroy)).subscribe();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._onDestroy.next();
        this._onDestroy.complete();
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isPopoverOpen() {
        return this._anchoring.isPopoverOpen();
    }
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    togglePopover() {
        this._anchoring.togglePopover();
    }
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    openPopover(options = {}) {
        this._anchoring.openPopover(options);
    }
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    closePopover(value) {
        this._anchoring.closePopover(value);
    }
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    realignPopover() {
        this._anchoring.realignPopoverToAnchor();
    }
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    getElement() {
        return this._elementRef;
    }
    /**
     * Throws an error if the popover instance is not provided.
     * @param {?} popover
     * @return {?}
     */
    _validateAttachedPopover(popover) {
        if (!popover || !(popover instanceof SatPopover)) {
            throw getInvalidPopoverError();
        }
    }
}
SatPopoverAnchor.decorators = [
    { type: Directive, args: [{
                selector: '[satPopoverAnchorFor]',
                exportAs: 'satPopoverAnchor',
                providers: [SatPopoverAnchoringService],
            },] }
];
/** @nocollapse */
SatPopoverAnchor.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: SatPopoverAnchoringService }
];
SatPopoverAnchor.propDecorators = {
    attachedPopover: [{ type: Input, args: ['satPopoverAnchorFor',] }],
    popoverOpened: [{ type: Output }],
    popoverClosed: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SatPopoverAnchor.prototype._attachedPopover;
    /**
     * Emits when the popover is opened.
     * @type {?}
     */
    SatPopoverAnchor.prototype.popoverOpened;
    /**
     * Emits when the popover is closed.
     * @type {?}
     */
    SatPopoverAnchor.prototype.popoverClosed;
    /**
     * Emits when the directive is destroyed.
     * @type {?}
     */
    SatPopoverAnchor.prototype._onDestroy;
    /** @type {?} */
    SatPopoverAnchor.prototype._elementRef;
    /** @type {?} */
    SatPopoverAnchor.prototype._viewContainerRef;
    /** @type {?} */
    SatPopoverAnchor.prototype._anchoring;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1hbmNob3IuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5jc3RhdGUvc2F0LXBvcG92ZXIvIiwic291cmNlcyI6WyJwb3BvdmVyL3BvcG92ZXItYW5jaG9yLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFHTCxNQUFNLEVBQ04sZ0JBQWdCLEVBQ2pCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFaEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzFELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBUXpFLE1BQU0sT0FBTyxnQkFBZ0I7Ozs7OztJQXNCM0IsWUFDVSxXQUF1QixFQUN2QixpQkFBbUMsRUFDcEMsVUFBc0M7UUFGckMsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFDdkIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFrQjtRQUNwQyxlQUFVLEdBQVYsVUFBVSxDQUE0Qjs7OztRQVhyQyxrQkFBYSxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7Ozs7UUFHekMsa0JBQWEsR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDOzs7O1FBRzFDLGVBQVUsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO0lBTXJDLENBQUM7Ozs7O0lBdkJMLElBQ0ksZUFBZSxLQUFLLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQzs7Ozs7SUFDdkQsSUFBSSxlQUFlLENBQUMsS0FBaUI7UUFDbkMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFDOUIsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN6RixDQUFDOzs7O0lBa0JELFFBQVE7OztjQUVBLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWE7YUFDMUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7O2NBQ3ZDLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWE7YUFDMUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDckQsS0FBSyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3ZFLENBQUM7Ozs7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzdCLENBQUM7Ozs7O0lBR0QsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN6QyxDQUFDOzs7OztJQUdELGFBQWE7UUFDWCxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ2xDLENBQUM7Ozs7OztJQUdELFdBQVcsQ0FBQyxVQUFpQyxFQUFFO1FBQzdDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7Ozs7OztJQUdELFlBQVksQ0FBQyxLQUFXO1FBQ3RCLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3RDLENBQUM7Ozs7O0lBR0QsY0FBYztRQUNaLElBQUksQ0FBQyxVQUFVLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztJQUMzQyxDQUFDOzs7OztJQUdELFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQzs7Ozs7O0lBR08sd0JBQXdCLENBQUMsT0FBbUI7UUFDbEQsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsT0FBTyxZQUFZLFVBQVUsQ0FBQyxFQUFFO1lBQ2hELE1BQU0sc0JBQXNCLEVBQUUsQ0FBQztTQUNoQztJQUNILENBQUM7OztZQWxGRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLHVCQUF1QjtnQkFDakMsUUFBUSxFQUFFLGtCQUFrQjtnQkFDNUIsU0FBUyxFQUFFLENBQUMsMEJBQTBCLENBQUM7YUFDeEM7Ozs7WUFwQkMsVUFBVTtZQU1WLGdCQUFnQjtZQU9ULDBCQUEwQjs7OzhCQVdoQyxLQUFLLFNBQUMscUJBQXFCOzRCQVczQixNQUFNOzRCQUdOLE1BQU07Ozs7SUFOUCw0Q0FBcUM7Ozs7O0lBR3JDLHlDQUFtRDs7Ozs7SUFHbkQseUNBQWtEOzs7OztJQUdsRCxzQ0FBeUM7O0lBR3ZDLHVDQUErQjs7SUFDL0IsNkNBQTJDOztJQUMzQyxzQ0FBNkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uSW5pdCxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0LCBtZXJnZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IFNhdFBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcbmltcG9ydCB7IGdldEludmFsaWRQb3BvdmVyRXJyb3IgfSBmcm9tICcuL3BvcG92ZXIuZXJyb3JzJztcbmltcG9ydCB7IFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlIH0gZnJvbSAnLi9wb3BvdmVyLWFuY2hvcmluZy5zZXJ2aWNlJztcbmltcG9ydCB7IFNhdFBvcG92ZXJPcGVuT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbc2F0UG9wb3ZlckFuY2hvckZvcl0nLFxuICBleHBvcnRBczogJ3NhdFBvcG92ZXJBbmNob3InLFxuICBwcm92aWRlcnM6IFtTYXRQb3BvdmVyQW5jaG9yaW5nU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJBbmNob3IgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgcG9wb3ZlciBpbnN0YW5jZS4gKi9cbiAgQElucHV0KCdzYXRQb3BvdmVyQW5jaG9yRm9yJylcbiAgZ2V0IGF0dGFjaGVkUG9wb3ZlcigpIHsgcmV0dXJuIHRoaXMuX2F0dGFjaGVkUG9wb3ZlcjsgfVxuICBzZXQgYXR0YWNoZWRQb3BvdmVyKHZhbHVlOiBTYXRQb3BvdmVyKSB7XG4gICAgdGhpcy5fdmFsaWRhdGVBdHRhY2hlZFBvcG92ZXIodmFsdWUpO1xuICAgIHRoaXMuX2F0dGFjaGVkUG9wb3ZlciA9IHZhbHVlO1xuICAgIC8vIEFuY2hvciB0aGUgcG9wb3ZlciB0byB0aGUgZWxlbWVudCByZWZcbiAgICB0aGlzLl9hbmNob3JpbmcuYW5jaG9yKHRoaXMuYXR0YWNoZWRQb3BvdmVyLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmLCB0aGlzLl9lbGVtZW50UmVmKTtcbiAgfVxuICBwcml2YXRlIF9hdHRhY2hlZFBvcG92ZXI6IFNhdFBvcG92ZXI7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaXMgb3BlbmVkLiAqL1xuICBAT3V0cHV0KCkgcG9wb3Zlck9wZW5lZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQuICovXG4gIEBPdXRwdXQoKSBwb3BvdmVyQ2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIGRpcmVjdGl2ZSBpcyBkZXN0cm95ZWQuICovXG4gIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHB1YmxpYyBfYW5jaG9yaW5nOiBTYXRQb3BvdmVyQW5jaG9yaW5nU2VydmljZSxcbiAgKSB7IH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICAvLyBSZS1lbWl0IG9wZW4gYW5kIGNsb3NlIGV2ZW50c1xuICAgIGNvbnN0IG9wZW5lZCQgPSB0aGlzLl9hbmNob3JpbmcucG9wb3Zlck9wZW5lZFxuICAgICAgLnBpcGUodGFwKCgpID0+IHRoaXMucG9wb3Zlck9wZW5lZC5lbWl0KCkpKTtcbiAgICBjb25zdCBjbG9zZWQkID0gdGhpcy5fYW5jaG9yaW5nLnBvcG92ZXJDbG9zZWRcbiAgICAgIC5waXBlKHRhcCh2YWx1ZSA9PiB0aGlzLnBvcG92ZXJDbG9zZWQuZW1pdCh2YWx1ZSkpKTtcbiAgICBtZXJnZShvcGVuZWQkLCBjbG9zZWQkKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogR2V0cyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBpc1BvcG92ZXJPcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9hbmNob3JpbmcuaXNQb3BvdmVyT3BlbigpO1xuICB9XG5cbiAgLyoqIFRvZ2dsZXMgdGhlIHBvcG92ZXIgYmV0d2VlbiB0aGUgb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy4gKi9cbiAgdG9nZ2xlUG9wb3ZlcigpOiB2b2lkIHtcbiAgICB0aGlzLl9hbmNob3JpbmcudG9nZ2xlUG9wb3ZlcigpO1xuICB9XG5cbiAgLyoqIE9wZW5zIHRoZSBwb3BvdmVyLiAqL1xuICBvcGVuUG9wb3ZlcihvcHRpb25zOiBTYXRQb3BvdmVyT3Blbk9wdGlvbnMgPSB7fSk6IHZvaWQge1xuICAgIHRoaXMuX2FuY2hvcmluZy5vcGVuUG9wb3ZlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBDbG9zZXMgdGhlIHBvcG92ZXIuICovXG4gIGNsb3NlUG9wb3Zlcih2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX2FuY2hvcmluZy5jbG9zZVBvcG92ZXIodmFsdWUpO1xuICB9XG5cbiAgLyoqIFJlYWxpZ24gdGhlIHBvcG92ZXIgdG8gdGhlIGFuY2hvci4gKi9cbiAgcmVhbGlnblBvcG92ZXIoKTogdm9pZCB7XG4gICAgdGhpcy5fYW5jaG9yaW5nLnJlYWxpZ25Qb3BvdmVyVG9BbmNob3IoKTtcbiAgfVxuXG4gIC8qKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGFuY2hvciBlbGVtZW50LiAqL1xuICBnZXRFbGVtZW50KCk6IEVsZW1lbnRSZWYge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmO1xuICB9XG5cbiAgLyoqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcG9wb3ZlciBpbnN0YW5jZSBpcyBub3QgcHJvdmlkZWQuICovXG4gIHByaXZhdGUgX3ZhbGlkYXRlQXR0YWNoZWRQb3BvdmVyKHBvcG92ZXI6IFNhdFBvcG92ZXIpOiB2b2lkIHtcbiAgICBpZiAoIXBvcG92ZXIgfHwgIShwb3BvdmVyIGluc3RhbmNlb2YgU2F0UG9wb3ZlcikpIHtcbiAgICAgIHRocm93IGdldEludmFsaWRQb3BvdmVyRXJyb3IoKTtcbiAgICB9XG4gIH1cblxufVxuIl19