/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, NgZone, Optional } from '@angular/core';
import { ConnectionPositionPair, Overlay, OverlayConfig, } from '@angular/cdk/overlay';
import { Directionality } from '@angular/cdk/bidi';
import { ESCAPE } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import { Subject } from 'rxjs';
import { takeUntil, take, filter, tap } from 'rxjs/operators';
import { PopoverNotificationService, NotificationAction } from './notification.service';
/**
 * Configuration provided by the popover for the anchoring service
 * to build the correct overlay config.
 * @record
 */
function PopoverConfig() { }
if (false) {
    /** @type {?} */
    PopoverConfig.prototype.horizontalAlign;
    /** @type {?} */
    PopoverConfig.prototype.verticalAlign;
    /** @type {?} */
    PopoverConfig.prototype.hasBackdrop;
    /** @type {?} */
    PopoverConfig.prototype.backdropClass;
    /** @type {?} */
    PopoverConfig.prototype.scrollStrategy;
    /** @type {?} */
    PopoverConfig.prototype.forceAlignment;
    /** @type {?} */
    PopoverConfig.prototype.lockAlignment;
}
var SatPopoverAnchoringService = /** @class */ (function () {
    function SatPopoverAnchoringService(_overlay, _ngZone, _dir) {
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new Subject();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new Subject();
        /**
         * Whether the popover is presently open.
         */
        this._popoverOpen = false;
        /**
         * Emits when the service is destroyed.
         */
        this._onDestroy = new Subject();
    }
    /**
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // Destroy popover before terminating subscriptions so that any resulting
        // detachments update 'closed state'
        this._destroyPopover();
        // Terminate subscriptions
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._onDestroy.next();
        this._onDestroy.complete();
        this.popoverOpened.complete();
        this.popoverClosed.complete();
    };
    /** Anchor a popover instance to a view and connection element. */
    /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.anchor = /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    function (popover, viewContainerRef, anchor) {
        // Destroy any previous popovers
        this._destroyPopover();
        // Assign local refs
        this._popover = popover;
        this._viewContainerRef = viewContainerRef;
        this._anchor = anchor;
        // Provide notification service as a communication channel between popover and anchor.
        // Then subscribe to notifications to take appropriate actions.
        this._popover._notifications = this._notifications = new PopoverNotificationService();
        this._subscribeToNotifications();
    };
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.isPopoverOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._popoverOpen;
    };
    /** Toggles the popover between the open and closed states. */
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.togglePopover = /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    function () {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    };
    /** Opens the popover. */
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.openPopover = /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        if (!this._popoverOpen) {
            this._applyOpenOptions(options);
            this._createOverlay();
            this._subscribeToBackdrop();
            this._subscribeToEscape();
            this._subscribeToDetachments();
            this._saveOpenedState();
        }
    };
    /** Closes the popover. */
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.closePopover = /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._overlayRef) {
            this._saveClosedState(value);
            this._overlayRef.detach();
        }
    };
    /** Realign the popover to the anchor. */
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.realignPopoverToAnchor = /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            /** @type {?} */
            var config = this._overlayRef.getConfig();
            /** @type {?} */
            var strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.reapplyLastPosition();
        }
    };
    /** Get a reference to the anchor element. */
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.getAnchorElement = /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    function () {
        return this._anchor;
    };
    /** Apply behavior properties on the popover based on the open options. */
    /**
     * Apply behavior properties on the popover based on the open options.
     * @param {?} options
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._applyOpenOptions = /**
     * Apply behavior properties on the popover based on the open options.
     * @param {?} options
     * @return {?}
     */
    function (options) {
        // Only override restoreFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        var restoreFocus = options.restoreFocus !== false;
        this._popover._restoreFocusOverride = restoreFocus;
        // Only override autoFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        var autoFocus = options.autoFocus !== false;
        this._popover._autoFocusOverride = autoFocus;
    };
    /** Create an overlay to be attached to the portal. */
    /**
     * Create an overlay to be attached to the portal.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._createOverlay = /**
     * Create an overlay to be attached to the portal.
     * @return {?}
     */
    function () {
        // Create overlay if it doesn't yet exist
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);
            /** @type {?} */
            var popoverConfig = {
                horizontalAlign: this._popover.horizontalAlign,
                verticalAlign: this._popover.verticalAlign,
                hasBackdrop: this._popover.hasBackdrop,
                backdropClass: this._popover.backdropClass,
                scrollStrategy: this._popover.scrollStrategy,
                forceAlignment: this._popover.forceAlignment,
                lockAlignment: this._popover.lockAlignment,
            };
            /** @type {?} */
            var overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
            this._subscribeToPositionChanges((/** @type {?} */ (overlayConfig.positionStrategy)));
            this._overlayRef = this._overlay.create(overlayConfig);
        }
        // Actually open the popover
        this._overlayRef.attach(this._portal);
        return this._overlayRef;
    };
    /** Removes the popover from the DOM. Does NOT update open state. */
    /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._destroyPopover = /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    };
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     */
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._destroyPopoverOnceClosed = /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isPopoverOpen() && this._overlayRef) {
            this._overlayRef.detachments().pipe(take(1), takeUntil(this._onDestroy)).subscribe(function () { return _this._destroyPopover(); });
        }
        else {
            this._destroyPopover();
        }
    };
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     */
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToNotifications = /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        this._notificationsSubscription = this._notifications.events()
            .subscribe(function (event) {
            switch (event.action) {
                case NotificationAction.OPEN:
                    _this.openPopover(event.value);
                    break;
                case NotificationAction.CLOSE:
                    _this.closePopover(event.value);
                    break;
                case NotificationAction.TOGGLE:
                    _this.togglePopover();
                    break;
                case NotificationAction.REPOSITION:
                // TODO: When the overlay's position can be dynamically changed, do not destroy
                case NotificationAction.UPDATE_CONFIG:
                    _this._destroyPopoverOnceClosed();
                    break;
                case NotificationAction.REALIGN:
                    _this.realignPopoverToAnchor();
                    break;
            }
        });
    };
    /** Close popover when backdrop is clicked. */
    /**
     * Close popover when backdrop is clicked.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToBackdrop = /**
     * Close popover when backdrop is clicked.
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .backdropClick()
            .pipe(tap(function () { return _this._popover.backdropClicked.emit(); }), filter(function () { return _this._popover.interactiveClose; }), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe(function () { return _this.closePopover(); });
    };
    /** Close popover when escape keydown event occurs. */
    /**
     * Close popover when escape keydown event occurs.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToEscape = /**
     * Close popover when escape keydown event occurs.
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .keydownEvents()
            .pipe(tap(function (event) { return _this._popover.overlayKeydown.emit(event); }), filter(function (event) { return event.keyCode === ESCAPE; }), filter(function () { return _this._popover.interactiveClose; }), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe(function () { return _this.closePopover(); });
    };
    /** Set state back to closed when detached. */
    /**
     * Set state back to closed when detached.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToDetachments = /**
     * Set state back to closed when detached.
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .detachments()
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function () { return _this._saveClosedState(); });
    };
    /** Save the opened state of the popover and emit. */
    /**
     * Save the opened state of the popover and emit.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._saveOpenedState = /**
     * Save the opened state of the popover and emit.
     * @return {?}
     */
    function () {
        if (!this._popoverOpen) {
            this._popover._open = this._popoverOpen = true;
            this.popoverOpened.next();
            this._popover.opened.emit();
        }
    };
    /** Save the closed state of the popover and emit. */
    /**
     * Save the closed state of the popover and emit.
     * @param {?=} value
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._saveClosedState = /**
     * Save the closed state of the popover and emit.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._popoverOpen) {
            this._popover._open = this._popoverOpen = false;
            this.popoverClosed.next(value);
            this._popover.closed.emit(value);
        }
    };
    /** Gets the text direction of the containing app. */
    /**
     * Gets the text direction of the containing app.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getDirection = /**
     * Gets the text direction of the containing app.
     * @return {?}
     */
    function () {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    };
    /** Create and return a config for creating the overlay. */
    /**
     * Create and return a config for creating the overlay.
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getOverlayConfig = /**
     * Create and return a config for creating the overlay.
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    function (config, anchor) {
        return new OverlayConfig({
            positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor),
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
            direction: this._getDirection(),
        });
    };
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     */
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @param {?} position
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToPositionChanges = /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._positionChangeSubscription = position.positionChanges
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function (change) {
            // Position changes may occur outside the Angular zone
            _this._ngZone.run(function () {
                _this._popover._setAlignmentClasses(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
            });
        });
    };
    /** Map a scroll strategy string type to an instance of a scroll strategy. */
    /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @param {?} strategy
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getScrollStrategyInstance = /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        switch (strategy) {
            case 'block':
                return this._overlay.scrollStrategies.block();
            case 'reposition':
                return this._overlay.scrollStrategies.reposition();
            case 'close':
                return this._overlay.scrollStrategies.close();
            case 'noop':
            default:
                return this._overlay.scrollStrategies.noop();
        }
    };
    /** Create and return a position strategy based on config provided to the component instance. */
    /**
     * Create and return a position strategy based on config provided to the component instance.
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getPositionStrategy = /**
     * Create and return a position strategy based on config provided to the component instance.
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    function (horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
        // Attach the overlay at the preferred position
        /** @type {?} */
        var targetPosition = getPosition(horizontalTarget, verticalTarget);
        /** @type {?} */
        var positions = [targetPosition];
        /** @type {?} */
        var strategy = this._overlay.position()
            .flexibleConnectedTo(anchor)
            .withFlexibleDimensions(false)
            .withPush(false)
            .withViewportMargin(0)
            .withLockedPosition(lockAlignment);
        // Unless the alignment is forced, add fallbacks based on the preferred positions
        if (!forceAlignment) {
            /** @type {?} */
            var fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
            positions.push.apply(positions, tslib_1.__spread(fallbacks));
        }
        return strategy.withPositions(positions);
    };
    /** Get fallback positions based around target alignments. */
    /**
     * Get fallback positions based around target alignments.
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getFallbacks = /**
     * Get fallback positions based around target alignments.
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    function (hTarget, vTarget) {
        // Determine if the target alignments overlap the anchor
        /** @type {?} */
        var horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
        /** @type {?} */
        var verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
        // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
        // cover the anchor
        /** @type {?} */
        var possibleHorizontalAlignments = horizontalOverlapAllowed ?
            ['before', 'start', 'center', 'end', 'after'] :
            ['before', 'after'];
        /** @type {?} */
        var possibleVerticalAlignments = verticalOverlapAllowed ?
            ['above', 'start', 'center', 'end', 'below'] :
            ['above', 'below'];
        // Create fallbacks for each allowed prioritized fallback alignment combo
        /** @type {?} */
        var fallbacks = [];
        prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach(function (h) {
            prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach(function (v) {
                fallbacks.push(getPosition(h, v));
            });
        });
        // Remove the first item since it will be the target alignment and isn't considered a fallback
        return fallbacks.slice(1, fallbacks.length);
    };
    SatPopoverAnchoringService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    SatPopoverAnchoringService.ctorParameters = function () { return [
        { type: Overlay },
        { type: NgZone },
        { type: Directionality, decorators: [{ type: Optional }] }
    ]; };
    return SatPopoverAnchoringService;
}());
export { SatPopoverAnchoringService };
if (false) {
    /**
     * Emits when the popover is opened.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype.popoverOpened;
    /**
     * Emits when the popover is closed.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype.popoverClosed;
    /**
     * Reference to the overlay containing the popover component.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._overlayRef;
    /**
     * Reference to the target popover.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._popover;
    /**
     * Reference to the view container for the popover template.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._viewContainerRef;
    /**
     * Reference to the anchor element.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._anchor;
    /**
     * Reference to a template portal where the overlay will be attached.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._portal;
    /**
     * Communications channel with the popover.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._notifications;
    /**
     * Single subscription to notifications service events.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._notificationsSubscription;
    /**
     * Single subscription to position changes.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._positionChangeSubscription;
    /**
     * Whether the popover is presently open.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._popoverOpen;
    /**
     * Emits when the service is destroyed.
     * @type {?}
     */
    SatPopoverAnchoringService.prototype._onDestroy;
    /** @type {?} */
    SatPopoverAnchoringService.prototype._overlay;
    /** @type {?} */
    SatPopoverAnchoringService.prototype._ngZone;
    /** @type {?} */
    SatPopoverAnchoringService.prototype._dir;
}
/**
 * Helper function to get a cdk position pair from SatPopover alignments.
 * @param {?} h
 * @param {?} v
 * @return {?}
 */
function getPosition(h, v) {
    var _a = getHorizontalConnectionPosPair(h), originX = _a.originX, overlayX = _a.overlayX;
    var _b = getVerticalConnectionPosPair(v), originY = _b.originY, overlayY = _b.overlayY;
    return new ConnectionPositionPair({ originX: originX, originY: originY }, { overlayX: overlayX, overlayY: overlayY });
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
    if (h === 'start') {
        return 'after';
    }
    if (h === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
    if (v === 'top') {
        return 'below';
    }
    if (v === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
    switch (h) {
        case 'before':
            return { originX: 'start', overlayX: 'end' };
        case 'start':
            return { originX: 'start', overlayX: 'start' };
        case 'end':
            return { originX: 'end', overlayX: 'end' };
        case 'after':
            return { originX: 'end', overlayX: 'start' };
        default:
            return { originX: 'center', overlayX: 'center' };
    }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
    switch (v) {
        case 'above':
            return { originY: 'top', overlayY: 'bottom' };
        case 'start':
            return { originY: 'top', overlayY: 'top' };
        case 'end':
            return { originY: 'bottom', overlayY: 'bottom' };
        case 'below':
            return { originY: 'bottom', overlayY: 'top' };
        default:
            return { originY: 'center', overlayY: 'center' };
    }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
    /** @type {?} */
    var targetIndex = options.indexOf(target);
    // Set the first item to be the target
    /** @type {?} */
    var reordered = [target];
    // Make left and right stacks where the highest priority item is last
    /** @type {?} */
    var left = options.slice(0, targetIndex);
    /** @type {?} */
    var right = options.slice(targetIndex + 1, options.length).reverse();
    // Alternate between stacks until one is empty
    while (left.length && right.length) {
        reordered.push(right.pop());
        reordered.push(left.pop());
    }
    // Flush out right side
    while (right.length) {
        reordered.push(right.pop());
    }
    // Flush out left side
    while (left.length) {
        reordered.push(left.pop());
    }
    return reordered;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyLyIsInNvdXJjZXMiOlsicG9wb3Zlci9wb3BvdmVyLWFuY2hvcmluZy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUVMLFVBQVUsRUFDVixNQUFNLEVBRU4sUUFBUSxFQUVULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDTCxzQkFBc0IsRUFHdEIsT0FBTyxFQUNQLGFBQWEsR0FJZCxNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBRSxjQUFjLEVBQVksTUFBTSxtQkFBbUIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDL0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3JELE9BQU8sRUFBZ0IsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQVU5RCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQzs7Ozs7O0FBTXhGLDRCQVFDOzs7SUFQQyx3Q0FBMkM7O0lBQzNDLHNDQUF1Qzs7SUFDdkMsb0NBQXFCOztJQUNyQixzQ0FBc0I7O0lBQ3RCLHVDQUF5Qzs7SUFDekMsdUNBQXdCOztJQUN4QixzQ0FBdUI7O0FBR3pCO0lBdUNFLG9DQUNVLFFBQWlCLEVBQ2pCLE9BQWUsRUFDSCxJQUFvQjtRQUZoQyxhQUFRLEdBQVIsUUFBUSxDQUFTO1FBQ2pCLFlBQU8sR0FBUCxPQUFPLENBQVE7UUFDSCxTQUFJLEdBQUosSUFBSSxDQUFnQjs7OztRQXRDMUMsa0JBQWEsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDOzs7O1FBR3BDLGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQzs7OztRQTJCNUIsaUJBQVksR0FBRyxLQUFLLENBQUM7Ozs7UUFHckIsZUFBVSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7SUFNckMsQ0FBQzs7OztJQUVMLGdEQUFXOzs7SUFBWDtRQUNFLHlFQUF5RTtRQUN6RSxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRXZCLDBCQUEwQjtRQUMxQixJQUFJLElBQUksQ0FBQywwQkFBMEIsRUFBRTtZQUNuQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDL0M7UUFDRCxJQUFJLElBQUksQ0FBQywyQkFBMkIsRUFBRTtZQUNwQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDaEQ7UUFDRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFM0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUM5QixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ2hDLENBQUM7SUFFRCxrRUFBa0U7Ozs7Ozs7O0lBQ2xFLDJDQUFNOzs7Ozs7O0lBQU4sVUFBTyxPQUFtQixFQUFFLGdCQUFrQyxFQUFFLE1BQWtCO1FBQ2hGLGdDQUFnQztRQUNoQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFdkIsb0JBQW9CO1FBQ3BCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxnQkFBZ0IsQ0FBQztRQUMxQyxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUV0QixzRkFBc0Y7UUFDdEYsK0RBQStEO1FBQy9ELElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSwwQkFBMEIsRUFBRSxDQUFDO1FBQ3RGLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRCxrREFBa0Q7Ozs7O0lBQ2xELGtEQUFhOzs7O0lBQWI7UUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQztJQUVELDhEQUE4RDs7Ozs7SUFDOUQsa0RBQWE7Ozs7SUFBYjtRQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdEUsQ0FBQztJQUVELHlCQUF5Qjs7Ozs7O0lBQ3pCLGdEQUFXOzs7OztJQUFYLFVBQVksT0FBbUM7UUFBbkMsd0JBQUEsRUFBQSxZQUFtQztRQUM3QyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUN0QixJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDaEMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3RCLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1lBQzVCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1lBQy9CLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1NBQ3pCO0lBQ0gsQ0FBQztJQUVELDBCQUEwQjs7Ozs7O0lBQzFCLGlEQUFZOzs7OztJQUFaLFVBQWEsS0FBVztRQUN0QixJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDcEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzdCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDM0I7SUFDSCxDQUFDO0lBRUQseUNBQXlDOzs7OztJQUN6QywyREFBc0I7Ozs7SUFBdEI7UUFDRSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7O2dCQUNkLE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRTs7Z0JBQ3JDLFFBQVEsR0FBRyxtQkFBQSxNQUFNLENBQUMsZ0JBQWdCLEVBQXFDO1lBQzdFLFFBQVEsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1NBQ2hDO0lBQ0gsQ0FBQztJQUVELDZDQUE2Qzs7Ozs7SUFDN0MscURBQWdCOzs7O0lBQWhCO1FBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7SUFFRCwwRUFBMEU7Ozs7OztJQUNsRSxzREFBaUI7Ozs7O0lBQXpCLFVBQTBCLE9BQThCOzs7WUFFaEQsWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLEtBQUssS0FBSztRQUNuRCxJQUFJLENBQUMsUUFBUSxDQUFDLHFCQUFxQixHQUFHLFlBQVksQ0FBQzs7O1lBRzdDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxLQUFLLEtBQUs7UUFDN0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsR0FBRyxTQUFTLENBQUM7SUFDL0MsQ0FBQztJQUVELHNEQUFzRDs7Ozs7SUFDOUMsbURBQWM7Ozs7SUFBdEI7UUFDRSx5Q0FBeUM7UUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQzs7Z0JBRWhGLGFBQWEsR0FBRztnQkFDcEIsZUFBZSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZTtnQkFDOUMsYUFBYSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYTtnQkFDMUMsV0FBVyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVztnQkFDdEMsYUFBYSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYTtnQkFDMUMsY0FBYyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYztnQkFDNUMsY0FBYyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYztnQkFDNUMsYUFBYSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYTthQUMzQzs7Z0JBRUssYUFBYSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUV6RSxJQUFJLENBQUMsMkJBQTJCLENBQzlCLG1CQUFBLGFBQWEsQ0FBQyxnQkFBZ0IsRUFBcUMsQ0FDcEUsQ0FBQztZQUVGLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDeEQ7UUFFRCw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMxQixDQUFDO0lBR0Qsb0VBQW9FOzs7OztJQUM1RCxvREFBZTs7OztJQUF2QjtRQUNFLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNwQixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzNCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1NBQ3pCO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRzs7Ozs7O0lBQ0ssOERBQXlCOzs7OztJQUFqQztRQUFBLGlCQVNDO1FBUkMsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUM1QyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FDakMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUNQLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQzNCLENBQUMsU0FBUyxDQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsZUFBZSxFQUFFLEVBQXRCLENBQXNCLENBQUMsQ0FBQztTQUMzQzthQUFNO1lBQ0wsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1NBQ3hCO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRzs7Ozs7O0lBQ0ssOERBQXlCOzs7OztJQUFqQztRQUFBLGlCQTJCQztRQTFCQyxJQUFJLElBQUksQ0FBQywwQkFBMEIsRUFBRTtZQUNuQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDL0M7UUFFRCxJQUFJLENBQUMsMEJBQTBCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUU7YUFDM0QsU0FBUyxDQUFDLFVBQUEsS0FBSztZQUNkLFFBQVEsS0FBSyxDQUFDLE1BQU0sRUFBRTtnQkFDcEIsS0FBSyxrQkFBa0IsQ0FBQyxJQUFJO29CQUMxQixLQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDOUIsTUFBTTtnQkFDUixLQUFLLGtCQUFrQixDQUFDLEtBQUs7b0JBQzNCLEtBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMvQixNQUFNO2dCQUNSLEtBQUssa0JBQWtCLENBQUMsTUFBTTtvQkFDNUIsS0FBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO29CQUNyQixNQUFNO2dCQUNSLEtBQUssa0JBQWtCLENBQUMsVUFBVSxDQUFDO2dCQUNqQywrRUFBK0U7Z0JBQ2pGLEtBQUssa0JBQWtCLENBQUMsYUFBYTtvQkFDbkMsS0FBSSxDQUFDLHlCQUF5QixFQUFFLENBQUM7b0JBQ2pDLE1BQU07Z0JBQ1IsS0FBSyxrQkFBa0IsQ0FBQyxPQUFPO29CQUM3QixLQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztvQkFDOUIsTUFBTTthQUNUO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsOENBQThDOzs7OztJQUN0Qyx5REFBb0I7Ozs7SUFBNUI7UUFBQSxpQkFVQztRQVRDLElBQUksQ0FBQyxXQUFXO2FBQ2IsYUFBYSxFQUFFO2FBQ2YsSUFBSSxDQUNILEdBQUcsQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLEVBQXBDLENBQW9DLENBQUMsRUFDL0MsTUFBTSxDQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixFQUE5QixDQUE4QixDQUFDLEVBQzVDLFNBQVMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQzdCLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQzNCO2FBQ0EsU0FBUyxDQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsWUFBWSxFQUFFLEVBQW5CLENBQW1CLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQsc0RBQXNEOzs7OztJQUM5Qyx1REFBa0I7Ozs7SUFBMUI7UUFBQSxpQkFXQztRQVZDLElBQUksQ0FBQyxXQUFXO2FBQ2IsYUFBYSxFQUFFO2FBQ2YsSUFBSSxDQUNILEdBQUcsQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLEtBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBeEMsQ0FBd0MsQ0FBQyxFQUN0RCxNQUFNLENBQUMsVUFBQSxLQUFLLElBQUksT0FBQSxLQUFLLENBQUMsT0FBTyxLQUFLLE1BQU0sRUFBeEIsQ0FBd0IsQ0FBQyxFQUN6QyxNQUFNLENBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLEVBQTlCLENBQThCLENBQUMsRUFDNUMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFDN0IsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FDM0I7YUFDQSxTQUFTLENBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxZQUFZLEVBQUUsRUFBbkIsQ0FBbUIsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCw4Q0FBOEM7Ozs7O0lBQ3RDLDREQUF1Qjs7OztJQUEvQjtRQUFBLGlCQUtDO1FBSkMsSUFBSSxDQUFDLFdBQVc7YUFDYixXQUFXLEVBQUU7YUFDYixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNoQyxTQUFTLENBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUF2QixDQUF1QixDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELHFEQUFxRDs7Ozs7SUFDN0MscURBQWdCOzs7O0lBQXhCO1FBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDdEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7WUFFL0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUMxQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUM3QjtJQUNILENBQUM7SUFFRCxxREFBcUQ7Ozs7OztJQUM3QyxxREFBZ0I7Ozs7O0lBQXhCLFVBQXlCLEtBQVc7UUFDbEMsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3JCLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1lBRWhELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNsQztJQUNILENBQUM7SUFFRCxxREFBcUQ7Ozs7O0lBQzdDLGtEQUFhOzs7O0lBQXJCO1FBQ0UsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDaEUsQ0FBQztJQUVELDJEQUEyRDs7Ozs7OztJQUNuRCxzREFBaUI7Ozs7OztJQUF6QixVQUEwQixNQUFxQixFQUFFLE1BQWtCO1FBQ2pFLE9BQU8sSUFBSSxhQUFhLENBQUM7WUFDdkIsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUN6QyxNQUFNLENBQUMsZUFBZSxFQUN0QixNQUFNLENBQUMsYUFBYSxFQUNwQixNQUFNLENBQUMsY0FBYyxFQUNyQixNQUFNLENBQUMsYUFBYSxFQUNwQixNQUFNLENBQ1A7WUFDRCxXQUFXLEVBQUUsTUFBTSxDQUFDLFdBQVc7WUFDL0IsYUFBYSxFQUFFLE1BQU0sQ0FBQyxhQUFhLElBQUksa0NBQWtDO1lBQ3pFLGNBQWMsRUFBRSxJQUFJLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQztZQUN0RSxTQUFTLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRTtTQUNoQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7OztPQUdHOzs7Ozs7O0lBQ0ssZ0VBQTJCOzs7Ozs7SUFBbkMsVUFBb0MsUUFBMkM7UUFBL0UsaUJBZ0JDO1FBZkMsSUFBSSxJQUFJLENBQUMsMkJBQTJCLEVBQUU7WUFDcEMsSUFBSSxDQUFDLDJCQUEyQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ2hEO1FBRUQsSUFBSSxDQUFDLDJCQUEyQixHQUFHLFFBQVEsQ0FBQyxlQUFlO2FBQ3hELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ2hDLFNBQVMsQ0FBQyxVQUFBLE1BQU07WUFDZixzREFBc0Q7WUFDdEQsS0FBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7Z0JBQ2YsS0FBSSxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FDaEMsNkJBQTZCLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFDN0QsMkJBQTJCLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FDNUQsQ0FBQztZQUNKLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsNkVBQTZFOzs7Ozs7SUFDckUsK0RBQTBCOzs7OztJQUFsQyxVQUFtQyxRQUFrQztRQUNuRSxRQUFRLFFBQVEsRUFBRTtZQUNoQixLQUFLLE9BQU87Z0JBQ1YsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2hELEtBQUssWUFBWTtnQkFDZixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDckQsS0FBSyxPQUFPO2dCQUNWLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNoRCxLQUFLLE1BQU0sQ0FBQztZQUNaO2dCQUNFLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUNoRDtJQUNILENBQUM7SUFFRCxnR0FBZ0c7Ozs7Ozs7Ozs7SUFDeEYseURBQW9COzs7Ozs7Ozs7SUFBNUIsVUFDRSxnQkFBMkMsRUFDM0MsY0FBdUMsRUFDdkMsY0FBdUIsRUFDdkIsYUFBc0IsRUFDdEIsTUFBa0I7OztZQUdaLGNBQWMsR0FBRyxXQUFXLENBQUMsZ0JBQWdCLEVBQUUsY0FBYyxDQUFDOztZQUM5RCxTQUFTLEdBQUcsQ0FBQyxjQUFjLENBQUM7O1lBRTVCLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRTthQUN0QyxtQkFBbUIsQ0FBQyxNQUFNLENBQUM7YUFDM0Isc0JBQXNCLENBQUMsS0FBSyxDQUFDO2FBQzdCLFFBQVEsQ0FBQyxLQUFLLENBQUM7YUFDZixrQkFBa0IsQ0FBQyxDQUFDLENBQUM7YUFDckIsa0JBQWtCLENBQUMsYUFBYSxDQUFDO1FBRXBDLGlGQUFpRjtRQUNqRixJQUFJLENBQUMsY0FBYyxFQUFFOztnQkFDYixTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUM7WUFDdEUsU0FBUyxDQUFDLElBQUksT0FBZCxTQUFTLG1CQUFTLFNBQVMsR0FBRTtTQUM5QjtRQUVELE9BQU8sUUFBUSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQsNkRBQTZEOzs7Ozs7O0lBQ3JELGtEQUFhOzs7Ozs7SUFBckIsVUFDRSxPQUFrQyxFQUNsQyxPQUFnQzs7O1lBRzFCLHdCQUF3QixHQUFHLE9BQU8sS0FBSyxRQUFRLElBQUksT0FBTyxLQUFLLE9BQU87O1lBQ3RFLHNCQUFzQixHQUFHLE9BQU8sS0FBSyxPQUFPLElBQUksT0FBTyxLQUFLLE9BQU87Ozs7WUFJbkUsNEJBQTRCLEdBQ2hDLHdCQUF3QixDQUFDLENBQUM7WUFDeEIsQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUMvQyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUM7O1lBQ2pCLDBCQUEwQixHQUM5QixzQkFBc0IsQ0FBQyxDQUFDO1lBQ3RCLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDOUMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDOzs7WUFHaEIsU0FBUyxHQUE2QixFQUFFO1FBQzlDLHNCQUFzQixDQUFDLE9BQU8sRUFBRSw0QkFBNEIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUM7WUFDckUsc0JBQXNCLENBQUMsT0FBTyxFQUFFLDBCQUEwQixDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUEsQ0FBQztnQkFDbkUsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEMsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILDhGQUE4RjtRQUM5RixPQUFPLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QyxDQUFDOztnQkExWUYsVUFBVTs7OztnQkFwQ1QsT0FBTztnQkFUUCxNQUFNO2dCQWVDLGNBQWMsdUJBd0VsQixRQUFROztJQWtXYixpQ0FBQztDQUFBLEFBNVlELElBNFlDO1NBM1lZLDBCQUEwQjs7Ozs7O0lBR3JDLG1EQUFvQzs7Ozs7SUFHcEMsbURBQW9DOzs7OztJQUdwQyxpREFBd0I7Ozs7O0lBR3hCLDhDQUE2Qjs7Ozs7SUFHN0IsdURBQTRDOzs7OztJQUc1Qyw2Q0FBNEI7Ozs7O0lBRzVCLDZDQUFxQzs7Ozs7SUFHckMsb0RBQW1EOzs7OztJQUduRCxnRUFBaUQ7Ozs7O0lBR2pELGlFQUFrRDs7Ozs7SUFHbEQsa0RBQTZCOzs7OztJQUc3QixnREFBeUM7O0lBR3ZDLDhDQUF5Qjs7SUFDekIsNkNBQXVCOztJQUN2QiwwQ0FBd0M7Ozs7Ozs7O0FBcVc1QyxTQUFTLFdBQVcsQ0FDbEIsQ0FBNEIsRUFDNUIsQ0FBMEI7SUFFcEIsSUFBQSxzQ0FBdUQsRUFBdEQsb0JBQU8sRUFBRSxzQkFBNkM7SUFDdkQsSUFBQSxvQ0FBcUQsRUFBcEQsb0JBQU8sRUFBRSxzQkFBMkM7SUFDM0QsT0FBTyxJQUFJLHNCQUFzQixDQUFDLEVBQUMsT0FBTyxTQUFBLEVBQUUsT0FBTyxTQUFBLEVBQUMsRUFBRSxFQUFDLFFBQVEsVUFBQSxFQUFFLFFBQVEsVUFBQSxFQUFDLENBQUMsQ0FBQztBQUM5RSxDQUFDOzs7Ozs7QUFHRCxTQUFTLDZCQUE2QixDQUFDLENBQTBCO0lBQy9ELElBQUksQ0FBQyxLQUFLLE9BQU8sRUFBRTtRQUNqQixPQUFPLE9BQU8sQ0FBQztLQUNoQjtJQUVELElBQUksQ0FBQyxLQUFLLEtBQUssRUFBRTtRQUNmLE9BQU8sUUFBUSxDQUFDO0tBQ2pCO0lBRUQsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQzs7Ozs7O0FBR0QsU0FBUywyQkFBMkIsQ0FBQyxDQUF3QjtJQUMzRCxJQUFJLENBQUMsS0FBSyxLQUFLLEVBQUU7UUFDZixPQUFPLE9BQU8sQ0FBQztLQUNoQjtJQUVELElBQUksQ0FBQyxLQUFLLFFBQVEsRUFBRTtRQUNsQixPQUFPLE9BQU8sQ0FBQztLQUNoQjtJQUVELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7Ozs7OztBQUdELFNBQVMsOEJBQThCLENBQUMsQ0FBNEI7SUFFbEUsUUFBUSxDQUFDLEVBQUU7UUFDVCxLQUFLLFFBQVE7WUFDWCxPQUFPLEVBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFDLENBQUM7UUFDN0MsS0FBSyxPQUFPO1lBQ1YsT0FBTyxFQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBQyxDQUFDO1FBQy9DLEtBQUssS0FBSztZQUNSLE9BQU8sRUFBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUMsQ0FBQztRQUMzQyxLQUFLLE9BQU87WUFDVixPQUFPLEVBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFDLENBQUM7UUFDN0M7WUFDRSxPQUFPLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFDLENBQUM7S0FDbEQ7QUFDSCxDQUFDOzs7Ozs7QUFHRCxTQUFTLDRCQUE0QixDQUFDLENBQTBCO0lBRTlELFFBQVEsQ0FBQyxFQUFFO1FBQ1QsS0FBSyxPQUFPO1lBQ1YsT0FBTyxFQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBQyxDQUFDO1FBQzlDLEtBQUssT0FBTztZQUNWLE9BQU8sRUFBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUMsQ0FBQztRQUMzQyxLQUFLLEtBQUs7WUFDUixPQUFPLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFDLENBQUM7UUFDakQsS0FBSyxPQUFPO1lBQ1YsT0FBTyxFQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBQyxDQUFDO1FBQzlDO1lBQ0UsT0FBTyxFQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBQyxDQUFDO0tBQ2xEO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7OztBQVdELFNBQVMsc0JBQXNCLENBQUksTUFBUyxFQUFFLE9BQVk7O1FBQ2xELFdBQVcsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQzs7O1FBR3JDLFNBQVMsR0FBRyxDQUFDLE1BQU0sQ0FBQzs7O1FBR3BCLElBQUksR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUM7O1FBQ3BDLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxDQUFDLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRTtJQUV0RSw4Q0FBOEM7SUFDOUMsT0FBTyxJQUFJLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7UUFDbEMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUM1QixTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0tBQzVCO0lBRUQsdUJBQXVCO0lBQ3ZCLE9BQU8sS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNuQixTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0tBQzdCO0lBRUQsc0JBQXNCO0lBQ3RCLE9BQU8sSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUNsQixTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0tBQzVCO0lBRUQsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEVsZW1lbnRSZWYsXG4gIEluamVjdGFibGUsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIsXG4gIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSxcbiAgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsXG4gIE92ZXJsYXksXG4gIE92ZXJsYXlDb25maWcsXG4gIE92ZXJsYXlSZWYsXG4gIFNjcm9sbFN0cmF0ZWd5LFxuICBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MsXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5LCBEaXJlY3Rpb259IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwsIHRha2UsIGZpbHRlciwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBTYXRQb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbiAgU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5LFxuICBTYXRQb3BvdmVyT3Blbk9wdGlvbnMsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5pbXBvcnQgeyBQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZSwgTm90aWZpY2F0aW9uQWN0aW9uIH0gZnJvbSAnLi9ub3RpZmljYXRpb24uc2VydmljZSc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBwcm92aWRlZCBieSB0aGUgcG9wb3ZlciBmb3IgdGhlIGFuY2hvcmluZyBzZXJ2aWNlXG4gKiB0byBidWlsZCB0aGUgY29ycmVjdCBvdmVybGF5IGNvbmZpZy5cbiAqL1xuaW50ZXJmYWNlIFBvcG92ZXJDb25maWcge1xuICBob3Jpem9udGFsQWxpZ246IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ247XG4gIHZlcnRpY2FsQWxpZ246IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduO1xuICBoYXNCYWNrZHJvcDogYm9vbGVhbjtcbiAgYmFja2Ryb3BDbGFzczogc3RyaW5nO1xuICBzY3JvbGxTdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5O1xuICBmb3JjZUFsaWdubWVudDogYm9vbGVhbjtcbiAgbG9ja0FsaWdubWVudDogYm9vbGVhbjtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIHBvcG92ZXJPcGVuZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgcG9wb3ZlckNsb3NlZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSBjb250YWluaW5nIHRoZSBwb3BvdmVyIGNvbXBvbmVudC4gKi9cbiAgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHBvcG92ZXIuICovXG4gIHByaXZhdGUgX3BvcG92ZXI6IFNhdFBvcG92ZXI7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdmlldyBjb250YWluZXIgZm9yIHRoZSBwb3BvdmVyIHRlbXBsYXRlLiAqL1xuICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGFuY2hvciBlbGVtZW50LiAqL1xuICBwcml2YXRlIF9hbmNob3I6IEVsZW1lbnRSZWY7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byBhIHRlbXBsYXRlIHBvcnRhbCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGF0dGFjaGVkLiAqL1xuICBwcml2YXRlIF9wb3J0YWw6IFRlbXBsYXRlUG9ydGFsPGFueT47XG5cbiAgLyoqIENvbW11bmljYXRpb25zIGNoYW5uZWwgd2l0aCB0aGUgcG9wb3Zlci4gKi9cbiAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uczogUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2U7XG5cbiAgLyoqIFNpbmdsZSBzdWJzY3JpcHRpb24gdG8gbm90aWZpY2F0aW9ucyBzZXJ2aWNlIGV2ZW50cy4gKi9cbiAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKiBTaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHBvc2l0aW9uIGNoYW5nZXMuICovXG4gIHByaXZhdGUgX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIHByaXZhdGUgX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHNlcnZpY2UgaXMgZGVzdHJveWVkLiAqL1xuICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyOiBEaXJlY3Rpb25hbGl0eVxuICApIHsgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIC8vIERlc3Ryb3kgcG9wb3ZlciBiZWZvcmUgdGVybWluYXRpbmcgc3Vic2NyaXB0aW9ucyBzbyB0aGF0IGFueSByZXN1bHRpbmdcbiAgICAvLyBkZXRhY2htZW50cyB1cGRhdGUgJ2Nsb3NlZCBzdGF0ZSdcbiAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgLy8gVGVybWluYXRlIHN1YnNjcmlwdGlvbnNcbiAgICBpZiAodGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG5cbiAgICB0aGlzLnBvcG92ZXJPcGVuZWQuY29tcGxldGUoKTtcbiAgICB0aGlzLnBvcG92ZXJDbG9zZWQuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBBbmNob3IgYSBwb3BvdmVyIGluc3RhbmNlIHRvIGEgdmlldyBhbmQgY29ubmVjdGlvbiBlbGVtZW50LiAqL1xuICBhbmNob3IocG9wb3ZlcjogU2F0UG9wb3Zlciwgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgYW5jaG9yOiBFbGVtZW50UmVmKTogdm9pZCB7XG4gICAgLy8gRGVzdHJveSBhbnkgcHJldmlvdXMgcG9wb3ZlcnNcbiAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgLy8gQXNzaWduIGxvY2FsIHJlZnNcbiAgICB0aGlzLl9wb3BvdmVyID0gcG9wb3ZlcjtcbiAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICB0aGlzLl9hbmNob3IgPSBhbmNob3I7XG5cbiAgICAvLyBQcm92aWRlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlIGFzIGEgY29tbXVuaWNhdGlvbiBjaGFubmVsIGJldHdlZW4gcG9wb3ZlciBhbmQgYW5jaG9yLlxuICAgIC8vIFRoZW4gc3Vic2NyaWJlIHRvIG5vdGlmaWNhdGlvbnMgdG8gdGFrZSBhcHByb3ByaWF0ZSBhY3Rpb25zLlxuICAgIHRoaXMuX3BvcG92ZXIuX25vdGlmaWNhdGlvbnMgPSB0aGlzLl9ub3RpZmljYXRpb25zID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlKCk7XG4gICAgdGhpcy5fc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zKCk7XG4gIH1cblxuICAvKiogR2V0cyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBpc1BvcG92ZXJPcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9wb3BvdmVyT3BlbjtcbiAgfVxuXG4gIC8qKiBUb2dnbGVzIHRoZSBwb3BvdmVyIGJldHdlZW4gdGhlIG9wZW4gYW5kIGNsb3NlZCBzdGF0ZXMuICovXG4gIHRvZ2dsZVBvcG92ZXIoKTogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuID8gdGhpcy5jbG9zZVBvcG92ZXIoKSA6IHRoaXMub3BlblBvcG92ZXIoKTtcbiAgfVxuXG4gIC8qKiBPcGVucyB0aGUgcG9wb3Zlci4gKi9cbiAgb3BlblBvcG92ZXIob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zID0ge30pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICB0aGlzLl9hcHBseU9wZW5PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9CYWNrZHJvcCgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9Fc2NhcGUoKTtcbiAgICAgIHRoaXMuX3N1YnNjcmliZVRvRGV0YWNobWVudHMoKTtcbiAgICAgIHRoaXMuX3NhdmVPcGVuZWRTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDbG9zZXMgdGhlIHBvcG92ZXIuICovXG4gIGNsb3NlUG9wb3Zlcih2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9zYXZlQ2xvc2VkU3RhdGUodmFsdWUpO1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICB9XG4gIH1cblxuICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICByZWFsaWduUG9wb3ZlclRvQW5jaG9yKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLl9vdmVybGF5UmVmLmdldENvbmZpZygpO1xuICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb25maWcucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgICBzdHJhdGVneS5yZWFwcGx5TGFzdFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuICovXG4gIGdldEFuY2hvckVsZW1lbnQoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgfVxuXG4gIC8qKiBBcHBseSBiZWhhdmlvciBwcm9wZXJ0aWVzIG9uIHRoZSBwb3BvdmVyIGJhc2VkIG9uIHRoZSBvcGVuIG9wdGlvbnMuICovXG4gIHByaXZhdGUgX2FwcGx5T3Blbk9wdGlvbnMob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zKTogdm9pZCB7XG4gICAgLy8gT25seSBvdmVycmlkZSByZXN0b3JlRm9jdXMgYXMgYGZhbHNlYCBpZiB0aGUgb3B0aW9uIGlzIGV4cGxpY2l0bHkgYGZhbHNlYFxuICAgIGNvbnN0IHJlc3RvcmVGb2N1cyA9IG9wdGlvbnMucmVzdG9yZUZvY3VzICE9PSBmYWxzZTtcbiAgICB0aGlzLl9wb3BvdmVyLl9yZXN0b3JlRm9jdXNPdmVycmlkZSA9IHJlc3RvcmVGb2N1cztcblxuICAgIC8vIE9ubHkgb3ZlcnJpZGUgYXV0b0ZvY3VzIGFzIGBmYWxzZWAgaWYgdGhlIG9wdGlvbiBpcyBleHBsaWNpdGx5IGBmYWxzZWBcbiAgICBjb25zdCBhdXRvRm9jdXMgPSBvcHRpb25zLmF1dG9Gb2N1cyAhPT0gZmFsc2U7XG4gICAgdGhpcy5fcG9wb3Zlci5fYXV0b0ZvY3VzT3ZlcnJpZGUgPSBhdXRvRm9jdXM7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuIG92ZXJsYXkgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHBvcnRhbC4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcbiAgICAvLyBDcmVhdGUgb3ZlcmxheSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX3BvcG92ZXIuX3RlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcblxuICAgICAgY29uc3QgcG9wb3ZlckNvbmZpZyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbEFsaWduOiB0aGlzLl9wb3BvdmVyLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5fcG9wb3Zlci52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBoYXNCYWNrZHJvcDogdGhpcy5fcG9wb3Zlci5oYXNCYWNrZHJvcCxcbiAgICAgICAgYmFja2Ryb3BDbGFzczogdGhpcy5fcG9wb3Zlci5iYWNrZHJvcENsYXNzLFxuICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fcG9wb3Zlci5zY3JvbGxTdHJhdGVneSxcbiAgICAgICAgZm9yY2VBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgIGxvY2tBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIubG9ja0FsaWdubWVudCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKHBvcG92ZXJDb25maWcsIHRoaXMuX2FuY2hvcik7XG5cbiAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKFxuICAgICAgICBvdmVybGF5Q29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgICApO1xuXG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheUNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgb3BlbiB0aGUgcG9wb3ZlclxuICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gIH1cblxuXG4gIC8qKiBSZW1vdmVzIHRoZSBwb3BvdmVyIGZyb20gdGhlIERPTS4gRG9lcyBOT1QgdXBkYXRlIG9wZW4gc3RhdGUuICovXG4gIHByaXZhdGUgX2Rlc3Ryb3lQb3BvdmVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcG9wb3ZlciBpbW1lZGlhdGVseSBpZiBpdCBpcyBjbG9zZWQsIG9yIHdhaXRzIHVudGlsIGl0XG4gICAqIGhhcyBiZWVuIGNsb3NlZCB0byBkZXN0cm95IGl0LlxuICAgKi9cbiAgcHJpdmF0ZSBfZGVzdHJveVBvcG92ZXJPbmNlQ2xvc2VkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzUG9wb3Zlck9wZW4oKSAmJiB0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaG1lbnRzKCkucGlwZShcbiAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2Rlc3Ryb3lQb3BvdmVyKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGFwcHJvcHJpYXRlIGFuY2hvciBtZXRob2Qgd2hlbiBhbiBldmVudCBpcyBkaXNwYXRjaGVkIHRocm91Z2hcbiAgICogdGhlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlLlxuICAgKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbiA9IHRoaXMuX25vdGlmaWNhdGlvbnMuZXZlbnRzKClcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmFjdGlvbikge1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLk9QRU46XG4gICAgICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLkNMT1NFOlxuICAgICAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoZXZlbnQudmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBOb3RpZmljYXRpb25BY3Rpb24uVE9HR0xFOlxuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3BvdmVyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OOlxuICAgICAgICAgICAgLy8gVE9ETzogV2hlbiB0aGUgb3ZlcmxheSdzIHBvc2l0aW9uIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkLCBkbyBub3QgZGVzdHJveVxuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLlVQREFURV9DT05GSUc6XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95UG9wb3Zlck9uY2VDbG9zZWQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLlJFQUxJR046XG4gICAgICAgICAgICB0aGlzLnJlYWxpZ25Qb3BvdmVyVG9BbmNob3IoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBDbG9zZSBwb3BvdmVyIHdoZW4gYmFja2Ryb3AgaXMgY2xpY2tlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcCgpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuYmFja2Ryb3BDbGljaygpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKCgpID0+IHRoaXMuX3BvcG92ZXIuYmFja2Ryb3BDbGlja2VkLmVtaXQoKSksXG4gICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl9wb3BvdmVyLmludGVyYWN0aXZlQ2xvc2UpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyQ2xvc2VkKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2VQb3BvdmVyKCkpO1xuICB9XG5cbiAgLyoqIENsb3NlIHBvcG92ZXIgd2hlbiBlc2NhcGUga2V5ZG93biBldmVudCBvY2N1cnMuICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvRXNjYXBlKCk6IHZvaWQge1xuICAgIHRoaXMuX292ZXJsYXlSZWZcbiAgICAgIC5rZXlkb3duRXZlbnRzKClcbiAgICAgIC5waXBlKFxuICAgICAgICB0YXAoZXZlbnQgPT4gdGhpcy5fcG9wb3Zlci5vdmVybGF5S2V5ZG93bi5lbWl0KGV2ZW50KSksXG4gICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudC5rZXlDb2RlID09PSBFU0NBUEUpLFxuICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fcG9wb3Zlci5pbnRlcmFjdGl2ZUNsb3NlKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMucG9wb3ZlckNsb3NlZCksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlUG9wb3ZlcigpKTtcbiAgfVxuXG4gIC8qKiBTZXQgc3RhdGUgYmFjayB0byBjbG9zZWQgd2hlbiBkZXRhY2hlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9EZXRhY2htZW50cygpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuZGV0YWNobWVudHMoKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3NhdmVDbG9zZWRTdGF0ZSgpKTtcbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVPcGVuZWRTdGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICB0aGlzLl9wb3BvdmVyLl9vcGVuID0gdGhpcy5fcG9wb3Zlck9wZW4gPSB0cnVlO1xuXG4gICAgICB0aGlzLnBvcG92ZXJPcGVuZWQubmV4dCgpO1xuICAgICAgdGhpcy5fcG9wb3Zlci5vcGVuZWQuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBjbG9zZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVDbG9zZWRTdGF0ZSh2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wb3BvdmVyT3Blbikge1xuICAgICAgdGhpcy5fcG9wb3Zlci5fb3BlbiA9IHRoaXMuX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgICAgIHRoaXMucG9wb3ZlckNsb3NlZC5uZXh0KHZhbHVlKTtcbiAgICAgIHRoaXMuX3BvcG92ZXIuY2xvc2VkLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gIHByaXZhdGUgX2dldERpcmVjdGlvbigpOiBEaXJlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuZCByZXR1cm4gYSBjb25maWcgZm9yIGNyZWF0aW5nIHRoZSBvdmVybGF5LiAqL1xuICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnKGNvbmZpZzogUG9wb3ZlckNvbmZpZywgYW5jaG9yOiBFbGVtZW50UmVmKTogT3ZlcmxheUNvbmZpZyB7XG4gICAgcmV0dXJuIG5ldyBPdmVybGF5Q29uZmlnKHtcbiAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMuX2dldFBvc2l0aW9uU3RyYXRlZ3koXG4gICAgICAgIGNvbmZpZy5ob3Jpem9udGFsQWxpZ24sXG4gICAgICAgIGNvbmZpZy52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBjb25maWcuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgIGNvbmZpZy5sb2NrQWxpZ25tZW50LFxuICAgICAgICBhbmNob3IsXG4gICAgICApLFxuICAgICAgaGFzQmFja2Ryb3A6IGNvbmZpZy5oYXNCYWNrZHJvcCxcbiAgICAgIGJhY2tkcm9wQ2xhc3M6IGNvbmZpZy5iYWNrZHJvcENsYXNzIHx8ICdjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCcsXG4gICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZShjb25maWcuc2Nyb2xsU3RyYXRlZ3kpLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLl9nZXREaXJlY3Rpb24oKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldCB0aGUgY29ycmVjdCBhbGlnbm1lbnQgY2xhc3NlcyxcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYW5pbWF0aW9uIG9yaWdpbiBpcyBjb3JyZWN0LCBldmVuIHdpdGggYSBmYWxsYmFjayBwb3NpdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKHBvc2l0aW9uOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSBwb3NpdGlvbi5wb3NpdGlvbkNoYW5nZXNcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgICAvLyBQb3NpdGlvbiBjaGFuZ2VzIG1heSBvY2N1ciBvdXRzaWRlIHRoZSBBbmd1bGFyIHpvbmVcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcG9wb3Zlci5fc2V0QWxpZ25tZW50Q2xhc3NlcyhcbiAgICAgICAgICAgIGdldEhvcml6b250YWxQb3BvdmVyQWxpZ25tZW50KGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WCksXG4gICAgICAgICAgICBnZXRWZXJ0aWNhbFBvcG92ZXJBbGlnbm1lbnQoY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm92ZXJsYXlZKSxcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqIE1hcCBhIHNjcm9sbCBzdHJhdGVneSBzdHJpbmcgdHlwZSB0byBhbiBpbnN0YW5jZSBvZiBhIHNjcm9sbCBzdHJhdGVneS4gKi9cbiAgcHJpdmF0ZSBfZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZShzdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5KTogU2Nyb2xsU3RyYXRlZ3kge1xuICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5ibG9jaygpO1xuICAgICAgY2FzZSAncmVwb3NpdGlvbic6XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xuICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmNsb3NlKCk7XG4gICAgICBjYXNlICdub29wJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMubm9vcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDcmVhdGUgYW5kIHJldHVybiBhIHBvc2l0aW9uIHN0cmF0ZWd5IGJhc2VkIG9uIGNvbmZpZyBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLiAqL1xuICBwcml2YXRlIF9nZXRQb3NpdGlvblN0cmF0ZWd5KFxuICAgIGhvcml6b250YWxUYXJnZXQ6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gICAgdmVydGljYWxUYXJnZXQ6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduLFxuICAgIGZvcmNlQWxpZ25tZW50OiBib29sZWFuLFxuICAgIGxvY2tBbGlnbm1lbnQ6IGJvb2xlYW4sXG4gICAgYW5jaG9yOiBFbGVtZW50UmVmLFxuICApOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIC8vIEF0dGFjaCB0aGUgb3ZlcmxheSBhdCB0aGUgcHJlZmVycmVkIHBvc2l0aW9uXG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihob3Jpem9udGFsVGFyZ2V0LCB2ZXJ0aWNhbFRhcmdldCk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW3RhcmdldFBvc2l0aW9uXTtcblxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyhhbmNob3IpXG4gICAgICAud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSlcbiAgICAgIC53aXRoUHVzaChmYWxzZSlcbiAgICAgIC53aXRoVmlld3BvcnRNYXJnaW4oMClcbiAgICAgIC53aXRoTG9ja2VkUG9zaXRpb24obG9ja0FsaWdubWVudCk7XG5cbiAgICAvLyBVbmxlc3MgdGhlIGFsaWdubWVudCBpcyBmb3JjZWQsIGFkZCBmYWxsYmFja3MgYmFzZWQgb24gdGhlIHByZWZlcnJlZCBwb3NpdGlvbnNcbiAgICBpZiAoIWZvcmNlQWxpZ25tZW50KSB7XG4gICAgICBjb25zdCBmYWxsYmFja3MgPSB0aGlzLl9nZXRGYWxsYmFja3MoaG9yaXpvbnRhbFRhcmdldCwgdmVydGljYWxUYXJnZXQpO1xuICAgICAgcG9zaXRpb25zLnB1c2goLi4uZmFsbGJhY2tzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyYXRlZ3kud2l0aFBvc2l0aW9ucyhwb3NpdGlvbnMpO1xuICB9XG5cbiAgLyoqIEdldCBmYWxsYmFjayBwb3NpdGlvbnMgYmFzZWQgYXJvdW5kIHRhcmdldCBhbGlnbm1lbnRzLiAqL1xuICBwcml2YXRlIF9nZXRGYWxsYmFja3MoXG4gICAgaFRhcmdldDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbixcbiAgICB2VGFyZ2V0OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnblxuICApOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10ge1xuICAgIC8vIERldGVybWluZSBpZiB0aGUgdGFyZ2V0IGFsaWdubWVudHMgb3ZlcmxhcCB0aGUgYW5jaG9yXG4gICAgY29uc3QgaG9yaXpvbnRhbE92ZXJsYXBBbGxvd2VkID0gaFRhcmdldCAhPT0gJ2JlZm9yZScgJiYgaFRhcmdldCAhPT0gJ2FmdGVyJztcbiAgICBjb25zdCB2ZXJ0aWNhbE92ZXJsYXBBbGxvd2VkID0gdlRhcmdldCAhPT0gJ2Fib3ZlJyAmJiB2VGFyZ2V0ICE9PSAnYmVsb3cnO1xuXG4gICAgLy8gSWYgYSB0YXJnZXQgYWxpZ25tZW50IGRvZXNuJ3QgY292ZXIgdGhlIGFuY2hvciwgZG9uJ3QgbGV0IGFueSBvZiB0aGUgZmFsbGJhY2sgYWxpZ25tZW50c1xuICAgIC8vIGNvdmVyIHRoZSBhbmNob3JcbiAgICBjb25zdCBwb3NzaWJsZUhvcml6b250YWxBbGlnbm1lbnRzOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduW10gPVxuICAgICAgaG9yaXpvbnRhbE92ZXJsYXBBbGxvd2VkID9cbiAgICAgICAgWydiZWZvcmUnLCAnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCcsICdhZnRlciddIDpcbiAgICAgICAgWydiZWZvcmUnLCAnYWZ0ZXInXTtcbiAgICBjb25zdCBwb3NzaWJsZVZlcnRpY2FsQWxpZ25tZW50czogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ25bXSA9XG4gICAgICB2ZXJ0aWNhbE92ZXJsYXBBbGxvd2VkID9cbiAgICAgICAgWydhYm92ZScsICdzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2JlbG93J10gOlxuICAgICAgICBbJ2Fib3ZlJywgJ2JlbG93J107XG5cbiAgICAvLyBDcmVhdGUgZmFsbGJhY2tzIGZvciBlYWNoIGFsbG93ZWQgcHJpb3JpdGl6ZWQgZmFsbGJhY2sgYWxpZ25tZW50IGNvbWJvXG4gICAgY29uc3QgZmFsbGJhY2tzOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10gPSBbXTtcbiAgICBwcmlvcml0aXplQXJvdW5kVGFyZ2V0KGhUYXJnZXQsIHBvc3NpYmxlSG9yaXpvbnRhbEFsaWdubWVudHMpLmZvckVhY2goaCA9PiB7XG4gICAgICBwcmlvcml0aXplQXJvdW5kVGFyZ2V0KHZUYXJnZXQsIHBvc3NpYmxlVmVydGljYWxBbGlnbm1lbnRzKS5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBmYWxsYmFja3MucHVzaChnZXRQb3NpdGlvbihoLCB2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgaXRlbSBzaW5jZSBpdCB3aWxsIGJlIHRoZSB0YXJnZXQgYWxpZ25tZW50IGFuZCBpc24ndCBjb25zaWRlcmVkIGEgZmFsbGJhY2tcbiAgICByZXR1cm4gZmFsbGJhY2tzLnNsaWNlKDEsIGZhbGxiYWNrcy5sZW5ndGgpO1xuICB9XG5cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBjZGsgcG9zaXRpb24gcGFpciBmcm9tIFNhdFBvcG92ZXIgYWxpZ25tZW50cy4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKFxuICBoOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICB2OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbik6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIge1xuICBjb25zdCB7b3JpZ2luWCwgb3ZlcmxheVh9ID0gZ2V0SG9yaXpvbnRhbENvbm5lY3Rpb25Qb3NQYWlyKGgpO1xuICBjb25zdCB7b3JpZ2luWSwgb3ZlcmxheVl9ID0gZ2V0VmVydGljYWxDb25uZWN0aW9uUG9zUGFpcih2KTtcbiAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUG9zaXRpb25QYWlyKHtvcmlnaW5YLCBvcmlnaW5ZfSwge292ZXJsYXlYLCBvdmVybGF5WX0pO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQuICovXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsUG9wb3ZlckFsaWdubWVudChoOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyk6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24ge1xuICBpZiAoaCA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnYWZ0ZXInO1xuICB9XG5cbiAgaWYgKGggPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdiZWZvcmUnO1xuICB9XG5cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQuICovXG5mdW5jdGlvbiBnZXRWZXJ0aWNhbFBvcG92ZXJBbGlnbm1lbnQodjogVmVydGljYWxDb25uZWN0aW9uUG9zKTogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24ge1xuICBpZiAodiA9PT0gJ3RvcCcpIHtcbiAgICByZXR1cm4gJ2JlbG93JztcbiAgfVxuXG4gIGlmICh2ID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAnYWJvdmUnO1xuICB9XG5cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYWxpZ25tZW50IHRvIG9yaWdpbi9vdmVybGF5IHBvc2l0aW9uIHBhaXIuICovXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsQ29ubmVjdGlvblBvc1BhaXIoaDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbik6XG4gICAge29yaWdpblg6IEhvcml6b250YWxDb25uZWN0aW9uUG9zLCBvdmVybGF5WDogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3N9IHtcbiAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ3N0YXJ0Jywgb3ZlcmxheVg6ICdlbmQnfTtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICByZXR1cm4ge29yaWdpblg6ICdzdGFydCcsIG92ZXJsYXlYOiAnc3RhcnQnfTtcbiAgICBjYXNlICdlbmQnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnZW5kJywgb3ZlcmxheVg6ICdlbmQnfTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4ge29yaWdpblg6ICdlbmQnLCBvdmVybGF5WDogJ3N0YXJ0J307XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ2NlbnRlcicsIG92ZXJsYXlYOiAnY2VudGVyJ307XG4gIH1cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGFsaWdubWVudCB0byBvcmlnaW4vb3ZlcmxheSBwb3NpdGlvbiBwYWlyLiAqL1xuZnVuY3Rpb24gZ2V0VmVydGljYWxDb25uZWN0aW9uUG9zUGFpcih2OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbik6XG4gICAge29yaWdpblk6IFZlcnRpY2FsQ29ubmVjdGlvblBvcywgb3ZlcmxheVk6IFZlcnRpY2FsQ29ubmVjdGlvblBvc30ge1xuICBzd2l0Y2ggKHYpIHtcbiAgICBjYXNlICdhYm92ZSc6XG4gICAgICByZXR1cm4ge29yaWdpblk6ICd0b3AnLCBvdmVybGF5WTogJ2JvdHRvbSd9O1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHJldHVybiB7b3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlZOiAndG9wJ307XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWTogJ2JvdHRvbScsIG92ZXJsYXlZOiAnYm90dG9tJ307XG4gICAgY2FzZSAnYmVsb3cnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVk6ICd0b3AnfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnY2VudGVyJywgb3ZlcmxheVk6ICdjZW50ZXInfTtcbiAgfVxufVxuXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gb3JkZXJlZCBhcnJheSBvcHRpb25zIGFuZCByZXR1cm5zIGEgcmVvcmRlcmRlZFxuICogYXJyYXkgYXJvdW5kIHRoZSB0YXJnZXQgaXRlbS4gZS5nLjpcbiAqXG4gKiB0YXJnZXQ6IDM7IG9wdGlvbnM6IFsxLCAyLCAzLCA0LCA1LCA2LCA3XTtcbiAqXG4gKiByZXR1cm46IFszLCA0LCAyLCA1LCAxLCA2LCA3XVxuICovXG5mdW5jdGlvbiBwcmlvcml0aXplQXJvdW5kVGFyZ2V0PFQ+KHRhcmdldDogVCwgb3B0aW9uczogVFtdKTogVFtdIHtcbiAgY29uc3QgdGFyZ2V0SW5kZXggPSBvcHRpb25zLmluZGV4T2YodGFyZ2V0KTtcblxuICAvLyBTZXQgdGhlIGZpcnN0IGl0ZW0gdG8gYmUgdGhlIHRhcmdldFxuICBjb25zdCByZW9yZGVyZWQgPSBbdGFyZ2V0XTtcblxuICAvLyBNYWtlIGxlZnQgYW5kIHJpZ2h0IHN0YWNrcyB3aGVyZSB0aGUgaGlnaGVzdCBwcmlvcml0eSBpdGVtIGlzIGxhc3RcbiAgY29uc3QgbGVmdCA9IG9wdGlvbnMuc2xpY2UoMCwgdGFyZ2V0SW5kZXgpO1xuICBjb25zdCByaWdodCA9IG9wdGlvbnMuc2xpY2UodGFyZ2V0SW5kZXggKyAxLCBvcHRpb25zLmxlbmd0aCkucmV2ZXJzZSgpO1xuXG4gIC8vIEFsdGVybmF0ZSBiZXR3ZWVuIHN0YWNrcyB1bnRpbCBvbmUgaXMgZW1wdHlcbiAgd2hpbGUgKGxlZnQubGVuZ3RoICYmIHJpZ2h0Lmxlbmd0aCkge1xuICAgIHJlb3JkZXJlZC5wdXNoKHJpZ2h0LnBvcCgpKTtcbiAgICByZW9yZGVyZWQucHVzaChsZWZ0LnBvcCgpKTtcbiAgfVxuXG4gIC8vIEZsdXNoIG91dCByaWdodCBzaWRlXG4gIHdoaWxlIChyaWdodC5sZW5ndGgpIHtcbiAgICByZW9yZGVyZWQucHVzaChyaWdodC5wb3AoKSk7XG4gIH1cblxuICAvLyBGbHVzaCBvdXQgbGVmdCBzaWRlXG4gIHdoaWxlIChsZWZ0Lmxlbmd0aCkge1xuICAgIHJlb3JkZXJlZC5wdXNoKGxlZnQucG9wKCkpO1xuICB9XG5cbiAgcmV0dXJuIHJlb3JkZXJlZDtcbn1cbiJdfQ==