import { trigger, style, animate, transition } from '@angular/animations';
import { Injectable, Component, ElementRef, EventEmitter, Inject, Input, ViewChild, ViewEncapsulation, TemplateRef, Optional, Output, NgZone, Directive, ViewContainerRef, HostListener, NgModule } from '@angular/core';
import { Subject, merge, of } from 'rxjs';
import { DOCUMENT, CommonModule } from '@angular/common';
import { FocusTrapFactory, A11yModule } from '@angular/cdk/a11y';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { ConnectionPositionPair, Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { ESCAPE } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import { takeUntil, take, filter, tap, delay, switchMap } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const transformPopover = trigger('transformPopover', [
    transition(':enter', [
        style({ opacity: 0, transform: 'scale(0.3)' }),
        animate('{{openTransition}}', style({ opacity: 1, transform: 'scale(1)' }))
    ]),
    transition(':leave', [
        animate('{{closeTransition}}', style({ opacity: 0, transform: 'scale(0.5)' }))
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @enum {number} */
const NotificationAction = {
    /** Popover should open. */
    OPEN: 0,
    /** Popover should close. */
    CLOSE: 1,
    /** Popover should toggle open or closed. */
    TOGGLE: 2,
    /** Popover has new target positions. */
    REPOSITION: 3,
    /** Popover needs new configuration. */
    UPDATE_CONFIG: 4,
    /** Popover should realign itself to the anchor.  */
    REALIGN: 5,
};
NotificationAction[NotificationAction.OPEN] = 'OPEN';
NotificationAction[NotificationAction.CLOSE] = 'CLOSE';
NotificationAction[NotificationAction.TOGGLE] = 'TOGGLE';
NotificationAction[NotificationAction.REPOSITION] = 'REPOSITION';
NotificationAction[NotificationAction.UPDATE_CONFIG] = 'UPDATE_CONFIG';
NotificationAction[NotificationAction.REALIGN] = 'REALIGN';
/**
 * Event object for dispatching to anchoring service.
 */
class PopoverNotification {
    /**
     * @param {?} action
     * @param {?=} value
     */
    constructor(action, value) {
        this.action = action;
        this.value = value;
    }
}
class PopoverNotificationService {
    constructor() {
        this.store = new Subject();
    }
    /**
     * Dispatch a notification to all subscribers.
     * @param {?} notification
     * @return {?}
     */
    dispatch(notification) {
        this.store.next(notification);
    }
    /**
     * Stream of notification events.
     * @return {?}
     */
    events() {
        return this.store.asObservable();
    }
    /**
     * Complete event stream.
     * @return {?}
     */
    dispose() {
        this.store.complete();
    }
}
PopoverNotificationService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const VALID_SCROLL = [
    'noop',
    'block',
    'reposition',
    'close'
];
/** @type {?} */
const VALID_HORIZ_ALIGN = [
    'before',
    'start',
    'center',
    'end',
    'after'
];
/** @type {?} */
const VALID_VERT_ALIGN = [
    'above',
    'start',
    'center',
    'end',
    'below'
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getInvalidPopoverError() {
    return Error('SatPopoverAnchor must be provided an SatPopover component instance.');
}
/**
 * @return {?}
 */
function getUnanchoredPopoverError() {
    return Error('SatPopover is not anchored to any SatPopoverAnchor.');
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidHorizontalAlignError(alignment) {
    return Error(generateGenericError('horizontalAlign/xAlign', alignment, VALID_HORIZ_ALIGN));
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidVerticalAlignError(alignment) {
    return Error(generateGenericError('verticalAlign/yAlign', alignment, VALID_VERT_ALIGN));
}
/**
 * @param {?} strategy
 * @return {?}
 */
function getInvalidScrollStrategyError(strategy) {
    return Error(generateGenericError('scrollStrategy', strategy, VALID_SCROLL));
}
/**
 * @param {?} apiName
 * @param {?} invalid
 * @param {?} valid
 * @return {?}
 */
function generateGenericError(apiName, invalid, valid) {
    return `Invalid ${apiName}: '${invalid}'. Valid options are ` +
        `${valid.map(v => `'${v}'`).join(', ')}.`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
/** @type {?} */
const DEFAULT_TRANSITION = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';
class SatPopover {
    /**
     * @param {?} _focusTrapFactory
     * @param {?} _document
     */
    constructor(_focusTrapFactory, _document) {
        this._focusTrapFactory = _focusTrapFactory;
        this._document = _document;
        this._horizontalAlign = 'center';
        this._verticalAlign = 'center';
        this._forceAlignment = false;
        this._lockAlignment = false;
        this._autoFocus = true;
        this._autoFocusOverride = true;
        this._restoreFocus = true;
        this._restoreFocusOverride = true;
        this._scrollStrategy = 'reposition';
        this._hasBackdrop = false;
        this._interactiveClose = true;
        this._openTransition = DEFAULT_TRANSITION;
        this._closeTransition = DEFAULT_TRANSITION;
        /**
         * Optional backdrop class.
         */
        this.backdropClass = '';
        /**
         * Emits when the popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Emits when the popover has finished opening.
         */
        this.afterOpen = new EventEmitter();
        /**
         * Emits when the popover has finished closing.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits when the backdrop is clicked.
         */
        this.backdropClicked = new EventEmitter();
        /**
         * Emits when a keydown event is targeted to this popover's overlay.
         */
        this.overlayKeydown = new EventEmitter();
        /**
         * Classes to be added to the popover for setting the correct transform origin.
         */
        this._classList = {};
        /**
         * Whether the popover is presently open.
         */
        this._open = false;
    }
    /**
     * Alignment of the popover on the horizontal axis.
     * @return {?}
     */
    get horizontalAlign() { return this._horizontalAlign; }
    /**
     * @param {?} val
     * @return {?}
     */
    set horizontalAlign(val) {
        this._validateHorizontalAlign(val);
        if (this._horizontalAlign !== val) {
            this._horizontalAlign = val;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Alignment of the popover on the x axis. Alias for `horizontalAlign`.
     * @return {?}
     */
    get xAlign() { return this.horizontalAlign; }
    /**
     * @param {?} val
     * @return {?}
     */
    set xAlign(val) { this.horizontalAlign = val; }
    /**
     * Alignment of the popover on the vertical axis.
     * @return {?}
     */
    get verticalAlign() { return this._verticalAlign; }
    /**
     * @param {?} val
     * @return {?}
     */
    set verticalAlign(val) {
        this._validateVerticalAlign(val);
        if (this._verticalAlign !== val) {
            this._verticalAlign = val;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Alignment of the popover on the y axis. Alias for `verticalAlign`.
     * @return {?}
     */
    get yAlign() { return this.verticalAlign; }
    /**
     * @param {?} val
     * @return {?}
     */
    set yAlign(val) { this.verticalAlign = val; }
    /**
     * Whether the popover always opens with the specified alignment.
     * @return {?}
     */
    get forceAlignment() { return this._forceAlignment; }
    /**
     * @param {?} val
     * @return {?}
     */
    set forceAlignment(val) {
        /** @type {?} */
        const coercedVal = coerceBooleanProperty(val);
        if (this._forceAlignment !== coercedVal) {
            this._forceAlignment = coercedVal;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Whether the popover's alignment is locked after opening. This prevents the popover
     * from changing its alignement when scrolling or changing the size of the viewport.
     * @return {?}
     */
    get lockAlignment() { return this._lockAlignment; }
    /**
     * @param {?} val
     * @return {?}
     */
    set lockAlignment(val) {
        /** @type {?} */
        const coercedVal = coerceBooleanProperty(val);
        if (this._lockAlignment !== coercedVal) {
            this._lockAlignment = coerceBooleanProperty(val);
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Whether the first focusable element should be focused on open.
     * @return {?}
     */
    get autoFocus() { return this._autoFocus && this._autoFocusOverride; }
    /**
     * @param {?} val
     * @return {?}
     */
    set autoFocus(val) {
        this._autoFocus = coerceBooleanProperty(val);
    }
    /**
     * Whether the popover should return focus to the previously focused element after closing.
     * @return {?}
     */
    get restoreFocus() { return this._restoreFocus && this._restoreFocusOverride; }
    /**
     * @param {?} val
     * @return {?}
     */
    set restoreFocus(val) {
        this._restoreFocus = coerceBooleanProperty(val);
    }
    /**
     * How the popover should handle scrolling.
     * @return {?}
     */
    get scrollStrategy() { return this._scrollStrategy; }
    /**
     * @param {?} val
     * @return {?}
     */
    set scrollStrategy(val) {
        this._validateScrollStrategy(val);
        if (this._scrollStrategy !== val) {
            this._scrollStrategy = val;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
        }
    }
    /**
     * Whether the popover should have a backdrop (includes closing on click).
     * @return {?}
     */
    get hasBackdrop() { return this._hasBackdrop; }
    /**
     * @param {?} val
     * @return {?}
     */
    set hasBackdrop(val) {
        this._hasBackdrop = coerceBooleanProperty(val);
    }
    /**
     * Whether the popover should close when the user clicks the backdrop or presses ESC.
     * @return {?}
     */
    get interactiveClose() { return this._interactiveClose; }
    /**
     * @param {?} val
     * @return {?}
     */
    set interactiveClose(val) {
        this._interactiveClose = coerceBooleanProperty(val);
    }
    /**
     * Custom transition to use while opening.
     * @return {?}
     */
    get openTransition() { return this._openTransition; }
    /**
     * @param {?} val
     * @return {?}
     */
    set openTransition(val) {
        if (val) {
            this._openTransition = val;
        }
    }
    /**
     * Custom transition to use while closing.
     * @return {?}
     */
    get closeTransition() { return this._closeTransition; }
    /**
     * @param {?} val
     * @return {?}
     */
    set closeTransition(val) {
        if (val) {
            this._closeTransition = val;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._setAlignmentClasses();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._notifications) {
            this._notifications.dispose();
        }
    }
    /**
     * Open this popover.
     * @param {?=} options
     * @return {?}
     */
    open(options = {}) {
        /** @type {?} */
        const notification = new PopoverNotification(NotificationAction.OPEN, options);
        this._dispatchActionNotification(notification);
    }
    /**
     * Close this popover.
     * @param {?=} value
     * @return {?}
     */
    close(value) {
        /** @type {?} */
        const notification = new PopoverNotification(NotificationAction.CLOSE, value);
        this._dispatchActionNotification(notification);
    }
    /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    toggle() {
        /** @type {?} */
        const notification = new PopoverNotification(NotificationAction.TOGGLE);
        this._dispatchActionNotification(notification);
    }
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    realign() {
        /** @type {?} */
        const notification = new PopoverNotification(NotificationAction.REALIGN);
        this._dispatchActionNotification(notification);
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isOpen() {
        return this._open;
    }
    /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    _getAnimation() {
        return {
            value: 'visible',
            params: { openTransition: this.openTransition, closeTransition: this.closeTransition }
        };
    }
    /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    _onAnimationDone(event) {
        if (event.toState === 'visible') {
            this._trapFocus();
            this.afterOpen.emit();
        }
        else if (event.toState === 'void') {
            this._restoreFocusAndDestroyTrap();
            this.afterClose.emit();
        }
    }
    /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    _setAlignmentClasses(horizAlign = this.horizontalAlign, vertAlign = this.verticalAlign) {
        this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';
        this._classList['sat-popover-after'] = horizAlign === 'after' || horizAlign === 'start';
        this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';
        this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';
        this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';
    }
    /**
     * Move the focus inside the focus trap and remember where to return later.
     * @return {?}
     */
    _trapFocus() {
        this._savePreviouslyFocusedElement();
        // There won't be a focus trap element if the close animation starts before open finishes
        if (!this._focusTrapElement) {
            return;
        }
        if (!this._focusTrap && this._focusTrapElement) {
            this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
        }
        if (this.autoFocus) {
            this._focusTrap.focusInitialElementWhenReady();
        }
    }
    /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @return {?}
     */
    _restoreFocusAndDestroyTrap() {
        /** @type {?} */
        const toFocus = this._previouslyFocusedElement;
        // Must check active element is focusable for IE sake
        if (toFocus && 'focus' in toFocus && this.restoreFocus) {
            this._previouslyFocusedElement.focus();
        }
        this._previouslyFocusedElement = null;
        if (this._focusTrap) {
            this._focusTrap.destroy();
            this._focusTrap = undefined;
        }
    }
    /**
     * Save a reference to the element focused before the popover was opened.
     * @return {?}
     */
    _savePreviouslyFocusedElement() {
        if (this._document) {
            this._previouslyFocusedElement = (/** @type {?} */ (this._document.activeElement));
        }
    }
    /**
     * Dispatch a notification to the notification service, if possible.
     * @param {?} notification
     * @return {?}
     */
    _dispatchConfigNotification(notification) {
        if (this._notifications) {
            this._notifications.dispatch(notification);
        }
    }
    /**
     * Dispatch a notification to the notification service and throw if unable to.
     * @param {?} notification
     * @return {?}
     */
    _dispatchActionNotification(notification) {
        if (!this._notifications) {
            throw getUnanchoredPopoverError();
        }
        this._notifications.dispatch(notification);
    }
    /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @param {?} pos
     * @return {?}
     */
    _validateHorizontalAlign(pos) {
        if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
            throw getInvalidHorizontalAlignError(pos);
        }
    }
    /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @param {?} pos
     * @return {?}
     */
    _validateVerticalAlign(pos) {
        if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
            throw getInvalidVerticalAlignError(pos);
        }
    }
    /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @param {?} strategy
     * @return {?}
     */
    _validateScrollStrategy(strategy) {
        if (VALID_SCROLL.indexOf(strategy) === -1) {
            throw getInvalidScrollStrategyError(strategy);
        }
    }
}
SatPopover.decorators = [
    { type: Component, args: [{
                selector: 'sat-popover',
                encapsulation: ViewEncapsulation.None,
                animations: [transformPopover],
                template: "<ng-template>\n  <div class=\"sat-popover-container\"\n      #focusTrapElement\n      [ngClass]=\"_classList\"\n      [@transformPopover]=\"_getAnimation()\"\n      (@transformPopover.done)=\"_onAnimationDone($event)\">\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n",
                styles: [".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}.sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}.sat-popover-container.sat-popover-center.sat-popover-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.sat-popover-container.sat-popover-center.sat-popover-below{-webkit-transform-origin:center top;transform-origin:center top}.sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}.sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}"]
            }] }
];
/** @nocollapse */
SatPopover.ctorParameters = () => [
    { type: FocusTrapFactory },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
SatPopover.propDecorators = {
    horizontalAlign: [{ type: Input }],
    xAlign: [{ type: Input }],
    verticalAlign: [{ type: Input }],
    yAlign: [{ type: Input }],
    forceAlignment: [{ type: Input }],
    lockAlignment: [{ type: Input }],
    autoFocus: [{ type: Input }],
    restoreFocus: [{ type: Input }],
    scrollStrategy: [{ type: Input }],
    hasBackdrop: [{ type: Input }],
    interactiveClose: [{ type: Input }],
    openTransition: [{ type: Input }],
    closeTransition: [{ type: Input }],
    backdropClass: [{ type: Input }],
    opened: [{ type: Output }],
    closed: [{ type: Output }],
    afterOpen: [{ type: Output }],
    afterClose: [{ type: Output }],
    backdropClicked: [{ type: Output }],
    overlayKeydown: [{ type: Output }],
    _templateRef: [{ type: ViewChild, args: [TemplateRef,] }],
    _focusTrapElement: [{ type: ViewChild, args: ['focusTrapElement',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class SatPopoverAnchoringService {
    /**
     * @param {?} _overlay
     * @param {?} _ngZone
     * @param {?} _dir
     */
    constructor(_overlay, _ngZone, _dir) {
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new Subject();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new Subject();
        /**
         * Whether the popover is presently open.
         */
        this._popoverOpen = false;
        /**
         * Emits when the service is destroyed.
         */
        this._onDestroy = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Destroy popover before terminating subscriptions so that any resulting
        // detachments update 'closed state'
        this._destroyPopover();
        // Terminate subscriptions
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._onDestroy.next();
        this._onDestroy.complete();
        this.popoverOpened.complete();
        this.popoverClosed.complete();
    }
    /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    anchor(popover, viewContainerRef, anchor) {
        // Destroy any previous popovers
        this._destroyPopover();
        // Assign local refs
        this._popover = popover;
        this._viewContainerRef = viewContainerRef;
        this._anchor = anchor;
        // Provide notification service as a communication channel between popover and anchor.
        // Then subscribe to notifications to take appropriate actions.
        this._popover._notifications = this._notifications = new PopoverNotificationService();
        this._subscribeToNotifications();
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isPopoverOpen() {
        return this._popoverOpen;
    }
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    togglePopover() {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    }
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    openPopover(options = {}) {
        if (!this._popoverOpen) {
            this._applyOpenOptions(options);
            this._createOverlay();
            this._subscribeToBackdrop();
            this._subscribeToEscape();
            this._subscribeToDetachments();
            this._saveOpenedState();
        }
    }
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    closePopover(value) {
        if (this._overlayRef) {
            this._saveClosedState(value);
            this._overlayRef.detach();
        }
    }
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    realignPopoverToAnchor() {
        if (this._overlayRef) {
            /** @type {?} */
            const config = this._overlayRef.getConfig();
            /** @type {?} */
            const strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.reapplyLastPosition();
        }
    }
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    getAnchorElement() {
        return this._anchor;
    }
    /**
     * Apply behavior properties on the popover based on the open options.
     * @param {?} options
     * @return {?}
     */
    _applyOpenOptions(options) {
        // Only override restoreFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        const restoreFocus = options.restoreFocus !== false;
        this._popover._restoreFocusOverride = restoreFocus;
        // Only override autoFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        const autoFocus = options.autoFocus !== false;
        this._popover._autoFocusOverride = autoFocus;
    }
    /**
     * Create an overlay to be attached to the portal.
     * @return {?}
     */
    _createOverlay() {
        // Create overlay if it doesn't yet exist
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);
            /** @type {?} */
            const popoverConfig = {
                horizontalAlign: this._popover.horizontalAlign,
                verticalAlign: this._popover.verticalAlign,
                hasBackdrop: this._popover.hasBackdrop,
                backdropClass: this._popover.backdropClass,
                scrollStrategy: this._popover.scrollStrategy,
                forceAlignment: this._popover.forceAlignment,
                lockAlignment: this._popover.lockAlignment,
            };
            /** @type {?} */
            const overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
            this._subscribeToPositionChanges((/** @type {?} */ (overlayConfig.positionStrategy)));
            this._overlayRef = this._overlay.create(overlayConfig);
        }
        // Actually open the popover
        this._overlayRef.attach(this._portal);
        return this._overlayRef;
    }
    /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @return {?}
     */
    _destroyPopover() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    }
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @return {?}
     */
    _destroyPopoverOnceClosed() {
        if (this.isPopoverOpen() && this._overlayRef) {
            this._overlayRef.detachments().pipe(take(1), takeUntil(this._onDestroy)).subscribe(() => this._destroyPopover());
        }
        else {
            this._destroyPopover();
        }
    }
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @return {?}
     */
    _subscribeToNotifications() {
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        this._notificationsSubscription = this._notifications.events()
            .subscribe(event => {
            switch (event.action) {
                case NotificationAction.OPEN:
                    this.openPopover(event.value);
                    break;
                case NotificationAction.CLOSE:
                    this.closePopover(event.value);
                    break;
                case NotificationAction.TOGGLE:
                    this.togglePopover();
                    break;
                case NotificationAction.REPOSITION:
                // TODO: When the overlay's position can be dynamically changed, do not destroy
                case NotificationAction.UPDATE_CONFIG:
                    this._destroyPopoverOnceClosed();
                    break;
                case NotificationAction.REALIGN:
                    this.realignPopoverToAnchor();
                    break;
            }
        });
    }
    /**
     * Close popover when backdrop is clicked.
     * @return {?}
     */
    _subscribeToBackdrop() {
        this._overlayRef
            .backdropClick()
            .pipe(tap(() => this._popover.backdropClicked.emit()), filter(() => this._popover.interactiveClose), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe(() => this.closePopover());
    }
    /**
     * Close popover when escape keydown event occurs.
     * @return {?}
     */
    _subscribeToEscape() {
        this._overlayRef
            .keydownEvents()
            .pipe(tap(event => this._popover.overlayKeydown.emit(event)), filter(event => event.keyCode === ESCAPE), filter(() => this._popover.interactiveClose), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe(() => this.closePopover());
    }
    /**
     * Set state back to closed when detached.
     * @return {?}
     */
    _subscribeToDetachments() {
        this._overlayRef
            .detachments()
            .pipe(takeUntil(this._onDestroy))
            .subscribe(() => this._saveClosedState());
    }
    /**
     * Save the opened state of the popover and emit.
     * @return {?}
     */
    _saveOpenedState() {
        if (!this._popoverOpen) {
            this._popover._open = this._popoverOpen = true;
            this.popoverOpened.next();
            this._popover.opened.emit();
        }
    }
    /**
     * Save the closed state of the popover and emit.
     * @param {?=} value
     * @return {?}
     */
    _saveClosedState(value) {
        if (this._popoverOpen) {
            this._popover._open = this._popoverOpen = false;
            this.popoverClosed.next(value);
            this._popover.closed.emit(value);
        }
    }
    /**
     * Gets the text direction of the containing app.
     * @return {?}
     */
    _getDirection() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * Create and return a config for creating the overlay.
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    _getOverlayConfig(config, anchor) {
        return new OverlayConfig({
            positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor),
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
            direction: this._getDirection(),
        });
    }
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @param {?} position
     * @return {?}
     */
    _subscribeToPositionChanges(position) {
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._positionChangeSubscription = position.positionChanges
            .pipe(takeUntil(this._onDestroy))
            .subscribe(change => {
            // Position changes may occur outside the Angular zone
            this._ngZone.run(() => {
                this._popover._setAlignmentClasses(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
            });
        });
    }
    /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @param {?} strategy
     * @return {?}
     */
    _getScrollStrategyInstance(strategy) {
        switch (strategy) {
            case 'block':
                return this._overlay.scrollStrategies.block();
            case 'reposition':
                return this._overlay.scrollStrategies.reposition();
            case 'close':
                return this._overlay.scrollStrategies.close();
            case 'noop':
            default:
                return this._overlay.scrollStrategies.noop();
        }
    }
    /**
     * Create and return a position strategy based on config provided to the component instance.
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    _getPositionStrategy(horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
        // Attach the overlay at the preferred position
        /** @type {?} */
        const targetPosition = getPosition(horizontalTarget, verticalTarget);
        /** @type {?} */
        const positions = [targetPosition];
        /** @type {?} */
        const strategy = this._overlay.position()
            .flexibleConnectedTo(anchor)
            .withFlexibleDimensions(false)
            .withPush(false)
            .withViewportMargin(0)
            .withLockedPosition(lockAlignment);
        // Unless the alignment is forced, add fallbacks based on the preferred positions
        if (!forceAlignment) {
            /** @type {?} */
            const fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
            positions.push(...fallbacks);
        }
        return strategy.withPositions(positions);
    }
    /**
     * Get fallback positions based around target alignments.
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    _getFallbacks(hTarget, vTarget) {
        // Determine if the target alignments overlap the anchor
        /** @type {?} */
        const horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
        /** @type {?} */
        const verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
        // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
        // cover the anchor
        /** @type {?} */
        const possibleHorizontalAlignments = horizontalOverlapAllowed ?
            ['before', 'start', 'center', 'end', 'after'] :
            ['before', 'after'];
        /** @type {?} */
        const possibleVerticalAlignments = verticalOverlapAllowed ?
            ['above', 'start', 'center', 'end', 'below'] :
            ['above', 'below'];
        // Create fallbacks for each allowed prioritized fallback alignment combo
        /** @type {?} */
        const fallbacks = [];
        prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach(h => {
            prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach(v => {
                fallbacks.push(getPosition(h, v));
            });
        });
        // Remove the first item since it will be the target alignment and isn't considered a fallback
        return fallbacks.slice(1, fallbacks.length);
    }
}
SatPopoverAnchoringService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SatPopoverAnchoringService.ctorParameters = () => [
    { type: Overlay },
    { type: NgZone },
    { type: Directionality, decorators: [{ type: Optional }] }
];
/**
 * Helper function to get a cdk position pair from SatPopover alignments.
 * @param {?} h
 * @param {?} v
 * @return {?}
 */
function getPosition(h, v) {
    const { originX, overlayX } = getHorizontalConnectionPosPair(h);
    const { originY, overlayY } = getVerticalConnectionPosPair(v);
    return new ConnectionPositionPair({ originX, originY }, { overlayX, overlayY });
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
    if (h === 'start') {
        return 'after';
    }
    if (h === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
    if (v === 'top') {
        return 'below';
    }
    if (v === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
    switch (h) {
        case 'before':
            return { originX: 'start', overlayX: 'end' };
        case 'start':
            return { originX: 'start', overlayX: 'start' };
        case 'end':
            return { originX: 'end', overlayX: 'end' };
        case 'after':
            return { originX: 'end', overlayX: 'start' };
        default:
            return { originX: 'center', overlayX: 'center' };
    }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
    switch (v) {
        case 'above':
            return { originY: 'top', overlayY: 'bottom' };
        case 'start':
            return { originY: 'top', overlayY: 'top' };
        case 'end':
            return { originY: 'bottom', overlayY: 'bottom' };
        case 'below':
            return { originY: 'bottom', overlayY: 'top' };
        default:
            return { originY: 'center', overlayY: 'center' };
    }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
    /** @type {?} */
    const targetIndex = options.indexOf(target);
    // Set the first item to be the target
    /** @type {?} */
    const reordered = [target];
    // Make left and right stacks where the highest priority item is last
    /** @type {?} */
    const left = options.slice(0, targetIndex);
    /** @type {?} */
    const right = options.slice(targetIndex + 1, options.length).reverse();
    // Alternate between stacks until one is empty
    while (left.length && right.length) {
        reordered.push(right.pop());
        reordered.push(left.pop());
    }
    // Flush out right side
    while (right.length) {
        reordered.push(right.pop());
    }
    // Flush out left side
    while (left.length) {
        reordered.push(left.pop());
    }
    return reordered;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class SatPopoverAnchor {
    /**
     * @param {?} _elementRef
     * @param {?} _viewContainerRef
     * @param {?} _anchoring
     */
    constructor(_elementRef, _viewContainerRef, _anchoring) {
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._anchoring = _anchoring;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new EventEmitter();
        /**
         * Emits when the directive is destroyed.
         */
        this._onDestroy = new Subject();
    }
    /**
     * Reference to the popover instance.
     * @return {?}
     */
    get attachedPopover() { return this._attachedPopover; }
    /**
     * @param {?} value
     * @return {?}
     */
    set attachedPopover(value) {
        this._validateAttachedPopover(value);
        this._attachedPopover = value;
        // Anchor the popover to the element ref
        this._anchoring.anchor(this.attachedPopover, this._viewContainerRef, this._elementRef);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Re-emit open and close events
        /** @type {?} */
        const opened$ = this._anchoring.popoverOpened
            .pipe(tap(() => this.popoverOpened.emit()));
        /** @type {?} */
        const closed$ = this._anchoring.popoverClosed
            .pipe(tap(value => this.popoverClosed.emit(value)));
        merge(opened$, closed$).pipe(takeUntil(this._onDestroy)).subscribe();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._onDestroy.next();
        this._onDestroy.complete();
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isPopoverOpen() {
        return this._anchoring.isPopoverOpen();
    }
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    togglePopover() {
        this._anchoring.togglePopover();
    }
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    openPopover(options = {}) {
        this._anchoring.openPopover(options);
    }
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    closePopover(value) {
        this._anchoring.closePopover(value);
    }
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    realignPopover() {
        this._anchoring.realignPopoverToAnchor();
    }
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    getElement() {
        return this._elementRef;
    }
    /**
     * Throws an error if the popover instance is not provided.
     * @param {?} popover
     * @return {?}
     */
    _validateAttachedPopover(popover) {
        if (!popover || !(popover instanceof SatPopover)) {
            throw getInvalidPopoverError();
        }
    }
}
SatPopoverAnchor.decorators = [
    { type: Directive, args: [{
                selector: '[satPopoverAnchorFor]',
                exportAs: 'satPopoverAnchor',
                providers: [SatPopoverAnchoringService],
            },] }
];
/** @nocollapse */
SatPopoverAnchor.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: SatPopoverAnchoringService }
];
SatPopoverAnchor.propDecorators = {
    attachedPopover: [{ type: Input, args: ['satPopoverAnchorFor',] }],
    popoverOpened: [{ type: Output }],
    popoverClosed: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class SatPopoverHoverDirective {
    /**
     * @param {?} anchor
     */
    constructor(anchor) {
        this.anchor = anchor;
        this._satPopoverHover = 0;
        /**
         * Emits when the directive is destroyed.
         */
        this._onDestroy = new Subject();
        /**
         * Emits when the user's mouse enters the element.
         */
        this._onMouseEnter = new Subject();
        /**
         * Emits when the user's mouse leaves the element.
         */
        this._onMouseLeave = new Subject();
    }
    /**
     * Amount of time to delay (ms) after hovering starts before
     * the popover opens. Defaults to 0ms.
     * @return {?}
     */
    get satPopoverHover() { return this._satPopoverHover; }
    /**
     * @param {?} val
     * @return {?}
     */
    set satPopoverHover(val) {
        this._satPopoverHover = coerceNumberProperty(val);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Whenever the user hovers this host element, delay the configured
        // amount of time and open the popover. Terminate if the mouse leaves
        // the host element before the delay is complete.
        this._onMouseEnter
            .pipe(switchMap(() => {
            return of(null).pipe(delay(this._satPopoverHover || 0), takeUntil(this._onMouseLeave));
        }), takeUntil(this._onDestroy))
            .subscribe(() => this.anchor.openPopover());
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._onDestroy.next();
        this._onDestroy.complete();
    }
    /**
     * @return {?}
     */
    showPopover() {
        this._onMouseEnter.next();
    }
    /**
     * @return {?}
     */
    closePopover() {
        this._onMouseLeave.next();
        this.anchor.closePopover();
    }
}
SatPopoverHoverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[satPopoverHover]'
            },] }
];
/** @nocollapse */
SatPopoverHoverDirective.ctorParameters = () => [
    { type: SatPopoverAnchor }
];
SatPopoverHoverDirective.propDecorators = {
    satPopoverHover: [{ type: Input }],
    showPopover: [{ type: HostListener, args: ['mouseenter',] }],
    closePopover: [{ type: HostListener, args: ['mouseleave',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class SatPopoverModule {
}
SatPopoverModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    OverlayModule,
                    A11yModule,
                    BidiModule,
                ],
                declarations: [
                    SatPopover,
                    SatPopoverAnchor,
                    SatPopoverHoverDirective,
                ],
                exports: [
                    SatPopover,
                    SatPopoverAnchor,
                    SatPopoverHoverDirective,
                    BidiModule,
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { SatPopoverModule, SatPopoverAnchor, SatPopoverAnchoringService, SatPopover, SatPopoverHoverDirective, transformPopover as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmNzdGF0ZS1zYXQtcG9wb3Zlci5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQG5jc3RhdGUvc2F0LXBvcG92ZXIvcG9wb3Zlci9wb3BvdmVyLmFuaW1hdGlvbnMudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvbm90aWZpY2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvdHlwZXMudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci5lcnJvcnMudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci5jb21wb25lbnQudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZS50cyIsIm5nOi8vQG5jc3RhdGUvc2F0LXBvcG92ZXIvcG9wb3Zlci9wb3BvdmVyLWFuY2hvci5kaXJlY3RpdmUudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci1ob3Zlci5kaXJlY3RpdmUudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgdHJpZ2dlcixcbiAgc3RhdGUsXG4gIHN0eWxlLFxuICBhbmltYXRlLFxuICB0cmFuc2l0aW9uLFxuICBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGFcbn0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1Qb3BvdmVyOiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEgPSB0cmlnZ2VyKCd0cmFuc2Zvcm1Qb3BvdmVyJywgW1xuICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXG4gICAgc3R5bGUoe29wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDAuMyknfSksXG4gICAgYW5pbWF0ZSgne3tvcGVuVHJhbnNpdGlvbn19JyxcbiAgICAgIHN0eWxlKHtvcGFjaXR5OiAxLCB0cmFuc2Zvcm06ICdzY2FsZSgxKSd9KSlcbiAgXSksXG4gIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICBhbmltYXRlKCd7e2Nsb3NlVHJhbnNpdGlvbn19JyxcbiAgICAgIHN0eWxlKHtvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICdzY2FsZSgwLjUpJ30pKVxuICBdKVxuXSk7XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qKiBFbnVtZXJhdGVkIGFjdGlvbnMgZm9yIGEgcG9wb3ZlciB0byBwZXJmb3JtLiAqL1xuZXhwb3J0IGVudW0gTm90aWZpY2F0aW9uQWN0aW9uIHtcbiAgLyoqIFBvcG92ZXIgc2hvdWxkIG9wZW4uICovXG4gIE9QRU4sXG4gIC8qKiBQb3BvdmVyIHNob3VsZCBjbG9zZS4gKi9cbiAgQ0xPU0UsXG4gIC8qKiBQb3BvdmVyIHNob3VsZCB0b2dnbGUgb3BlbiBvciBjbG9zZWQuICovXG4gIFRPR0dMRSxcbiAgLyoqIFBvcG92ZXIgaGFzIG5ldyB0YXJnZXQgcG9zaXRpb25zLiAqL1xuICBSRVBPU0lUSU9OLFxuICAvKiogUG9wb3ZlciBuZWVkcyBuZXcgY29uZmlndXJhdGlvbi4gKi9cbiAgVVBEQVRFX0NPTkZJRyxcbiAgLyoqIFBvcG92ZXIgc2hvdWxkIHJlYWxpZ24gaXRzZWxmIHRvIHRoZSBhbmNob3IuICAqL1xuICBSRUFMSUdOLFxufVxuXG4vKiogRXZlbnQgb2JqZWN0IGZvciBkaXNwYXRjaGluZyB0byBhbmNob3Jpbmcgc2VydmljZS4gKi9cbmV4cG9ydCBjbGFzcyBQb3BvdmVyTm90aWZpY2F0aW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgLyoqIEFjdGlvbiB0byBwZXJmb3JtLiAqL1xuICAgIHB1YmxpYyBhY3Rpb246IE5vdGlmaWNhdGlvbkFjdGlvbixcbiAgICAvKiogT3B0aW9uYWwgcGF5bG9hZC4gKi9cbiAgICBwdWJsaWMgdmFsdWU/OiBhbnlcbiAgKSB7IH1cbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlIHtcblxuICBwcml2YXRlIHN0b3JlID0gbmV3IFN1YmplY3Q8UG9wb3Zlck5vdGlmaWNhdGlvbj4oKTtcblxuICAvKiogRGlzcGF0Y2ggYSBub3RpZmljYXRpb24gdG8gYWxsIHN1YnNjcmliZXJzLiAqL1xuICBkaXNwYXRjaChub3RpZmljYXRpb246IFBvcG92ZXJOb3RpZmljYXRpb24pIHtcbiAgICB0aGlzLnN0b3JlLm5leHQobm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIC8qKiBTdHJlYW0gb2Ygbm90aWZpY2F0aW9uIGV2ZW50cy4gKi9cbiAgZXZlbnRzKCk6IE9ic2VydmFibGU8UG9wb3Zlck5vdGlmaWNhdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqIENvbXBsZXRlIGV2ZW50IHN0cmVhbS4gKi9cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnN0b3JlLmNvbXBsZXRlKCk7XG4gIH1cblxufVxuIiwiZXhwb3J0IHR5cGUgU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5ID0gJ25vb3AnIHwgJ2Jsb2NrJyB8ICdyZXBvc2l0aW9uJyB8ICdjbG9zZSc7XG5leHBvcnQgY29uc3QgVkFMSURfU0NST0xMOiBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3lbXSA9IFtcbiAgJ25vb3AnLFxuICAnYmxvY2snLFxuICAncmVwb3NpdGlvbicsXG4gICdjbG9zZSdcbl07XG5cbmV4cG9ydCB0eXBlIFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24gPSAnYmVmb3JlJyB8ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnIHwgJ2FmdGVyJztcbmV4cG9ydCBjb25zdCBWQUxJRF9IT1JJWl9BTElHTjogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbltdID0gW1xuICAnYmVmb3JlJyxcbiAgJ3N0YXJ0JyxcbiAgJ2NlbnRlcicsXG4gICdlbmQnLFxuICAnYWZ0ZXInXG5dO1xuXG5leHBvcnQgdHlwZSBTYXRQb3BvdmVyVmVydGljYWxBbGlnbiA9ICdhYm92ZScgIHwgJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgfCAnYmVsb3cnO1xuZXhwb3J0IGNvbnN0IFZBTElEX1ZFUlRfQUxJR046IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduW10gPSBbXG4gICdhYm92ZScsXG4gICdzdGFydCcsXG4gICdjZW50ZXInLFxuICAnZW5kJyxcbiAgJ2JlbG93J1xuXTtcblxuZXhwb3J0IGludGVyZmFjZSBTYXRQb3BvdmVyT3Blbk9wdGlvbnMge1xuICAvKipcbiAgICogV2hldGhlciB0aGUgcG9wb3ZlciBzaG91bGQgcmV0dXJuIGZvY3VzIHRvIHRoZSBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudCBhZnRlclxuICAgKiBjbG9zaW5nLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgKi9cbiAgcmVzdG9yZUZvY3VzPzogYm9vbGVhbjtcblxuICAvKiogV2hldGhlciB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgc2hvdWxkIGJlIGZvY3VzZWQgb24gb3Blbi4gRGVmYXVsdHMgdG8gdHJ1ZS4gKi9cbiAgYXV0b0ZvY3VzPzogYm9vbGVhbjtcbn1cbiIsImltcG9ydCB7IFZBTElEX0hPUklaX0FMSUdOLCBWQUxJRF9WRVJUX0FMSUdOLCBWQUxJRF9TQ1JPTEwgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludmFsaWRQb3BvdmVyRXJyb3IoKTogRXJyb3Ige1xuICByZXR1cm4gRXJyb3IoJ1NhdFBvcG92ZXJBbmNob3IgbXVzdCBiZSBwcm92aWRlZCBhbiBTYXRQb3BvdmVyIGNvbXBvbmVudCBpbnN0YW5jZS4nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuYW5jaG9yZWRQb3BvdmVyRXJyb3IoKTogRXJyb3Ige1xuICByZXR1cm4gRXJyb3IoJ1NhdFBvcG92ZXIgaXMgbm90IGFuY2hvcmVkIHRvIGFueSBTYXRQb3BvdmVyQW5jaG9yLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW52YWxpZEhvcml6b250YWxBbGlnbkVycm9yKGFsaWdubWVudCk6IEVycm9yIHtcbiAgcmV0dXJuIEVycm9yKGdlbmVyYXRlR2VuZXJpY0Vycm9yKCdob3Jpem9udGFsQWxpZ24veEFsaWduJywgYWxpZ25tZW50LCBWQUxJRF9IT1JJWl9BTElHTikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW52YWxpZFZlcnRpY2FsQWxpZ25FcnJvcihhbGlnbm1lbnQpOiBFcnJvciB7XG4gIHJldHVybiBFcnJvcihnZW5lcmF0ZUdlbmVyaWNFcnJvcigndmVydGljYWxBbGlnbi95QWxpZ24nLCBhbGlnbm1lbnQsIFZBTElEX1ZFUlRfQUxJR04pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludmFsaWRTY3JvbGxTdHJhdGVneUVycm9yKHN0cmF0ZWd5KTogRXJyb3Ige1xuICByZXR1cm4gRXJyb3IoZ2VuZXJhdGVHZW5lcmljRXJyb3IoJ3Njcm9sbFN0cmF0ZWd5Jywgc3RyYXRlZ3ksIFZBTElEX1NDUk9MTCkpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUdlbmVyaWNFcnJvcihhcGlOYW1lOiBzdHJpbmcsIGludmFsaWQ6IGFueSwgdmFsaWQ6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBJbnZhbGlkICR7YXBpTmFtZX06ICcke2ludmFsaWR9Jy4gVmFsaWQgb3B0aW9ucyBhcmUgYCArXG4gICAgYCR7dmFsaWQubWFwKHYgPT4gYCcke3Z9J2ApLmpvaW4oJywgJyl9LmA7XG59XG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgVmlld0NoaWxkLFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgVGVtcGxhdGVSZWYsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFuaW1hdGlvbkV2ZW50IH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBGb2N1c1RyYXAsIEZvY3VzVHJhcEZhY3RvcnkgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuXG5pbXBvcnQgeyB0cmFuc2Zvcm1Qb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyLmFuaW1hdGlvbnMnO1xuaW1wb3J0IHtcbiAgTm90aWZpY2F0aW9uQWN0aW9uLFxuICBQb3BvdmVyTm90aWZpY2F0aW9uLFxuICBQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZSxcbn0gZnJvbSAnLi9ub3RpZmljYXRpb24uc2VydmljZSc7XG5pbXBvcnQge1xuICBnZXRVbmFuY2hvcmVkUG9wb3ZlckVycm9yLFxuICBnZXRJbnZhbGlkSG9yaXpvbnRhbEFsaWduRXJyb3IsXG4gIGdldEludmFsaWRWZXJ0aWNhbEFsaWduRXJyb3IsXG4gIGdldEludmFsaWRTY3JvbGxTdHJhdGVneUVycm9yLFxufSBmcm9tICcuL3BvcG92ZXIuZXJyb3JzJztcbmltcG9ydCB7XG4gIFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneSxcbiAgU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbixcbiAgU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24sXG4gIFZBTElEX1NDUk9MTCxcbiAgVkFMSURfSE9SSVpfQUxJR04sXG4gIFZBTElEX1ZFUlRfQUxJR04sXG4gIFNhdFBvcG92ZXJPcGVuT3B0aW9ucyxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIFNlZSBodHRwOi8vY3ViaWMtYmV6aWVyLmNvbS8jLjI1LC44LC4yNSwxIGZvciByZWZlcmVuY2UuXG5jb25zdCBERUZBVUxUX1RSQU5TSVRJT04gID0gJzIwMG1zIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnc2F0LXBvcG92ZXInLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBhbmltYXRpb25zOiBbdHJhbnNmb3JtUG9wb3Zlcl0sXG4gIHN0eWxlVXJsczogWycuL3BvcG92ZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgdGVtcGxhdGVVcmw6ICcuL3BvcG92ZXIuY29tcG9uZW50Lmh0bWwnLFxufSlcbmV4cG9ydCBjbGFzcyBTYXRQb3BvdmVyIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIGhvcml6b250YWwgYXhpcy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGhvcml6b250YWxBbGlnbigpIHsgcmV0dXJuIHRoaXMuX2hvcml6b250YWxBbGlnbjsgfVxuICBzZXQgaG9yaXpvbnRhbEFsaWduKHZhbDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbikge1xuICAgIHRoaXMuX3ZhbGlkYXRlSG9yaXpvbnRhbEFsaWduKHZhbCk7XG4gICAgaWYgKHRoaXMuX2hvcml6b250YWxBbGlnbiAhPT0gdmFsKSB7XG4gICAgICB0aGlzLl9ob3Jpem9udGFsQWxpZ24gPSB2YWw7XG4gICAgICB0aGlzLl9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uUkVQT1NJVElPTikpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9ob3Jpem9udGFsQWxpZ246IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24gPSAnY2VudGVyJztcblxuICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB4IGF4aXMuIEFsaWFzIGZvciBgaG9yaXpvbnRhbEFsaWduYC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHhBbGlnbigpIHsgcmV0dXJuIHRoaXMuaG9yaXpvbnRhbEFsaWduOyB9XG4gIHNldCB4QWxpZ24odmFsOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduKSB7IHRoaXMuaG9yaXpvbnRhbEFsaWduID0gdmFsOyB9XG5cbiAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgdmVydGljYWwgYXhpcy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHZlcnRpY2FsQWxpZ24oKSB7IHJldHVybiB0aGlzLl92ZXJ0aWNhbEFsaWduOyB9XG4gIHNldCB2ZXJ0aWNhbEFsaWduKHZhbDogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24pIHtcbiAgICB0aGlzLl92YWxpZGF0ZVZlcnRpY2FsQWxpZ24odmFsKTtcbiAgICBpZiAodGhpcy5fdmVydGljYWxBbGlnbiAhPT0gdmFsKSB7XG4gICAgICB0aGlzLl92ZXJ0aWNhbEFsaWduID0gdmFsO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlJFUE9TSVRJT04pKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfdmVydGljYWxBbGlnbjogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24gPSAnY2VudGVyJztcblxuICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB5IGF4aXMuIEFsaWFzIGZvciBgdmVydGljYWxBbGlnbmAuICovXG4gIEBJbnB1dCgpXG4gIGdldCB5QWxpZ24oKSB7IHJldHVybiB0aGlzLnZlcnRpY2FsQWxpZ247IH1cbiAgc2V0IHlBbGlnbih2YWw6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduKSB7IHRoaXMudmVydGljYWxBbGlnbiA9IHZhbDsgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGFsd2F5cyBvcGVucyB3aXRoIHRoZSBzcGVjaWZpZWQgYWxpZ25tZW50LiAqL1xuICBASW5wdXQoKVxuICBnZXQgZm9yY2VBbGlnbm1lbnQoKSB7IHJldHVybiB0aGlzLl9mb3JjZUFsaWdubWVudDsgfVxuICBzZXQgZm9yY2VBbGlnbm1lbnQodmFsOiBib29sZWFuKSB7XG4gICAgY29uc3QgY29lcmNlZFZhbCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICAgIGlmICh0aGlzLl9mb3JjZUFsaWdubWVudCAhPT0gY29lcmNlZFZhbCkge1xuICAgICAgdGhpcy5fZm9yY2VBbGlnbm1lbnQgPSBjb2VyY2VkVmFsO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlJFUE9TSVRJT04pKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfZm9yY2VBbGlnbm1lbnQgPSBmYWxzZTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcG9wb3ZlcidzIGFsaWdubWVudCBpcyBsb2NrZWQgYWZ0ZXIgb3BlbmluZy4gVGhpcyBwcmV2ZW50cyB0aGUgcG9wb3ZlclxuICAgKiBmcm9tIGNoYW5naW5nIGl0cyBhbGlnbmVtZW50IHdoZW4gc2Nyb2xsaW5nIG9yIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBsb2NrQWxpZ25tZW50KCkgeyByZXR1cm4gdGhpcy5fbG9ja0FsaWdubWVudDsgfVxuICBzZXQgbG9ja0FsaWdubWVudCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBjb2VyY2VkVmFsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gICAgaWYgKHRoaXMuX2xvY2tBbGlnbm1lbnQgIT09IGNvZXJjZWRWYWwpIHtcbiAgICAgIHRoaXMuX2xvY2tBbGlnbm1lbnQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OKSk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2xvY2tBbGlnbm1lbnQgPSBmYWxzZTtcblxuICAvKiogV2hldGhlciB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgc2hvdWxkIGJlIGZvY3VzZWQgb24gb3Blbi4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGF1dG9Gb2N1cygpIHsgcmV0dXJuIHRoaXMuX2F1dG9Gb2N1cyAmJiB0aGlzLl9hdXRvRm9jdXNPdmVycmlkZTsgfVxuICBzZXQgYXV0b0ZvY3VzKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX2F1dG9Gb2N1cyA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICB9XG4gIHByaXZhdGUgX2F1dG9Gb2N1cyA9IHRydWU7XG4gIF9hdXRvRm9jdXNPdmVycmlkZSA9IHRydWU7XG5cbiAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBzaG91bGQgcmV0dXJuIGZvY3VzIHRvIHRoZSBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudCBhZnRlciBjbG9zaW5nLiAqL1xuIEBJbnB1dCgpXG4gIGdldCByZXN0b3JlRm9jdXMoKSB7IHJldHVybiB0aGlzLl9yZXN0b3JlRm9jdXMgJiYgdGhpcy5fcmVzdG9yZUZvY3VzT3ZlcnJpZGU7IH1cbiAgc2V0IHJlc3RvcmVGb2N1cyh2YWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZXN0b3JlRm9jdXMgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgfVxuICBwcml2YXRlIF9yZXN0b3JlRm9jdXMgPSB0cnVlO1xuICBfcmVzdG9yZUZvY3VzT3ZlcnJpZGUgPSB0cnVlO1xuXG4gIC8qKiBIb3cgdGhlIHBvcG92ZXIgc2hvdWxkIGhhbmRsZSBzY3JvbGxpbmcuICovXG4gIEBJbnB1dCgpXG4gIGdldCBzY3JvbGxTdHJhdGVneSgpIHsgcmV0dXJuIHRoaXMuX3Njcm9sbFN0cmF0ZWd5OyB9XG4gIHNldCBzY3JvbGxTdHJhdGVneSh2YWw6IFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneSkge1xuICAgIHRoaXMuX3ZhbGlkYXRlU2Nyb2xsU3RyYXRlZ3kodmFsKTtcbiAgICBpZiAodGhpcy5fc2Nyb2xsU3RyYXRlZ3kgIT09IHZhbCkge1xuICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kgPSB2YWw7XG4gICAgICB0aGlzLl9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uVVBEQVRFX0NPTkZJRykpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9zY3JvbGxTdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5ID0gJ3JlcG9zaXRpb24nO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBoYXZlIGEgYmFja2Ryb3AgKGluY2x1ZGVzIGNsb3Npbmcgb24gY2xpY2spLiAqL1xuICBASW5wdXQoKVxuICBnZXQgaGFzQmFja2Ryb3AoKSB7IHJldHVybiB0aGlzLl9oYXNCYWNrZHJvcDsgfVxuICBzZXQgaGFzQmFja2Ryb3AodmFsOiBib29sZWFuKSB7XG4gICAgdGhpcy5faGFzQmFja2Ryb3AgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgfVxuICBwcml2YXRlIF9oYXNCYWNrZHJvcCA9IGZhbHNlO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBjbG9zZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFja2Ryb3Agb3IgcHJlc3NlcyBFU0MuICovXG4gIEBJbnB1dCgpXG4gIGdldCBpbnRlcmFjdGl2ZUNsb3NlKCkgeyByZXR1cm4gdGhpcy5faW50ZXJhY3RpdmVDbG9zZTsgfVxuICBzZXQgaW50ZXJhY3RpdmVDbG9zZSh2YWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9pbnRlcmFjdGl2ZUNsb3NlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gIH1cbiAgcHJpdmF0ZSBfaW50ZXJhY3RpdmVDbG9zZSA9IHRydWU7XG5cbiAgLyoqIEN1c3RvbSB0cmFuc2l0aW9uIHRvIHVzZSB3aGlsZSBvcGVuaW5nLiAqL1xuICBASW5wdXQoKVxuICBnZXQgb3BlblRyYW5zaXRpb24oKSB7IHJldHVybiB0aGlzLl9vcGVuVHJhbnNpdGlvbjsgfVxuICBzZXQgb3BlblRyYW5zaXRpb24odmFsOiBzdHJpbmcpIHtcbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLl9vcGVuVHJhbnNpdGlvbiA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfb3BlblRyYW5zaXRpb24gPSBERUZBVUxUX1RSQU5TSVRJT047XG5cbiAgLyoqIEN1c3RvbSB0cmFuc2l0aW9uIHRvIHVzZSB3aGlsZSBjbG9zaW5nLiAqL1xuICBASW5wdXQoKVxuICBnZXQgY2xvc2VUcmFuc2l0aW9uKCkgeyByZXR1cm4gdGhpcy5fY2xvc2VUcmFuc2l0aW9uOyB9XG4gIHNldCBjbG9zZVRyYW5zaXRpb24odmFsOiBzdHJpbmcpIHtcbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLl9jbG9zZVRyYW5zaXRpb24gPSB2YWw7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2Nsb3NlVHJhbnNpdGlvbiA9IERFRkFVTFRfVFJBTlNJVElPTjtcblxuICAvKiogT3B0aW9uYWwgYmFja2Ryb3AgY2xhc3MuICovXG4gIEBJbnB1dCgpIGJhY2tkcm9wQ2xhc3MgPSAnJztcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIEBPdXRwdXQoKSBvcGVuZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkLiAqL1xuICBAT3V0cHV0KCkgY2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIG9wZW5pbmcuICovXG4gIEBPdXRwdXQoKSBhZnRlck9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIGNsb3NpbmcuICovXG4gIEBPdXRwdXQoKSBhZnRlckNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLiAqL1xuICBAT3V0cHV0KCkgYmFja2Ryb3BDbGlja2VkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIGEga2V5ZG93biBldmVudCBpcyB0YXJnZXRlZCB0byB0aGlzIHBvcG92ZXIncyBvdmVybGF5LiAqL1xuICBAT3V0cHV0KCkgb3ZlcmxheUtleWRvd24gPSBuZXcgRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+KCk7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0ZW1wbGF0ZSBzbyBpdCBjYW4gYmUgcGxhY2VkIHdpdGhpbiBhIHBvcnRhbC4gKi9cbiAgQFZpZXdDaGlsZChUZW1wbGF0ZVJlZikgX3RlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIC8qKiBDbGFzc2VzIHRvIGJlIGFkZGVkIHRvIHRoZSBwb3BvdmVyIGZvciBzZXR0aW5nIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBvcmlnaW4uICovXG4gIF9jbGFzc0xpc3Q6IGFueSA9IHt9O1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBfb3BlbiA9IGZhbHNlO1xuXG4gIC8qKiBJbnN0YW5jZSBvZiBub3RpZmljYXRpb24gc2VydmljZS4gV2lsbCBiZSB1bmRlZmluZWQgdW50aWwgYXR0YWNoZWQgdG8gYW4gYW5jaG9yLiAqL1xuICBfbm90aWZpY2F0aW9uczogUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2U7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0byBidWlsZCBhIGZvY3VzIHRyYXAgYXJvdW5kLiAqL1xuICBAVmlld0NoaWxkKCdmb2N1c1RyYXBFbGVtZW50JylcbiAgcHJpdmF0ZSBfZm9jdXNUcmFwRWxlbWVudDogRWxlbWVudFJlZjtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIG9wZW5pbmcuICovXG4gIHByaXZhdGUgX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudDogSFRNTEVsZW1lbnQ7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byBhIGZvY3VzIHRyYXAgYXJvdW5kIHRoZSBwb3BvdmVyLiAqL1xuICBwcml2YXRlIF9mb2N1c1RyYXA6IEZvY3VzVHJhcDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9mb2N1c1RyYXBGYWN0b3J5OiBGb2N1c1RyYXBGYWN0b3J5LFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnlcbiAgKSB7IH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9zZXRBbGlnbm1lbnRDbGFzc2VzKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fbm90aWZpY2F0aW9ucykge1xuICAgICAgdGhpcy5fbm90aWZpY2F0aW9ucy5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIE9wZW4gdGhpcyBwb3BvdmVyLiAqL1xuICBvcGVuKG9wdGlvbnM6IFNhdFBvcG92ZXJPcGVuT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLk9QRU4sIG9wdGlvbnMpO1xuICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvKiogQ2xvc2UgdGhpcyBwb3BvdmVyLiAqL1xuICBjbG9zZSh2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5DTE9TRSwgdmFsdWUpO1xuICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvKiogVG9nZ2xlIHRoaXMgcG9wb3ZlciBvcGVuIG9yIGNsb3NlZC4gKi9cbiAgdG9nZ2xlKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5UT0dHTEUpO1xuICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICByZWFsaWduKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5SRUFMSUdOKTtcbiAgICB0aGlzLl9kaXNwYXRjaEFjdGlvbk5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICB9XG5cbiAgLyoqIEdldHMgd2hldGhlciB0aGUgcG9wb3ZlciBpcyBwcmVzZW50bHkgb3Blbi4gKi9cbiAgaXNPcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICB9XG5cbiAgLyoqIEdldHMgYW4gYW5pbWF0aW9uIGNvbmZpZyB3aXRoIGN1c3RvbWl6ZWQgKG9yIGRlZmF1bHQpIHRyYW5zaXRpb24gdmFsdWVzLiAqL1xuICBfZ2V0QW5pbWF0aW9uKCk6IHsgdmFsdWU6IGFueSwgcGFyYW1zOiBhbnkgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiAndmlzaWJsZScsXG4gICAgICBwYXJhbXM6IHsgb3BlblRyYW5zaXRpb246IHRoaXMub3BlblRyYW5zaXRpb24sIGNsb3NlVHJhbnNpdGlvbjogdGhpcy5jbG9zZVRyYW5zaXRpb24gfVxuICAgIH07XG4gIH1cblxuICAvKiogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIHBvcG92ZXIgaXMgZmluaXNoZWQgYW5pbWF0aW5nIGluIG9yIG91dC4gKi9cbiAgX29uQW5pbWF0aW9uRG9uZShldmVudDogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB0aGlzLl90cmFwRm9jdXMoKTtcbiAgICAgIHRoaXMuYWZ0ZXJPcGVuLmVtaXQoKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICd2b2lkJykge1xuICAgICAgdGhpcy5fcmVzdG9yZUZvY3VzQW5kRGVzdHJveVRyYXAoKTtcbiAgICAgIHRoaXMuYWZ0ZXJDbG9zZS5lbWl0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEFwcGx5IGFsaWdubWVudCBjbGFzc2VzIGJhc2VkIG9uIGFsaWdubWVudCBpbnB1dHMuICovXG4gIF9zZXRBbGlnbm1lbnRDbGFzc2VzKGhvcml6QWxpZ24gPSB0aGlzLmhvcml6b250YWxBbGlnbiwgdmVydEFsaWduID0gdGhpcy52ZXJ0aWNhbEFsaWduKSB7XG4gICAgdGhpcy5fY2xhc3NMaXN0WydzYXQtcG9wb3Zlci1iZWZvcmUnXSA9IGhvcml6QWxpZ24gPT09ICdiZWZvcmUnIHx8IGhvcml6QWxpZ24gPT09ICdlbmQnO1xuICAgIHRoaXMuX2NsYXNzTGlzdFsnc2F0LXBvcG92ZXItYWZ0ZXInXSAgPSBob3JpekFsaWduID09PSAnYWZ0ZXInIHx8IGhvcml6QWxpZ24gPT09ICdzdGFydCc7XG5cbiAgICB0aGlzLl9jbGFzc0xpc3RbJ3NhdC1wb3BvdmVyLWFib3ZlJ10gPSB2ZXJ0QWxpZ24gPT09ICdhYm92ZScgfHwgdmVydEFsaWduID09PSAnZW5kJztcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ3NhdC1wb3BvdmVyLWJlbG93J10gPSB2ZXJ0QWxpZ24gPT09ICdiZWxvdycgfHwgdmVydEFsaWduID09PSAnc3RhcnQnO1xuXG4gICAgdGhpcy5fY2xhc3NMaXN0WydzYXQtcG9wb3Zlci1jZW50ZXInXSA9IGhvcml6QWxpZ24gPT09ICdjZW50ZXInIHx8IHZlcnRBbGlnbiA9PT0gJ2NlbnRlcic7XG4gIH1cblxuICAvKiogTW92ZSB0aGUgZm9jdXMgaW5zaWRlIHRoZSBmb2N1cyB0cmFwIGFuZCByZW1lbWJlciB3aGVyZSB0byByZXR1cm4gbGF0ZXIuICovXG4gIHByaXZhdGUgX3RyYXBGb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLl9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk7XG5cbiAgICAvLyBUaGVyZSB3b24ndCBiZSBhIGZvY3VzIHRyYXAgZWxlbWVudCBpZiB0aGUgY2xvc2UgYW5pbWF0aW9uIHN0YXJ0cyBiZWZvcmUgb3BlbiBmaW5pc2hlc1xuICAgIGlmICghdGhpcy5fZm9jdXNUcmFwRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKHRoaXMuX2ZvY3VzVHJhcEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXV0b0ZvY3VzKSB7XG4gICAgICB0aGlzLl9mb2N1c1RyYXAuZm9jdXNJbml0aWFsRWxlbWVudFdoZW5SZWFkeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZXN0b3JlIGZvY3VzIHRvIHRoZSBlbGVtZW50IGZvY3VzZWQgYmVmb3JlIHRoZSBwb3BvdmVyIG9wZW5lZC4gQWxzbyBkZXN0cm95IHRyYXAuICovXG4gIHByaXZhdGUgX3Jlc3RvcmVGb2N1c0FuZERlc3Ryb3lUcmFwKCk6IHZvaWQge1xuICAgIGNvbnN0IHRvRm9jdXMgPSB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQ7XG5cbiAgICAvLyBNdXN0IGNoZWNrIGFjdGl2ZSBlbGVtZW50IGlzIGZvY3VzYWJsZSBmb3IgSUUgc2FrZVxuICAgIGlmICh0b0ZvY3VzICYmICdmb2N1cycgaW4gdG9Gb2N1cyAmJiB0aGlzLnJlc3RvcmVGb2N1cykge1xuICAgICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl9mb2N1c1RyYXApIHtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcC5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9mb2N1c1RyYXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgZm9jdXNlZCBiZWZvcmUgdGhlIHBvcG92ZXIgd2FzIG9wZW5lZC4gKi9cbiAgcHJpdmF0ZSBfc2F2ZVByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgIHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgLyoqIERpc3BhdGNoIGEgbm90aWZpY2F0aW9uIHRvIHRoZSBub3RpZmljYXRpb24gc2VydmljZSwgaWYgcG9zc2libGUuICovXG4gIHByaXZhdGUgX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogUG9wb3Zlck5vdGlmaWNhdGlvbikge1xuICAgIGlmICh0aGlzLl9ub3RpZmljYXRpb25zKSB7XG4gICAgICB0aGlzLl9ub3RpZmljYXRpb25zLmRpc3BhdGNoKG5vdGlmaWNhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqIERpc3BhdGNoIGEgbm90aWZpY2F0aW9uIHRvIHRoZSBub3RpZmljYXRpb24gc2VydmljZSBhbmQgdGhyb3cgaWYgdW5hYmxlIHRvLiAqL1xuICBwcml2YXRlIF9kaXNwYXRjaEFjdGlvbk5vdGlmaWNhdGlvbihub3RpZmljYXRpb246IFBvcG92ZXJOb3RpZmljYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuX25vdGlmaWNhdGlvbnMpIHtcbiAgICAgIHRocm93IGdldFVuYW5jaG9yZWRQb3BvdmVyRXJyb3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ub3RpZmljYXRpb25zLmRpc3BhdGNoKG5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBhbGlnbm1lbnQgaXMgbm90IGEgdmFsaWQgaG9yaXpvbnRhbEFsaWduLiAqL1xuICBwcml2YXRlIF92YWxpZGF0ZUhvcml6b250YWxBbGlnbihwb3M6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24pOiB2b2lkIHtcbiAgICBpZiAoVkFMSURfSE9SSVpfQUxJR04uaW5kZXhPZihwb3MpID09PSAtMSkge1xuICAgICAgdGhyb3cgZ2V0SW52YWxpZEhvcml6b250YWxBbGlnbkVycm9yKHBvcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYWxpZ25tZW50IGlzIG5vdCBhIHZhbGlkIHZlcnRpY2FsQWxpZ24uICovXG4gIHByaXZhdGUgX3ZhbGlkYXRlVmVydGljYWxBbGlnbihwb3M6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduKTogdm9pZCB7XG4gICAgaWYgKFZBTElEX1ZFUlRfQUxJR04uaW5kZXhPZihwb3MpID09PSAtMSkge1xuICAgICAgdGhyb3cgZ2V0SW52YWxpZFZlcnRpY2FsQWxpZ25FcnJvcihwb3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNjcm9sbCBzdHJhdGVneSBpcyBub3QgYSB2YWxpZCBzdHJhdGVneS4gKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdGVTY3JvbGxTdHJhdGVneShzdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5KTogdm9pZCB7XG4gICAgaWYgKFZBTElEX1NDUk9MTC5pbmRleE9mKHN0cmF0ZWd5KSA9PT0gLTEpIHtcbiAgICAgIHRocm93IGdldEludmFsaWRTY3JvbGxTdHJhdGVneUVycm9yKHN0cmF0ZWd5KTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEVsZW1lbnRSZWYsXG4gIEluamVjdGFibGUsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIsXG4gIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSxcbiAgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsXG4gIE92ZXJsYXksXG4gIE92ZXJsYXlDb25maWcsXG4gIE92ZXJsYXlSZWYsXG4gIFNjcm9sbFN0cmF0ZWd5LFxuICBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MsXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5LCBEaXJlY3Rpb259IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwsIHRha2UsIGZpbHRlciwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBTYXRQb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbiAgU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5LFxuICBTYXRQb3BvdmVyT3Blbk9wdGlvbnMsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5pbXBvcnQgeyBQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZSwgTm90aWZpY2F0aW9uQWN0aW9uIH0gZnJvbSAnLi9ub3RpZmljYXRpb24uc2VydmljZSc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBwcm92aWRlZCBieSB0aGUgcG9wb3ZlciBmb3IgdGhlIGFuY2hvcmluZyBzZXJ2aWNlXG4gKiB0byBidWlsZCB0aGUgY29ycmVjdCBvdmVybGF5IGNvbmZpZy5cbiAqL1xuaW50ZXJmYWNlIFBvcG92ZXJDb25maWcge1xuICBob3Jpem9udGFsQWxpZ246IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ247XG4gIHZlcnRpY2FsQWxpZ246IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduO1xuICBoYXNCYWNrZHJvcDogYm9vbGVhbjtcbiAgYmFja2Ryb3BDbGFzczogc3RyaW5nO1xuICBzY3JvbGxTdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5O1xuICBmb3JjZUFsaWdubWVudDogYm9vbGVhbjtcbiAgbG9ja0FsaWdubWVudDogYm9vbGVhbjtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIHBvcG92ZXJPcGVuZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgcG9wb3ZlckNsb3NlZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSBjb250YWluaW5nIHRoZSBwb3BvdmVyIGNvbXBvbmVudC4gKi9cbiAgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHBvcG92ZXIuICovXG4gIHByaXZhdGUgX3BvcG92ZXI6IFNhdFBvcG92ZXI7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdmlldyBjb250YWluZXIgZm9yIHRoZSBwb3BvdmVyIHRlbXBsYXRlLiAqL1xuICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGFuY2hvciBlbGVtZW50LiAqL1xuICBwcml2YXRlIF9hbmNob3I6IEVsZW1lbnRSZWY7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byBhIHRlbXBsYXRlIHBvcnRhbCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGF0dGFjaGVkLiAqL1xuICBwcml2YXRlIF9wb3J0YWw6IFRlbXBsYXRlUG9ydGFsPGFueT47XG5cbiAgLyoqIENvbW11bmljYXRpb25zIGNoYW5uZWwgd2l0aCB0aGUgcG9wb3Zlci4gKi9cbiAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uczogUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2U7XG5cbiAgLyoqIFNpbmdsZSBzdWJzY3JpcHRpb24gdG8gbm90aWZpY2F0aW9ucyBzZXJ2aWNlIGV2ZW50cy4gKi9cbiAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKiBTaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHBvc2l0aW9uIGNoYW5nZXMuICovXG4gIHByaXZhdGUgX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIHByaXZhdGUgX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHNlcnZpY2UgaXMgZGVzdHJveWVkLiAqL1xuICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyOiBEaXJlY3Rpb25hbGl0eVxuICApIHsgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIC8vIERlc3Ryb3kgcG9wb3ZlciBiZWZvcmUgdGVybWluYXRpbmcgc3Vic2NyaXB0aW9ucyBzbyB0aGF0IGFueSByZXN1bHRpbmdcbiAgICAvLyBkZXRhY2htZW50cyB1cGRhdGUgJ2Nsb3NlZCBzdGF0ZSdcbiAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgLy8gVGVybWluYXRlIHN1YnNjcmlwdGlvbnNcbiAgICBpZiAodGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG5cbiAgICB0aGlzLnBvcG92ZXJPcGVuZWQuY29tcGxldGUoKTtcbiAgICB0aGlzLnBvcG92ZXJDbG9zZWQuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBBbmNob3IgYSBwb3BvdmVyIGluc3RhbmNlIHRvIGEgdmlldyBhbmQgY29ubmVjdGlvbiBlbGVtZW50LiAqL1xuICBhbmNob3IocG9wb3ZlcjogU2F0UG9wb3Zlciwgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgYW5jaG9yOiBFbGVtZW50UmVmKTogdm9pZCB7XG4gICAgLy8gRGVzdHJveSBhbnkgcHJldmlvdXMgcG9wb3ZlcnNcbiAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgLy8gQXNzaWduIGxvY2FsIHJlZnNcbiAgICB0aGlzLl9wb3BvdmVyID0gcG9wb3ZlcjtcbiAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICB0aGlzLl9hbmNob3IgPSBhbmNob3I7XG5cbiAgICAvLyBQcm92aWRlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlIGFzIGEgY29tbXVuaWNhdGlvbiBjaGFubmVsIGJldHdlZW4gcG9wb3ZlciBhbmQgYW5jaG9yLlxuICAgIC8vIFRoZW4gc3Vic2NyaWJlIHRvIG5vdGlmaWNhdGlvbnMgdG8gdGFrZSBhcHByb3ByaWF0ZSBhY3Rpb25zLlxuICAgIHRoaXMuX3BvcG92ZXIuX25vdGlmaWNhdGlvbnMgPSB0aGlzLl9ub3RpZmljYXRpb25zID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlKCk7XG4gICAgdGhpcy5fc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zKCk7XG4gIH1cblxuICAvKiogR2V0cyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBpc1BvcG92ZXJPcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9wb3BvdmVyT3BlbjtcbiAgfVxuXG4gIC8qKiBUb2dnbGVzIHRoZSBwb3BvdmVyIGJldHdlZW4gdGhlIG9wZW4gYW5kIGNsb3NlZCBzdGF0ZXMuICovXG4gIHRvZ2dsZVBvcG92ZXIoKTogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuID8gdGhpcy5jbG9zZVBvcG92ZXIoKSA6IHRoaXMub3BlblBvcG92ZXIoKTtcbiAgfVxuXG4gIC8qKiBPcGVucyB0aGUgcG9wb3Zlci4gKi9cbiAgb3BlblBvcG92ZXIob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zID0ge30pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICB0aGlzLl9hcHBseU9wZW5PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9CYWNrZHJvcCgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9Fc2NhcGUoKTtcbiAgICAgIHRoaXMuX3N1YnNjcmliZVRvRGV0YWNobWVudHMoKTtcbiAgICAgIHRoaXMuX3NhdmVPcGVuZWRTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDbG9zZXMgdGhlIHBvcG92ZXIuICovXG4gIGNsb3NlUG9wb3Zlcih2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9zYXZlQ2xvc2VkU3RhdGUodmFsdWUpO1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICB9XG4gIH1cblxuICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICByZWFsaWduUG9wb3ZlclRvQW5jaG9yKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLl9vdmVybGF5UmVmLmdldENvbmZpZygpO1xuICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb25maWcucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgICBzdHJhdGVneS5yZWFwcGx5TGFzdFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuICovXG4gIGdldEFuY2hvckVsZW1lbnQoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgfVxuXG4gIC8qKiBBcHBseSBiZWhhdmlvciBwcm9wZXJ0aWVzIG9uIHRoZSBwb3BvdmVyIGJhc2VkIG9uIHRoZSBvcGVuIG9wdGlvbnMuICovXG4gIHByaXZhdGUgX2FwcGx5T3Blbk9wdGlvbnMob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zKTogdm9pZCB7XG4gICAgLy8gT25seSBvdmVycmlkZSByZXN0b3JlRm9jdXMgYXMgYGZhbHNlYCBpZiB0aGUgb3B0aW9uIGlzIGV4cGxpY2l0bHkgYGZhbHNlYFxuICAgIGNvbnN0IHJlc3RvcmVGb2N1cyA9IG9wdGlvbnMucmVzdG9yZUZvY3VzICE9PSBmYWxzZTtcbiAgICB0aGlzLl9wb3BvdmVyLl9yZXN0b3JlRm9jdXNPdmVycmlkZSA9IHJlc3RvcmVGb2N1cztcblxuICAgIC8vIE9ubHkgb3ZlcnJpZGUgYXV0b0ZvY3VzIGFzIGBmYWxzZWAgaWYgdGhlIG9wdGlvbiBpcyBleHBsaWNpdGx5IGBmYWxzZWBcbiAgICBjb25zdCBhdXRvRm9jdXMgPSBvcHRpb25zLmF1dG9Gb2N1cyAhPT0gZmFsc2U7XG4gICAgdGhpcy5fcG9wb3Zlci5fYXV0b0ZvY3VzT3ZlcnJpZGUgPSBhdXRvRm9jdXM7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuIG92ZXJsYXkgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHBvcnRhbC4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcbiAgICAvLyBDcmVhdGUgb3ZlcmxheSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX3BvcG92ZXIuX3RlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcblxuICAgICAgY29uc3QgcG9wb3ZlckNvbmZpZyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbEFsaWduOiB0aGlzLl9wb3BvdmVyLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5fcG9wb3Zlci52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBoYXNCYWNrZHJvcDogdGhpcy5fcG9wb3Zlci5oYXNCYWNrZHJvcCxcbiAgICAgICAgYmFja2Ryb3BDbGFzczogdGhpcy5fcG9wb3Zlci5iYWNrZHJvcENsYXNzLFxuICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fcG9wb3Zlci5zY3JvbGxTdHJhdGVneSxcbiAgICAgICAgZm9yY2VBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgIGxvY2tBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIubG9ja0FsaWdubWVudCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKHBvcG92ZXJDb25maWcsIHRoaXMuX2FuY2hvcik7XG5cbiAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKFxuICAgICAgICBvdmVybGF5Q29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgICApO1xuXG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheUNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgb3BlbiB0aGUgcG9wb3ZlclxuICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gIH1cblxuXG4gIC8qKiBSZW1vdmVzIHRoZSBwb3BvdmVyIGZyb20gdGhlIERPTS4gRG9lcyBOT1QgdXBkYXRlIG9wZW4gc3RhdGUuICovXG4gIHByaXZhdGUgX2Rlc3Ryb3lQb3BvdmVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcG9wb3ZlciBpbW1lZGlhdGVseSBpZiBpdCBpcyBjbG9zZWQsIG9yIHdhaXRzIHVudGlsIGl0XG4gICAqIGhhcyBiZWVuIGNsb3NlZCB0byBkZXN0cm95IGl0LlxuICAgKi9cbiAgcHJpdmF0ZSBfZGVzdHJveVBvcG92ZXJPbmNlQ2xvc2VkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzUG9wb3Zlck9wZW4oKSAmJiB0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaG1lbnRzKCkucGlwZShcbiAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2Rlc3Ryb3lQb3BvdmVyKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGFwcHJvcHJpYXRlIGFuY2hvciBtZXRob2Qgd2hlbiBhbiBldmVudCBpcyBkaXNwYXRjaGVkIHRocm91Z2hcbiAgICogdGhlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlLlxuICAgKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbiA9IHRoaXMuX25vdGlmaWNhdGlvbnMuZXZlbnRzKClcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmFjdGlvbikge1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLk9QRU46XG4gICAgICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLkNMT1NFOlxuICAgICAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoZXZlbnQudmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBOb3RpZmljYXRpb25BY3Rpb24uVE9HR0xFOlxuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3BvdmVyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OOlxuICAgICAgICAgICAgLy8gVE9ETzogV2hlbiB0aGUgb3ZlcmxheSdzIHBvc2l0aW9uIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkLCBkbyBub3QgZGVzdHJveVxuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLlVQREFURV9DT05GSUc6XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95UG9wb3Zlck9uY2VDbG9zZWQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLlJFQUxJR046XG4gICAgICAgICAgICB0aGlzLnJlYWxpZ25Qb3BvdmVyVG9BbmNob3IoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBDbG9zZSBwb3BvdmVyIHdoZW4gYmFja2Ryb3AgaXMgY2xpY2tlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcCgpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuYmFja2Ryb3BDbGljaygpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKCgpID0+IHRoaXMuX3BvcG92ZXIuYmFja2Ryb3BDbGlja2VkLmVtaXQoKSksXG4gICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl9wb3BvdmVyLmludGVyYWN0aXZlQ2xvc2UpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyQ2xvc2VkKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2VQb3BvdmVyKCkpO1xuICB9XG5cbiAgLyoqIENsb3NlIHBvcG92ZXIgd2hlbiBlc2NhcGUga2V5ZG93biBldmVudCBvY2N1cnMuICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvRXNjYXBlKCk6IHZvaWQge1xuICAgIHRoaXMuX292ZXJsYXlSZWZcbiAgICAgIC5rZXlkb3duRXZlbnRzKClcbiAgICAgIC5waXBlKFxuICAgICAgICB0YXAoZXZlbnQgPT4gdGhpcy5fcG9wb3Zlci5vdmVybGF5S2V5ZG93bi5lbWl0KGV2ZW50KSksXG4gICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudC5rZXlDb2RlID09PSBFU0NBUEUpLFxuICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fcG9wb3Zlci5pbnRlcmFjdGl2ZUNsb3NlKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMucG9wb3ZlckNsb3NlZCksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlUG9wb3ZlcigpKTtcbiAgfVxuXG4gIC8qKiBTZXQgc3RhdGUgYmFjayB0byBjbG9zZWQgd2hlbiBkZXRhY2hlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9EZXRhY2htZW50cygpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuZGV0YWNobWVudHMoKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3NhdmVDbG9zZWRTdGF0ZSgpKTtcbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVPcGVuZWRTdGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICB0aGlzLl9wb3BvdmVyLl9vcGVuID0gdGhpcy5fcG9wb3Zlck9wZW4gPSB0cnVlO1xuXG4gICAgICB0aGlzLnBvcG92ZXJPcGVuZWQubmV4dCgpO1xuICAgICAgdGhpcy5fcG9wb3Zlci5vcGVuZWQuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBjbG9zZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVDbG9zZWRTdGF0ZSh2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wb3BvdmVyT3Blbikge1xuICAgICAgdGhpcy5fcG9wb3Zlci5fb3BlbiA9IHRoaXMuX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgICAgIHRoaXMucG9wb3ZlckNsb3NlZC5uZXh0KHZhbHVlKTtcbiAgICAgIHRoaXMuX3BvcG92ZXIuY2xvc2VkLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gIHByaXZhdGUgX2dldERpcmVjdGlvbigpOiBEaXJlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuZCByZXR1cm4gYSBjb25maWcgZm9yIGNyZWF0aW5nIHRoZSBvdmVybGF5LiAqL1xuICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnKGNvbmZpZzogUG9wb3ZlckNvbmZpZywgYW5jaG9yOiBFbGVtZW50UmVmKTogT3ZlcmxheUNvbmZpZyB7XG4gICAgcmV0dXJuIG5ldyBPdmVybGF5Q29uZmlnKHtcbiAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMuX2dldFBvc2l0aW9uU3RyYXRlZ3koXG4gICAgICAgIGNvbmZpZy5ob3Jpem9udGFsQWxpZ24sXG4gICAgICAgIGNvbmZpZy52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBjb25maWcuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgIGNvbmZpZy5sb2NrQWxpZ25tZW50LFxuICAgICAgICBhbmNob3IsXG4gICAgICApLFxuICAgICAgaGFzQmFja2Ryb3A6IGNvbmZpZy5oYXNCYWNrZHJvcCxcbiAgICAgIGJhY2tkcm9wQ2xhc3M6IGNvbmZpZy5iYWNrZHJvcENsYXNzIHx8ICdjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCcsXG4gICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZShjb25maWcuc2Nyb2xsU3RyYXRlZ3kpLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLl9nZXREaXJlY3Rpb24oKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldCB0aGUgY29ycmVjdCBhbGlnbm1lbnQgY2xhc3NlcyxcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYW5pbWF0aW9uIG9yaWdpbiBpcyBjb3JyZWN0LCBldmVuIHdpdGggYSBmYWxsYmFjayBwb3NpdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKHBvc2l0aW9uOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSBwb3NpdGlvbi5wb3NpdGlvbkNoYW5nZXNcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgICAvLyBQb3NpdGlvbiBjaGFuZ2VzIG1heSBvY2N1ciBvdXRzaWRlIHRoZSBBbmd1bGFyIHpvbmVcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcG9wb3Zlci5fc2V0QWxpZ25tZW50Q2xhc3NlcyhcbiAgICAgICAgICAgIGdldEhvcml6b250YWxQb3BvdmVyQWxpZ25tZW50KGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WCksXG4gICAgICAgICAgICBnZXRWZXJ0aWNhbFBvcG92ZXJBbGlnbm1lbnQoY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm92ZXJsYXlZKSxcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqIE1hcCBhIHNjcm9sbCBzdHJhdGVneSBzdHJpbmcgdHlwZSB0byBhbiBpbnN0YW5jZSBvZiBhIHNjcm9sbCBzdHJhdGVneS4gKi9cbiAgcHJpdmF0ZSBfZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZShzdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5KTogU2Nyb2xsU3RyYXRlZ3kge1xuICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5ibG9jaygpO1xuICAgICAgY2FzZSAncmVwb3NpdGlvbic6XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xuICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmNsb3NlKCk7XG4gICAgICBjYXNlICdub29wJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMubm9vcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDcmVhdGUgYW5kIHJldHVybiBhIHBvc2l0aW9uIHN0cmF0ZWd5IGJhc2VkIG9uIGNvbmZpZyBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLiAqL1xuICBwcml2YXRlIF9nZXRQb3NpdGlvblN0cmF0ZWd5KFxuICAgIGhvcml6b250YWxUYXJnZXQ6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gICAgdmVydGljYWxUYXJnZXQ6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduLFxuICAgIGZvcmNlQWxpZ25tZW50OiBib29sZWFuLFxuICAgIGxvY2tBbGlnbm1lbnQ6IGJvb2xlYW4sXG4gICAgYW5jaG9yOiBFbGVtZW50UmVmLFxuICApOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIC8vIEF0dGFjaCB0aGUgb3ZlcmxheSBhdCB0aGUgcHJlZmVycmVkIHBvc2l0aW9uXG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihob3Jpem9udGFsVGFyZ2V0LCB2ZXJ0aWNhbFRhcmdldCk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW3RhcmdldFBvc2l0aW9uXTtcblxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyhhbmNob3IpXG4gICAgICAud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSlcbiAgICAgIC53aXRoUHVzaChmYWxzZSlcbiAgICAgIC53aXRoVmlld3BvcnRNYXJnaW4oMClcbiAgICAgIC53aXRoTG9ja2VkUG9zaXRpb24obG9ja0FsaWdubWVudCk7XG5cbiAgICAvLyBVbmxlc3MgdGhlIGFsaWdubWVudCBpcyBmb3JjZWQsIGFkZCBmYWxsYmFja3MgYmFzZWQgb24gdGhlIHByZWZlcnJlZCBwb3NpdGlvbnNcbiAgICBpZiAoIWZvcmNlQWxpZ25tZW50KSB7XG4gICAgICBjb25zdCBmYWxsYmFja3MgPSB0aGlzLl9nZXRGYWxsYmFja3MoaG9yaXpvbnRhbFRhcmdldCwgdmVydGljYWxUYXJnZXQpO1xuICAgICAgcG9zaXRpb25zLnB1c2goLi4uZmFsbGJhY2tzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyYXRlZ3kud2l0aFBvc2l0aW9ucyhwb3NpdGlvbnMpO1xuICB9XG5cbiAgLyoqIEdldCBmYWxsYmFjayBwb3NpdGlvbnMgYmFzZWQgYXJvdW5kIHRhcmdldCBhbGlnbm1lbnRzLiAqL1xuICBwcml2YXRlIF9nZXRGYWxsYmFja3MoXG4gICAgaFRhcmdldDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbixcbiAgICB2VGFyZ2V0OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnblxuICApOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10ge1xuICAgIC8vIERldGVybWluZSBpZiB0aGUgdGFyZ2V0IGFsaWdubWVudHMgb3ZlcmxhcCB0aGUgYW5jaG9yXG4gICAgY29uc3QgaG9yaXpvbnRhbE92ZXJsYXBBbGxvd2VkID0gaFRhcmdldCAhPT0gJ2JlZm9yZScgJiYgaFRhcmdldCAhPT0gJ2FmdGVyJztcbiAgICBjb25zdCB2ZXJ0aWNhbE92ZXJsYXBBbGxvd2VkID0gdlRhcmdldCAhPT0gJ2Fib3ZlJyAmJiB2VGFyZ2V0ICE9PSAnYmVsb3cnO1xuXG4gICAgLy8gSWYgYSB0YXJnZXQgYWxpZ25tZW50IGRvZXNuJ3QgY292ZXIgdGhlIGFuY2hvciwgZG9uJ3QgbGV0IGFueSBvZiB0aGUgZmFsbGJhY2sgYWxpZ25tZW50c1xuICAgIC8vIGNvdmVyIHRoZSBhbmNob3JcbiAgICBjb25zdCBwb3NzaWJsZUhvcml6b250YWxBbGlnbm1lbnRzOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduW10gPVxuICAgICAgaG9yaXpvbnRhbE92ZXJsYXBBbGxvd2VkID9cbiAgICAgICAgWydiZWZvcmUnLCAnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCcsICdhZnRlciddIDpcbiAgICAgICAgWydiZWZvcmUnLCAnYWZ0ZXInXTtcbiAgICBjb25zdCBwb3NzaWJsZVZlcnRpY2FsQWxpZ25tZW50czogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ25bXSA9XG4gICAgICB2ZXJ0aWNhbE92ZXJsYXBBbGxvd2VkID9cbiAgICAgICAgWydhYm92ZScsICdzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2JlbG93J10gOlxuICAgICAgICBbJ2Fib3ZlJywgJ2JlbG93J107XG5cbiAgICAvLyBDcmVhdGUgZmFsbGJhY2tzIGZvciBlYWNoIGFsbG93ZWQgcHJpb3JpdGl6ZWQgZmFsbGJhY2sgYWxpZ25tZW50IGNvbWJvXG4gICAgY29uc3QgZmFsbGJhY2tzOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10gPSBbXTtcbiAgICBwcmlvcml0aXplQXJvdW5kVGFyZ2V0KGhUYXJnZXQsIHBvc3NpYmxlSG9yaXpvbnRhbEFsaWdubWVudHMpLmZvckVhY2goaCA9PiB7XG4gICAgICBwcmlvcml0aXplQXJvdW5kVGFyZ2V0KHZUYXJnZXQsIHBvc3NpYmxlVmVydGljYWxBbGlnbm1lbnRzKS5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBmYWxsYmFja3MucHVzaChnZXRQb3NpdGlvbihoLCB2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgaXRlbSBzaW5jZSBpdCB3aWxsIGJlIHRoZSB0YXJnZXQgYWxpZ25tZW50IGFuZCBpc24ndCBjb25zaWRlcmVkIGEgZmFsbGJhY2tcbiAgICByZXR1cm4gZmFsbGJhY2tzLnNsaWNlKDEsIGZhbGxiYWNrcy5sZW5ndGgpO1xuICB9XG5cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBjZGsgcG9zaXRpb24gcGFpciBmcm9tIFNhdFBvcG92ZXIgYWxpZ25tZW50cy4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKFxuICBoOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICB2OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbik6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIge1xuICBjb25zdCB7b3JpZ2luWCwgb3ZlcmxheVh9ID0gZ2V0SG9yaXpvbnRhbENvbm5lY3Rpb25Qb3NQYWlyKGgpO1xuICBjb25zdCB7b3JpZ2luWSwgb3ZlcmxheVl9ID0gZ2V0VmVydGljYWxDb25uZWN0aW9uUG9zUGFpcih2KTtcbiAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUG9zaXRpb25QYWlyKHtvcmlnaW5YLCBvcmlnaW5ZfSwge292ZXJsYXlYLCBvdmVybGF5WX0pO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQuICovXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsUG9wb3ZlckFsaWdubWVudChoOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyk6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24ge1xuICBpZiAoaCA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnYWZ0ZXInO1xuICB9XG5cbiAgaWYgKGggPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdiZWZvcmUnO1xuICB9XG5cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQuICovXG5mdW5jdGlvbiBnZXRWZXJ0aWNhbFBvcG92ZXJBbGlnbm1lbnQodjogVmVydGljYWxDb25uZWN0aW9uUG9zKTogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24ge1xuICBpZiAodiA9PT0gJ3RvcCcpIHtcbiAgICByZXR1cm4gJ2JlbG93JztcbiAgfVxuXG4gIGlmICh2ID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAnYWJvdmUnO1xuICB9XG5cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYWxpZ25tZW50IHRvIG9yaWdpbi9vdmVybGF5IHBvc2l0aW9uIHBhaXIuICovXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsQ29ubmVjdGlvblBvc1BhaXIoaDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbik6XG4gICAge29yaWdpblg6IEhvcml6b250YWxDb25uZWN0aW9uUG9zLCBvdmVybGF5WDogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3N9IHtcbiAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ3N0YXJ0Jywgb3ZlcmxheVg6ICdlbmQnfTtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICByZXR1cm4ge29yaWdpblg6ICdzdGFydCcsIG92ZXJsYXlYOiAnc3RhcnQnfTtcbiAgICBjYXNlICdlbmQnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnZW5kJywgb3ZlcmxheVg6ICdlbmQnfTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4ge29yaWdpblg6ICdlbmQnLCBvdmVybGF5WDogJ3N0YXJ0J307XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ2NlbnRlcicsIG92ZXJsYXlYOiAnY2VudGVyJ307XG4gIH1cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGFsaWdubWVudCB0byBvcmlnaW4vb3ZlcmxheSBwb3NpdGlvbiBwYWlyLiAqL1xuZnVuY3Rpb24gZ2V0VmVydGljYWxDb25uZWN0aW9uUG9zUGFpcih2OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbik6XG4gICAge29yaWdpblk6IFZlcnRpY2FsQ29ubmVjdGlvblBvcywgb3ZlcmxheVk6IFZlcnRpY2FsQ29ubmVjdGlvblBvc30ge1xuICBzd2l0Y2ggKHYpIHtcbiAgICBjYXNlICdhYm92ZSc6XG4gICAgICByZXR1cm4ge29yaWdpblk6ICd0b3AnLCBvdmVybGF5WTogJ2JvdHRvbSd9O1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHJldHVybiB7b3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlZOiAndG9wJ307XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWTogJ2JvdHRvbScsIG92ZXJsYXlZOiAnYm90dG9tJ307XG4gICAgY2FzZSAnYmVsb3cnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVk6ICd0b3AnfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnY2VudGVyJywgb3ZlcmxheVk6ICdjZW50ZXInfTtcbiAgfVxufVxuXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gb3JkZXJlZCBhcnJheSBvcHRpb25zIGFuZCByZXR1cm5zIGEgcmVvcmRlcmRlZFxuICogYXJyYXkgYXJvdW5kIHRoZSB0YXJnZXQgaXRlbS4gZS5nLjpcbiAqXG4gKiB0YXJnZXQ6IDM7IG9wdGlvbnM6IFsxLCAyLCAzLCA0LCA1LCA2LCA3XTtcbiAqXG4gKiByZXR1cm46IFszLCA0LCAyLCA1LCAxLCA2LCA3XVxuICovXG5mdW5jdGlvbiBwcmlvcml0aXplQXJvdW5kVGFyZ2V0PFQ+KHRhcmdldDogVCwgb3B0aW9uczogVFtdKTogVFtdIHtcbiAgY29uc3QgdGFyZ2V0SW5kZXggPSBvcHRpb25zLmluZGV4T2YodGFyZ2V0KTtcblxuICAvLyBTZXQgdGhlIGZpcnN0IGl0ZW0gdG8gYmUgdGhlIHRhcmdldFxuICBjb25zdCByZW9yZGVyZWQgPSBbdGFyZ2V0XTtcblxuICAvLyBNYWtlIGxlZnQgYW5kIHJpZ2h0IHN0YWNrcyB3aGVyZSB0aGUgaGlnaGVzdCBwcmlvcml0eSBpdGVtIGlzIGxhc3RcbiAgY29uc3QgbGVmdCA9IG9wdGlvbnMuc2xpY2UoMCwgdGFyZ2V0SW5kZXgpO1xuICBjb25zdCByaWdodCA9IG9wdGlvbnMuc2xpY2UodGFyZ2V0SW5kZXggKyAxLCBvcHRpb25zLmxlbmd0aCkucmV2ZXJzZSgpO1xuXG4gIC8vIEFsdGVybmF0ZSBiZXR3ZWVuIHN0YWNrcyB1bnRpbCBvbmUgaXMgZW1wdHlcbiAgd2hpbGUgKGxlZnQubGVuZ3RoICYmIHJpZ2h0Lmxlbmd0aCkge1xuICAgIHJlb3JkZXJlZC5wdXNoKHJpZ2h0LnBvcCgpKTtcbiAgICByZW9yZGVyZWQucHVzaChsZWZ0LnBvcCgpKTtcbiAgfVxuXG4gIC8vIEZsdXNoIG91dCByaWdodCBzaWRlXG4gIHdoaWxlIChyaWdodC5sZW5ndGgpIHtcbiAgICByZW9yZGVyZWQucHVzaChyaWdodC5wb3AoKSk7XG4gIH1cblxuICAvLyBGbHVzaCBvdXQgbGVmdCBzaWRlXG4gIHdoaWxlIChsZWZ0Lmxlbmd0aCkge1xuICAgIHJlb3JkZXJlZC5wdXNoKGxlZnQucG9wKCkpO1xuICB9XG5cbiAgcmV0dXJuIHJlb3JkZXJlZDtcbn1cbiIsImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25Jbml0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIG1lcmdlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgU2F0UG9wb3ZlciB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgZ2V0SW52YWxpZFBvcG92ZXJFcnJvciB9IGZyb20gJy4vcG9wb3Zlci5lcnJvcnMnO1xuaW1wb3J0IHsgU2F0UG9wb3ZlckFuY2hvcmluZ1NlcnZpY2UgfSBmcm9tICcuL3BvcG92ZXItYW5jaG9yaW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2F0UG9wb3Zlck9wZW5PcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tzYXRQb3BvdmVyQW5jaG9yRm9yXScsXG4gIGV4cG9ydEFzOiAnc2F0UG9wb3ZlckFuY2hvcicsXG4gIHByb3ZpZGVyczogW1NhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgU2F0UG9wb3ZlckFuY2hvciBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBwb3BvdmVyIGluc3RhbmNlLiAqL1xuICBASW5wdXQoJ3NhdFBvcG92ZXJBbmNob3JGb3InKVxuICBnZXQgYXR0YWNoZWRQb3BvdmVyKCkgeyByZXR1cm4gdGhpcy5fYXR0YWNoZWRQb3BvdmVyOyB9XG4gIHNldCBhdHRhY2hlZFBvcG92ZXIodmFsdWU6IFNhdFBvcG92ZXIpIHtcbiAgICB0aGlzLl92YWxpZGF0ZUF0dGFjaGVkUG9wb3Zlcih2YWx1ZSk7XG4gICAgdGhpcy5fYXR0YWNoZWRQb3BvdmVyID0gdmFsdWU7XG4gICAgLy8gQW5jaG9yIHRoZSBwb3BvdmVyIHRvIHRoZSBlbGVtZW50IHJlZlxuICAgIHRoaXMuX2FuY2hvcmluZy5hbmNob3IodGhpcy5hdHRhY2hlZFBvcG92ZXIsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYsIHRoaXMuX2VsZW1lbnRSZWYpO1xuICB9XG4gIHByaXZhdGUgX2F0dGFjaGVkUG9wb3ZlcjogU2F0UG9wb3ZlcjtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIEBPdXRwdXQoKSBwb3BvdmVyT3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgQE91dHB1dCgpIHBvcG92ZXJDbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZC4gKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHVibGljIF9hbmNob3Jpbmc6IFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlLFxuICApIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIC8vIFJlLWVtaXQgb3BlbiBhbmQgY2xvc2UgZXZlbnRzXG4gICAgY29uc3Qgb3BlbmVkJCA9IHRoaXMuX2FuY2hvcmluZy5wb3BvdmVyT3BlbmVkXG4gICAgICAucGlwZSh0YXAoKCkgPT4gdGhpcy5wb3BvdmVyT3BlbmVkLmVtaXQoKSkpO1xuICAgIGNvbnN0IGNsb3NlZCQgPSB0aGlzLl9hbmNob3JpbmcucG9wb3ZlckNsb3NlZFxuICAgICAgLnBpcGUodGFwKHZhbHVlID0+IHRoaXMucG9wb3ZlckNsb3NlZC5lbWl0KHZhbHVlKSkpO1xuICAgIG1lcmdlKG9wZW5lZCQsIGNsb3NlZCQpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBHZXRzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIGlzUG9wb3Zlck9wZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcmluZy5pc1BvcG92ZXJPcGVuKCk7XG4gIH1cblxuICAvKiogVG9nZ2xlcyB0aGUgcG9wb3ZlciBiZXR3ZWVuIHRoZSBvcGVuIGFuZCBjbG9zZWQgc3RhdGVzLiAqL1xuICB0b2dnbGVQb3BvdmVyKCk6IHZvaWQge1xuICAgIHRoaXMuX2FuY2hvcmluZy50b2dnbGVQb3BvdmVyKCk7XG4gIH1cblxuICAvKiogT3BlbnMgdGhlIHBvcG92ZXIuICovXG4gIG9wZW5Qb3BvdmVyKG9wdGlvbnM6IFNhdFBvcG92ZXJPcGVuT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgdGhpcy5fYW5jaG9yaW5nLm9wZW5Qb3BvdmVyKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqIENsb3NlcyB0aGUgcG9wb3Zlci4gKi9cbiAgY2xvc2VQb3BvdmVyKHZhbHVlPzogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fYW5jaG9yaW5nLmNsb3NlUG9wb3Zlcih2YWx1ZSk7XG4gIH1cblxuICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICByZWFsaWduUG9wb3ZlcigpOiB2b2lkIHtcbiAgICB0aGlzLl9hbmNob3JpbmcucmVhbGlnblBvcG92ZXJUb0FuY2hvcigpO1xuICB9XG5cbiAgLyoqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuICovXG4gIGdldEVsZW1lbnQoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWY7XG4gIH1cblxuICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwb3BvdmVyIGluc3RhbmNlIGlzIG5vdCBwcm92aWRlZC4gKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdGVBdHRhY2hlZFBvcG92ZXIocG9wb3ZlcjogU2F0UG9wb3Zlcik6IHZvaWQge1xuICAgIGlmICghcG9wb3ZlciB8fCAhKHBvcG92ZXIgaW5zdGFuY2VvZiBTYXRQb3BvdmVyKSkge1xuICAgICAgdGhyb3cgZ2V0SW52YWxpZFBvcG92ZXJFcnJvcigpO1xuICAgIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29lcmNlTnVtYmVyUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgb2YsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlbGF5LCBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgU2F0UG9wb3ZlckFuY2hvciB9IGZyb20gJy4vcG9wb3Zlci1hbmNob3IuZGlyZWN0aXZlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3NhdFBvcG92ZXJIb3Zlcl0nXG59KVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJIb3ZlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSAobXMpIGFmdGVyIGhvdmVyaW5nIHN0YXJ0cyBiZWZvcmVcbiAgICogdGhlIHBvcG92ZXIgb3BlbnMuIERlZmF1bHRzIHRvIDBtcy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBzYXRQb3BvdmVySG92ZXIoKSB7IHJldHVybiB0aGlzLl9zYXRQb3BvdmVySG92ZXI7IH1cbiAgc2V0IHNhdFBvcG92ZXJIb3Zlcih2YWw6IG51bWJlcikge1xuICAgIHRoaXMuX3NhdFBvcG92ZXJIb3ZlciA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbCk7XG4gIH1cbiAgcHJpdmF0ZSBfc2F0UG9wb3ZlckhvdmVyID0gMDtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZC4gKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3QoKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGVudGVycyB0aGUgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfb25Nb3VzZUVudGVyID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGxlYXZlcyB0aGUgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfb25Nb3VzZUxlYXZlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgYW5jaG9yOiBTYXRQb3BvdmVyQW5jaG9yKSB7IH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgLy8gV2hlbmV2ZXIgdGhlIHVzZXIgaG92ZXJzIHRoaXMgaG9zdCBlbGVtZW50LCBkZWxheSB0aGUgY29uZmlndXJlZFxuICAgIC8vIGFtb3VudCBvZiB0aW1lIGFuZCBvcGVuIHRoZSBwb3BvdmVyLiBUZXJtaW5hdGUgaWYgdGhlIG1vdXNlIGxlYXZlc1xuICAgIC8vIHRoZSBob3N0IGVsZW1lbnQgYmVmb3JlIHRoZSBkZWxheSBpcyBjb21wbGV0ZS5cbiAgICB0aGlzLl9vbk1vdXNlRW50ZXJcbiAgICAgIC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvZihudWxsKS5waXBlKFxuICAgICAgICAgICAgZGVsYXkodGhpcy5fc2F0UG9wb3ZlckhvdmVyIHx8IDApLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uTW91c2VMZWF2ZSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmFuY2hvci5vcGVuUG9wb3ZlcigpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJylcbiAgc2hvd1BvcG92ZXIoKSB7XG4gICAgdGhpcy5fb25Nb3VzZUVudGVyLm5leHQoKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKVxuICBjbG9zZVBvcG92ZXIoKSB7XG4gICAgdGhpcy5fb25Nb3VzZUxlYXZlLm5leHQoKTtcbiAgICB0aGlzLmFuY2hvci5jbG9zZVBvcG92ZXIoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBPdmVybGF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQTExeU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IEJpZGlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5cbmltcG9ydCB7IFNhdFBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFNhdFBvcG92ZXJBbmNob3IgfSBmcm9tICcuL3BvcG92ZXItYW5jaG9yLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTYXRQb3BvdmVySG92ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3BvcG92ZXItaG92ZXIuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBPdmVybGF5TW9kdWxlLFxuICAgIEExMXlNb2R1bGUsXG4gICAgQmlkaU1vZHVsZSxcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbXG4gICAgU2F0UG9wb3ZlcixcbiAgICBTYXRQb3BvdmVyQW5jaG9yLFxuICAgIFNhdFBvcG92ZXJIb3ZlckRpcmVjdGl2ZSxcbiAgXSxcbiAgZXhwb3J0czogW1xuICAgIFNhdFBvcG92ZXIsXG4gICAgU2F0UG9wb3ZlckFuY2hvcixcbiAgICBTYXRQb3BvdmVySG92ZXJEaXJlY3RpdmUsXG4gICAgQmlkaU1vZHVsZSxcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBTYXRQb3BvdmVyTW9kdWxlIHsgfVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQVNBLE1BQWEsZ0JBQWdCLEdBQTZCLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRTtJQUNwRixVQUFVLENBQUMsUUFBUSxFQUFFO1FBQ25CLEtBQUssQ0FBQyxFQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBQyxDQUFDO1FBQzVDLE9BQU8sQ0FBQyxvQkFBb0IsRUFDMUIsS0FBSyxDQUFDLEVBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFDLENBQUMsQ0FBQztLQUM5QyxDQUFDO0lBQ0YsVUFBVSxDQUFDLFFBQVEsRUFBRTtRQUNuQixPQUFPLENBQUMscUJBQXFCLEVBQzNCLEtBQUssQ0FBQyxFQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBQyxDQUFDLENBQUM7S0FDaEQsQ0FBQztDQUNILENBQUM7Ozs7OztBQ25CRjs7O0lBTUUsT0FBSTs7SUFFSixRQUFLOztJQUVMLFNBQU07O0lBRU4sYUFBVTs7SUFFVixnQkFBYTs7SUFFYixVQUFPOzs7Ozs7Ozs7OztBQUlULE1BQWEsbUJBQW1COzs7OztJQUM5QixZQUVTLE1BQTBCLEVBRTFCLEtBQVc7UUFGWCxXQUFNLEdBQU4sTUFBTSxDQUFvQjtRQUUxQixVQUFLLEdBQUwsS0FBSyxDQUFNO0tBQ2Y7Q0FDTjtNQUdZLDBCQUEwQjtJQUR2QztRQUdVLFVBQUssR0FBRyxJQUFJLE9BQU8sRUFBdUIsQ0FBQztLQWlCcEQ7Ozs7OztJQWRDLFFBQVEsQ0FBQyxZQUFpQztRQUN4QyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztLQUMvQjs7Ozs7SUFHRCxNQUFNO1FBQ0osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxDQUFDO0tBQ2xDOzs7OztJQUdELE9BQU87UUFDTCxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0tBQ3ZCOzs7WUFsQkYsVUFBVTs7Ozs7Ozs7QUM1QlgsTUFBYSxZQUFZLEdBQStCO0lBQ3RELE1BQU07SUFDTixPQUFPO0lBQ1AsWUFBWTtJQUNaLE9BQU87Q0FDUjs7QUFHRCxNQUFhLGlCQUFpQixHQUFnQztJQUM1RCxRQUFRO0lBQ1IsT0FBTztJQUNQLFFBQVE7SUFDUixLQUFLO0lBQ0wsT0FBTztDQUNSOztBQUdELE1BQWEsZ0JBQWdCLEdBQThCO0lBQ3pELE9BQU87SUFDUCxPQUFPO0lBQ1AsUUFBUTtJQUNSLEtBQUs7SUFDTCxPQUFPO0NBQ1I7Ozs7OztBQ3hCRDs7O0FBRUEsU0FBZ0Isc0JBQXNCO0lBQ3BDLE9BQU8sS0FBSyxDQUFDLHFFQUFxRSxDQUFDLENBQUM7Q0FDckY7Ozs7QUFFRCxTQUFnQix5QkFBeUI7SUFDdkMsT0FBTyxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztDQUNyRTs7Ozs7QUFFRCxTQUFnQiw4QkFBOEIsQ0FBQyxTQUFTO0lBQ3RELE9BQU8sS0FBSyxDQUFDLG9CQUFvQixDQUFDLHdCQUF3QixFQUFFLFNBQVMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7Q0FDNUY7Ozs7O0FBRUQsU0FBZ0IsNEJBQTRCLENBQUMsU0FBUztJQUNwRCxPQUFPLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxzQkFBc0IsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO0NBQ3pGOzs7OztBQUVELFNBQWdCLDZCQUE2QixDQUFDLFFBQVE7SUFDcEQsT0FBTyxLQUFLLENBQUMsb0JBQW9CLENBQUMsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7Q0FDOUU7Ozs7Ozs7QUFFRCxTQUFTLG9CQUFvQixDQUFDLE9BQWUsRUFBRSxPQUFZLEVBQUUsS0FBZTtJQUMxRSxPQUFPLFdBQVcsT0FBTyxNQUFNLE9BQU8sdUJBQXVCO1FBQzNELEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO0NBQzdDOzs7Ozs7QUN6QkQ7O01BMENNLGtCQUFrQixHQUFJLHdDQUF3QztBQVNwRSxNQUFhLFVBQVU7Ozs7O0lBNEtyQixZQUNVLGlCQUFtQyxFQUNMLFNBQWM7UUFENUMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFrQjtRQUNMLGNBQVMsR0FBVCxTQUFTLENBQUs7UUFsSzlDLHFCQUFnQixHQUE4QixRQUFRLENBQUM7UUFpQnZELG1CQUFjLEdBQTRCLFFBQVEsQ0FBQztRQWlCbkQsb0JBQWUsR0FBRyxLQUFLLENBQUM7UUFleEIsbUJBQWMsR0FBRyxLQUFLLENBQUM7UUFRdkIsZUFBVSxHQUFHLElBQUksQ0FBQztRQUMxQix1QkFBa0IsR0FBRyxJQUFJLENBQUM7UUFRbEIsa0JBQWEsR0FBRyxJQUFJLENBQUM7UUFDN0IsMEJBQXFCLEdBQUcsSUFBSSxDQUFDO1FBWXJCLG9CQUFlLEdBQTZCLFlBQVksQ0FBQztRQVF6RCxpQkFBWSxHQUFHLEtBQUssQ0FBQztRQVFyQixzQkFBaUIsR0FBRyxJQUFJLENBQUM7UUFVekIsb0JBQWUsR0FBRyxrQkFBa0IsQ0FBQztRQVVyQyxxQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBQzs7OztRQUdyQyxrQkFBYSxHQUFHLEVBQUUsQ0FBQzs7OztRQUdsQixXQUFNLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQzs7OztRQUdsQyxXQUFNLEdBQUcsSUFBSSxZQUFZLEVBQU8sQ0FBQzs7OztRQUdqQyxjQUFTLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQzs7OztRQUdyQyxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQzs7OztRQUd0QyxvQkFBZSxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7Ozs7UUFHM0MsbUJBQWMsR0FBRyxJQUFJLFlBQVksRUFBaUIsQ0FBQzs7OztRQU03RCxlQUFVLEdBQVEsRUFBRSxDQUFDOzs7O1FBR3JCLFVBQUssR0FBRyxLQUFLLENBQUM7S0FrQlQ7Ozs7O0lBNUtMLElBQ0ksZUFBZSxLQUFLLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7Ozs7O0lBQ3ZELElBQUksZUFBZSxDQUFDLEdBQThCO1FBQ2hELElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNuQyxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsS0FBSyxHQUFHLEVBQUU7WUFDakMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsQ0FBQztZQUM1QixJQUFJLENBQUMsMkJBQTJCLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1NBQzFGO0tBQ0Y7Ozs7O0lBSUQsSUFDSSxNQUFNLEtBQUssT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUU7Ozs7O0lBQzdDLElBQUksTUFBTSxDQUFDLEdBQThCLElBQUksSUFBSSxDQUFDLGVBQWUsR0FBRyxHQUFHLENBQUMsRUFBRTs7Ozs7SUFHMUUsSUFDSSxhQUFhLEtBQUssT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUU7Ozs7O0lBQ25ELElBQUksYUFBYSxDQUFDLEdBQTRCO1FBQzVDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNqQyxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssR0FBRyxFQUFFO1lBQy9CLElBQUksQ0FBQyxjQUFjLEdBQUcsR0FBRyxDQUFDO1lBQzFCLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7U0FDMUY7S0FDRjs7Ozs7SUFJRCxJQUNJLE1BQU0sS0FBSyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRTs7Ozs7SUFDM0MsSUFBSSxNQUFNLENBQUMsR0FBNEIsSUFBSSxJQUFJLENBQUMsYUFBYSxHQUFHLEdBQUcsQ0FBQyxFQUFFOzs7OztJQUd0RSxJQUNJLGNBQWMsS0FBSyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRTs7Ozs7SUFDckQsSUFBSSxjQUFjLENBQUMsR0FBWTs7Y0FDdkIsVUFBVSxHQUFHLHFCQUFxQixDQUFDLEdBQUcsQ0FBQztRQUM3QyxJQUFJLElBQUksQ0FBQyxlQUFlLEtBQUssVUFBVSxFQUFFO1lBQ3ZDLElBQUksQ0FBQyxlQUFlLEdBQUcsVUFBVSxDQUFDO1lBQ2xDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7U0FDMUY7S0FDRjs7Ozs7O0lBT0QsSUFDSSxhQUFhLEtBQUssT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUU7Ozs7O0lBQ25ELElBQUksYUFBYSxDQUFDLEdBQVk7O2NBQ3RCLFVBQVUsR0FBRyxxQkFBcUIsQ0FBQyxHQUFHLENBQUM7UUFDN0MsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLFVBQVUsRUFBRTtZQUN0QyxJQUFJLENBQUMsY0FBYyxHQUFHLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pELElBQUksQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7U0FDMUY7S0FDRjs7Ozs7SUFJRCxJQUNJLFNBQVMsS0FBSyxPQUFPLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLGtCQUFrQixDQUFDLEVBQUU7Ozs7O0lBQ3RFLElBQUksU0FBUyxDQUFDLEdBQVk7UUFDeEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUM5Qzs7Ozs7SUFLRixJQUNLLFlBQVksS0FBSyxPQUFPLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLHFCQUFxQixDQUFDLEVBQUU7Ozs7O0lBQy9FLElBQUksWUFBWSxDQUFDLEdBQVk7UUFDM0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNqRDs7Ozs7SUFLRCxJQUNJLGNBQWMsS0FBSyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRTs7Ozs7SUFDckQsSUFBSSxjQUFjLENBQUMsR0FBNkI7UUFDOUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xDLElBQUksSUFBSSxDQUFDLGVBQWUsS0FBSyxHQUFHLEVBQUU7WUFDaEMsSUFBSSxDQUFDLGVBQWUsR0FBRyxHQUFHLENBQUM7WUFDM0IsSUFBSSxDQUFDLDJCQUEyQixDQUFDLElBQUksbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztTQUM3RjtLQUNGOzs7OztJQUlELElBQ0ksV0FBVyxLQUFLLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFOzs7OztJQUMvQyxJQUFJLFdBQVcsQ0FBQyxHQUFZO1FBQzFCLElBQUksQ0FBQyxZQUFZLEdBQUcscUJBQXFCLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDaEQ7Ozs7O0lBSUQsSUFDSSxnQkFBZ0IsS0FBSyxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFOzs7OztJQUN6RCxJQUFJLGdCQUFnQixDQUFDLEdBQVk7UUFDL0IsSUFBSSxDQUFDLGlCQUFpQixHQUFHLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3JEOzs7OztJQUlELElBQ0ksY0FBYyxLQUFLLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFOzs7OztJQUNyRCxJQUFJLGNBQWMsQ0FBQyxHQUFXO1FBQzVCLElBQUksR0FBRyxFQUFFO1lBQ1AsSUFBSSxDQUFDLGVBQWUsR0FBRyxHQUFHLENBQUM7U0FDNUI7S0FDRjs7Ozs7SUFJRCxJQUNJLGVBQWUsS0FBSyxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFOzs7OztJQUN2RCxJQUFJLGVBQWUsQ0FBQyxHQUFXO1FBQzdCLElBQUksR0FBRyxFQUFFO1lBQ1AsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsQ0FBQztTQUM3QjtLQUNGOzs7O0lBbURELFFBQVE7UUFDTixJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztLQUM3Qjs7OztJQUVELFdBQVc7UUFDVCxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDdkIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUMvQjtLQUNGOzs7Ozs7SUFHRCxJQUFJLENBQUMsVUFBaUMsRUFBRTs7Y0FDaEMsWUFBWSxHQUFHLElBQUksbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQztRQUM5RSxJQUFJLENBQUMsMkJBQTJCLENBQUMsWUFBWSxDQUFDLENBQUM7S0FDaEQ7Ozs7OztJQUdELEtBQUssQ0FBQyxLQUFXOztjQUNULFlBQVksR0FBRyxJQUFJLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7UUFDN0UsSUFBSSxDQUFDLDJCQUEyQixDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQ2hEOzs7OztJQUdELE1BQU07O2NBQ0UsWUFBWSxHQUFHLElBQUksbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDO1FBQ3ZFLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxZQUFZLENBQUMsQ0FBQztLQUNoRDs7Ozs7SUFHRCxPQUFPOztjQUNDLFlBQVksR0FBRyxJQUFJLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQztRQUN4RSxJQUFJLENBQUMsMkJBQTJCLENBQUMsWUFBWSxDQUFDLENBQUM7S0FDaEQ7Ozs7O0lBR0QsTUFBTTtRQUNKLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztLQUNuQjs7Ozs7SUFHRCxhQUFhO1FBQ1gsT0FBTztZQUNMLEtBQUssRUFBRSxTQUFTO1lBQ2hCLE1BQU0sRUFBRSxFQUFFLGNBQWMsRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFO1NBQ3ZGLENBQUM7S0FDSDs7Ozs7O0lBR0QsZ0JBQWdCLENBQUMsS0FBcUI7UUFDcEMsSUFBSSxLQUFLLENBQUMsT0FBTyxLQUFLLFNBQVMsRUFBRTtZQUMvQixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDbEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUN2QjthQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sS0FBSyxNQUFNLEVBQUU7WUFDbkMsSUFBSSxDQUFDLDJCQUEyQixFQUFFLENBQUM7WUFDbkMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUN4QjtLQUNGOzs7Ozs7O0lBR0Qsb0JBQW9CLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhO1FBQ3BGLElBQUksQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsR0FBRyxVQUFVLEtBQUssUUFBUSxJQUFJLFVBQVUsS0FBSyxLQUFLLENBQUM7UUFDeEYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxHQUFJLFVBQVUsS0FBSyxPQUFPLElBQUksVUFBVSxLQUFLLE9BQU8sQ0FBQztRQUV6RixJQUFJLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsU0FBUyxLQUFLLE9BQU8sSUFBSSxTQUFTLEtBQUssS0FBSyxDQUFDO1FBQ3BGLElBQUksQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsR0FBRyxTQUFTLEtBQUssT0FBTyxJQUFJLFNBQVMsS0FBSyxPQUFPLENBQUM7UUFFdEYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLFVBQVUsS0FBSyxRQUFRLElBQUksU0FBUyxLQUFLLFFBQVEsQ0FBQztLQUMzRjs7Ozs7SUFHTyxVQUFVO1FBQ2hCLElBQUksQ0FBQyw2QkFBNkIsRUFBRSxDQUFDOztRQUdyQyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQzNCLE9BQU87U0FDUjtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUM5QyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQ3ZGO1FBRUQsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxVQUFVLENBQUMsNEJBQTRCLEVBQUUsQ0FBQztTQUNoRDtLQUNGOzs7OztJQUdPLDJCQUEyQjs7Y0FDM0IsT0FBTyxHQUFHLElBQUksQ0FBQyx5QkFBeUI7O1FBRzlDLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUN0RCxJQUFJLENBQUMseUJBQXlCLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDeEM7UUFFRCxJQUFJLENBQUMseUJBQXlCLEdBQUcsSUFBSSxDQUFDO1FBRXRDLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNuQixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO1NBQzdCO0tBQ0Y7Ozs7O0lBR08sNkJBQTZCO1FBQ25DLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNsQixJQUFJLENBQUMseUJBQXlCLHNCQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFlLENBQUM7U0FDOUU7S0FDRjs7Ozs7O0lBR08sMkJBQTJCLENBQUMsWUFBaUM7UUFDbkUsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQzVDO0tBQ0Y7Ozs7OztJQUdPLDJCQUEyQixDQUFDLFlBQWlDO1FBQ25FLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3hCLE1BQU0seUJBQXlCLEVBQUUsQ0FBQztTQUNuQztRQUVELElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQzVDOzs7Ozs7SUFHTyx3QkFBd0IsQ0FBQyxHQUE4QjtRQUM3RCxJQUFJLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUN6QyxNQUFNLDhCQUE4QixDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNDO0tBQ0Y7Ozs7OztJQUdPLHNCQUFzQixDQUFDLEdBQTRCO1FBQ3pELElBQUksZ0JBQWdCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO1lBQ3hDLE1BQU0sNEJBQTRCLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDekM7S0FDRjs7Ozs7O0lBR08sdUJBQXVCLENBQUMsUUFBa0M7UUFDaEUsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO1lBQ3pDLE1BQU0sNkJBQTZCLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDL0M7S0FDRjs7O1lBMVVGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsYUFBYTtnQkFDdkIsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7Z0JBQ3JDLFVBQVUsRUFBRSxDQUFDLGdCQUFnQixDQUFDO2dCQUU5QixrU0FBdUM7O2FBQ3hDOzs7O1lBbENtQixnQkFBZ0I7NENBaU4vQixRQUFRLFlBQUksTUFBTSxTQUFDLFFBQVE7Ozs4QkEzSzdCLEtBQUs7cUJBWUwsS0FBSzs0QkFLTCxLQUFLO3FCQVlMLEtBQUs7NkJBS0wsS0FBSzs0QkFlTCxLQUFLO3dCQVlMLEtBQUs7MkJBU04sS0FBSzs2QkFTSixLQUFLOzBCQVlMLEtBQUs7K0JBUUwsS0FBSzs2QkFRTCxLQUFLOzhCQVVMLEtBQUs7NEJBVUwsS0FBSztxQkFHTCxNQUFNO3FCQUdOLE1BQU07d0JBR04sTUFBTTt5QkFHTixNQUFNOzhCQUdOLE1BQU07NkJBR04sTUFBTTsyQkFHTixTQUFTLFNBQUMsV0FBVztnQ0FZckIsU0FBUyxTQUFDLGtCQUFrQjs7Ozs7OztBQ3ROL0IsTUFpRGEsMEJBQTBCOzs7Ozs7SUFzQ3JDLFlBQ1UsUUFBaUIsRUFDakIsT0FBZSxFQUNILElBQW9CO1FBRmhDLGFBQVEsR0FBUixRQUFRLENBQVM7UUFDakIsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNILFNBQUksR0FBSixJQUFJLENBQWdCOzs7O1FBdEMxQyxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7Ozs7UUFHcEMsa0JBQWEsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDOzs7O1FBMkI1QixpQkFBWSxHQUFHLEtBQUssQ0FBQzs7OztRQUdyQixlQUFVLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztLQU1wQzs7OztJQUVMLFdBQVc7OztRQUdULElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7UUFHdkIsSUFBSSxJQUFJLENBQUMsMEJBQTBCLEVBQUU7WUFDbkMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQy9DO1FBQ0QsSUFBSSxJQUFJLENBQUMsMkJBQTJCLEVBQUU7WUFDcEMsSUFBSSxDQUFDLDJCQUEyQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ2hEO1FBQ0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRTNCLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDOUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUMvQjs7Ozs7Ozs7SUFHRCxNQUFNLENBQUMsT0FBbUIsRUFBRSxnQkFBa0MsRUFBRSxNQUFrQjs7UUFFaEYsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDOztRQUd2QixJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztRQUN4QixJQUFJLENBQUMsaUJBQWlCLEdBQUcsZ0JBQWdCLENBQUM7UUFDMUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7OztRQUl0QixJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksMEJBQTBCLEVBQUUsQ0FBQztRQUN0RixJQUFJLENBQUMseUJBQXlCLEVBQUUsQ0FBQztLQUNsQzs7Ozs7SUFHRCxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0tBQzFCOzs7OztJQUdELGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztLQUNyRTs7Ozs7O0lBR0QsV0FBVyxDQUFDLFVBQWlDLEVBQUU7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDdEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ2hDLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUN0QixJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztZQUM1QixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUMxQixJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztZQUMvQixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztTQUN6QjtLQUNGOzs7Ozs7SUFHRCxZQUFZLENBQUMsS0FBVztRQUN0QixJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDcEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzdCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDM0I7S0FDRjs7Ozs7SUFHRCxzQkFBc0I7UUFDcEIsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFOztrQkFDZCxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUU7O2tCQUNyQyxRQUFRLHNCQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBcUM7WUFDN0UsUUFBUSxDQUFDLG1CQUFtQixFQUFFLENBQUM7U0FDaEM7S0FDRjs7Ozs7SUFHRCxnQkFBZ0I7UUFDZCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7S0FDckI7Ozs7OztJQUdPLGlCQUFpQixDQUFDLE9BQThCOzs7Y0FFaEQsWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLEtBQUssS0FBSztRQUNuRCxJQUFJLENBQUMsUUFBUSxDQUFDLHFCQUFxQixHQUFHLFlBQVksQ0FBQzs7O2NBRzdDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxLQUFLLEtBQUs7UUFDN0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsR0FBRyxTQUFTLENBQUM7S0FDOUM7Ozs7O0lBR08sY0FBYzs7UUFFcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQzs7a0JBRWhGLGFBQWEsR0FBRztnQkFDcEIsZUFBZSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZTtnQkFDOUMsYUFBYSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYTtnQkFDMUMsV0FBVyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVztnQkFDdEMsYUFBYSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYTtnQkFDMUMsY0FBYyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYztnQkFDNUMsY0FBYyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYztnQkFDNUMsYUFBYSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYTthQUMzQzs7a0JBRUssYUFBYSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUV6RSxJQUFJLENBQUMsMkJBQTJCLG9CQUM5QixhQUFhLENBQUMsZ0JBQWdCLEdBQy9CLENBQUM7WUFFRixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQ3hEOztRQUdELElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0QyxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7S0FDekI7Ozs7O0lBSU8sZUFBZTtRQUNyQixJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDcEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUMzQixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztTQUN6QjtLQUNGOzs7Ozs7SUFNTyx5QkFBeUI7UUFDL0IsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUM1QyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FDakMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUNQLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQzNCLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7U0FDM0M7YUFBTTtZQUNMLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztTQUN4QjtLQUNGOzs7Ozs7SUFNTyx5QkFBeUI7UUFDL0IsSUFBSSxJQUFJLENBQUMsMEJBQTBCLEVBQUU7WUFDbkMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQy9DO1FBRUQsSUFBSSxDQUFDLDBCQUEwQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFO2FBQzNELFNBQVMsQ0FBQyxLQUFLO1lBQ2QsUUFBUSxLQUFLLENBQUMsTUFBTTtnQkFDbEIsS0FBSyxrQkFBa0IsQ0FBQyxJQUFJO29CQUMxQixJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDOUIsTUFBTTtnQkFDUixLQUFLLGtCQUFrQixDQUFDLEtBQUs7b0JBQzNCLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMvQixNQUFNO2dCQUNSLEtBQUssa0JBQWtCLENBQUMsTUFBTTtvQkFDNUIsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO29CQUNyQixNQUFNO2dCQUNSLEtBQUssa0JBQWtCLENBQUMsVUFBVSxDQUFDOztnQkFFbkMsS0FBSyxrQkFBa0IsQ0FBQyxhQUFhO29CQUNuQyxJQUFJLENBQUMseUJBQXlCLEVBQUUsQ0FBQztvQkFDakMsTUFBTTtnQkFDUixLQUFLLGtCQUFrQixDQUFDLE9BQU87b0JBQzdCLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO29CQUM5QixNQUFNO2FBQ1Q7U0FDRixDQUFDLENBQUM7S0FDTjs7Ozs7SUFHTyxvQkFBb0I7UUFDMUIsSUFBSSxDQUFDLFdBQVc7YUFDYixhQUFhLEVBQUU7YUFDZixJQUFJLENBQ0gsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLENBQUMsRUFDL0MsTUFBTSxDQUFDLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUM1QyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUM3QixTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUMzQjthQUNBLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO0tBQ3pDOzs7OztJQUdPLGtCQUFrQjtRQUN4QixJQUFJLENBQUMsV0FBVzthQUNiLGFBQWEsRUFBRTthQUNmLElBQUksQ0FDSCxHQUFHLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUN0RCxNQUFNLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxPQUFPLEtBQUssTUFBTSxDQUFDLEVBQ3pDLE1BQU0sQ0FBQyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsRUFDNUMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFDN0IsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FDM0I7YUFDQSxTQUFTLENBQUMsTUFBTSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztLQUN6Qzs7Ozs7SUFHTyx1QkFBdUI7UUFDN0IsSUFBSSxDQUFDLFdBQVc7YUFDYixXQUFXLEVBQUU7YUFDYixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNoQyxTQUFTLENBQUMsTUFBTSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO0tBQzdDOzs7OztJQUdPLGdCQUFnQjtRQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUN0QixJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztZQUUvQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQzdCO0tBQ0Y7Ozs7OztJQUdPLGdCQUFnQixDQUFDLEtBQVc7UUFDbEMsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3JCLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1lBRWhELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNsQztLQUNGOzs7OztJQUdPLGFBQWE7UUFDbkIsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0tBQy9EOzs7Ozs7O0lBR08saUJBQWlCLENBQUMsTUFBcUIsRUFBRSxNQUFrQjtRQUNqRSxPQUFPLElBQUksYUFBYSxDQUFDO1lBQ3ZCLGdCQUFnQixFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FDekMsTUFBTSxDQUFDLGVBQWUsRUFDdEIsTUFBTSxDQUFDLGFBQWEsRUFDcEIsTUFBTSxDQUFDLGNBQWMsRUFDckIsTUFBTSxDQUFDLGFBQWEsRUFDcEIsTUFBTSxDQUNQO1lBQ0QsV0FBVyxFQUFFLE1BQU0sQ0FBQyxXQUFXO1lBQy9CLGFBQWEsRUFBRSxNQUFNLENBQUMsYUFBYSxJQUFJLGtDQUFrQztZQUN6RSxjQUFjLEVBQUUsSUFBSSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUM7WUFDdEUsU0FBUyxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUU7U0FDaEMsQ0FBQyxDQUFDO0tBQ0o7Ozs7Ozs7SUFNTywyQkFBMkIsQ0FBQyxRQUEyQztRQUM3RSxJQUFJLElBQUksQ0FBQywyQkFBMkIsRUFBRTtZQUNwQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDaEQ7UUFFRCxJQUFJLENBQUMsMkJBQTJCLEdBQUcsUUFBUSxDQUFDLGVBQWU7YUFDeEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDaEMsU0FBUyxDQUFDLE1BQU07O1lBRWYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7Z0JBQ2YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FDaEMsNkJBQTZCLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFDN0QsMkJBQTJCLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FDNUQsQ0FBQzthQUNILENBQUMsQ0FBQztTQUNKLENBQUMsQ0FBQztLQUNOOzs7Ozs7SUFHTywwQkFBMEIsQ0FBQyxRQUFrQztRQUNuRSxRQUFRLFFBQVE7WUFDZCxLQUFLLE9BQU87Z0JBQ1YsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2hELEtBQUssWUFBWTtnQkFDZixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDckQsS0FBSyxPQUFPO2dCQUNWLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNoRCxLQUFLLE1BQU0sQ0FBQztZQUNaO2dCQUNFLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUNoRDtLQUNGOzs7Ozs7Ozs7O0lBR08sb0JBQW9CLENBQzFCLGdCQUEyQyxFQUMzQyxjQUF1QyxFQUN2QyxjQUF1QixFQUN2QixhQUFzQixFQUN0QixNQUFrQjs7O2NBR1osY0FBYyxHQUFHLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUM7O2NBQzlELFNBQVMsR0FBRyxDQUFDLGNBQWMsQ0FBQzs7Y0FFNUIsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFO2FBQ3RDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQzthQUMzQixzQkFBc0IsQ0FBQyxLQUFLLENBQUM7YUFDN0IsUUFBUSxDQUFDLEtBQUssQ0FBQzthQUNmLGtCQUFrQixDQUFDLENBQUMsQ0FBQzthQUNyQixrQkFBa0IsQ0FBQyxhQUFhLENBQUM7O1FBR3BDLElBQUksQ0FBQyxjQUFjLEVBQUU7O2tCQUNiLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixFQUFFLGNBQWMsQ0FBQztZQUN0RSxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUM7U0FDOUI7UUFFRCxPQUFPLFFBQVEsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDMUM7Ozs7Ozs7SUFHTyxhQUFhLENBQ25CLE9BQWtDLEVBQ2xDLE9BQWdDOzs7Y0FHMUIsd0JBQXdCLEdBQUcsT0FBTyxLQUFLLFFBQVEsSUFBSSxPQUFPLEtBQUssT0FBTzs7Y0FDdEUsc0JBQXNCLEdBQUcsT0FBTyxLQUFLLE9BQU8sSUFBSSxPQUFPLEtBQUssT0FBTzs7OztjQUluRSw0QkFBNEIsR0FDaEMsd0JBQXdCO1lBQ3RCLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQztZQUM3QyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUM7O2NBQ2pCLDBCQUEwQixHQUM5QixzQkFBc0I7WUFDcEIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDO1lBQzVDLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQzs7O2NBR2hCLFNBQVMsR0FBNkIsRUFBRTtRQUM5QyxzQkFBc0IsQ0FBQyxPQUFPLEVBQUUsNEJBQTRCLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNyRSxzQkFBc0IsQ0FBQyxPQUFPLEVBQUUsMEJBQTBCLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDbkUsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDbkMsQ0FBQyxDQUFDO1NBQ0osQ0FBQyxDQUFDOztRQUdILE9BQU8sU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQzdDOzs7WUExWUYsVUFBVTs7OztZQXBDVCxPQUFPO1lBVFAsTUFBTTtZQWVDLGNBQWMsdUJBd0VsQixRQUFROzs7Ozs7OztBQXFXYixTQUFTLFdBQVcsQ0FDbEIsQ0FBNEIsRUFDNUIsQ0FBMEI7VUFFcEIsRUFBQyxPQUFPLEVBQUUsUUFBUSxFQUFDLEdBQUcsOEJBQThCLENBQUMsQ0FBQyxDQUFDO1VBQ3ZELEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBQyxHQUFHLDRCQUE0QixDQUFDLENBQUMsQ0FBQztJQUMzRCxPQUFPLElBQUksc0JBQXNCLENBQUMsRUFBQyxPQUFPLEVBQUUsT0FBTyxFQUFDLEVBQUUsRUFBQyxRQUFRLEVBQUUsUUFBUSxFQUFDLENBQUMsQ0FBQztDQUM3RTs7Ozs7O0FBR0QsU0FBUyw2QkFBNkIsQ0FBQyxDQUEwQjtJQUMvRCxJQUFJLENBQUMsS0FBSyxPQUFPLEVBQUU7UUFDakIsT0FBTyxPQUFPLENBQUM7S0FDaEI7SUFFRCxJQUFJLENBQUMsS0FBSyxLQUFLLEVBQUU7UUFDZixPQUFPLFFBQVEsQ0FBQztLQUNqQjtJQUVELE9BQU8sUUFBUSxDQUFDO0NBQ2pCOzs7Ozs7QUFHRCxTQUFTLDJCQUEyQixDQUFDLENBQXdCO0lBQzNELElBQUksQ0FBQyxLQUFLLEtBQUssRUFBRTtRQUNmLE9BQU8sT0FBTyxDQUFDO0tBQ2hCO0lBRUQsSUFBSSxDQUFDLEtBQUssUUFBUSxFQUFFO1FBQ2xCLE9BQU8sT0FBTyxDQUFDO0tBQ2hCO0lBRUQsT0FBTyxRQUFRLENBQUM7Q0FDakI7Ozs7OztBQUdELFNBQVMsOEJBQThCLENBQUMsQ0FBNEI7SUFFbEUsUUFBUSxDQUFDO1FBQ1AsS0FBSyxRQUFRO1lBQ1gsT0FBTyxFQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBQyxDQUFDO1FBQzdDLEtBQUssT0FBTztZQUNWLE9BQU8sRUFBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUMsQ0FBQztRQUMvQyxLQUFLLEtBQUs7WUFDUixPQUFPLEVBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFDLENBQUM7UUFDM0MsS0FBSyxPQUFPO1lBQ1YsT0FBTyxFQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBQyxDQUFDO1FBQzdDO1lBQ0UsT0FBTyxFQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBQyxDQUFDO0tBQ2xEO0NBQ0Y7Ozs7OztBQUdELFNBQVMsNEJBQTRCLENBQUMsQ0FBMEI7SUFFOUQsUUFBUSxDQUFDO1FBQ1AsS0FBSyxPQUFPO1lBQ1YsT0FBTyxFQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBQyxDQUFDO1FBQzlDLEtBQUssT0FBTztZQUNWLE9BQU8sRUFBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUMsQ0FBQztRQUMzQyxLQUFLLEtBQUs7WUFDUixPQUFPLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFDLENBQUM7UUFDakQsS0FBSyxPQUFPO1lBQ1YsT0FBTyxFQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBQyxDQUFDO1FBQzlDO1lBQ0UsT0FBTyxFQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBQyxDQUFDO0tBQ2xEO0NBQ0Y7Ozs7Ozs7Ozs7Ozs7QUFXRCxTQUFTLHNCQUFzQixDQUFJLE1BQVMsRUFBRSxPQUFZOztVQUNsRCxXQUFXLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7OztVQUdyQyxTQUFTLEdBQUcsQ0FBQyxNQUFNLENBQUM7OztVQUdwQixJQUFJLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDOztVQUNwQyxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLEdBQUcsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUU7O0lBR3RFLE9BQU8sSUFBSSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQ2xDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDNUIsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztLQUM1Qjs7SUFHRCxPQUFPLEtBQUssQ0FBQyxNQUFNLEVBQUU7UUFDbkIsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztLQUM3Qjs7SUFHRCxPQUFPLElBQUksQ0FBQyxNQUFNLEVBQUU7UUFDbEIsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztLQUM1QjtJQUVELE9BQU8sU0FBUyxDQUFDO0NBQ2xCOzs7Ozs7QUN4aUJELE1BdUJhLGdCQUFnQjs7Ozs7O0lBc0IzQixZQUNVLFdBQXVCLEVBQ3ZCLGlCQUFtQyxFQUNwQyxVQUFzQztRQUZyQyxnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUN2QixzQkFBaUIsR0FBakIsaUJBQWlCLENBQWtCO1FBQ3BDLGVBQVUsR0FBVixVQUFVLENBQTRCOzs7O1FBWHJDLGtCQUFhLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQzs7OztRQUd6QyxrQkFBYSxHQUFHLElBQUksWUFBWSxFQUFPLENBQUM7Ozs7UUFHMUMsZUFBVSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7S0FNcEM7Ozs7O0lBdkJMLElBQ0ksZUFBZSxLQUFLLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7Ozs7O0lBQ3ZELElBQUksZUFBZSxDQUFDLEtBQWlCO1FBQ25DLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDOztRQUU5QixJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDeEY7Ozs7SUFrQkQsUUFBUTs7O2NBRUEsT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYTthQUMxQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDOztjQUN2QyxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhO2FBQzFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDckQsS0FBSyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO0tBQ3RFOzs7O0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUM1Qjs7Ozs7SUFHRCxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxDQUFDO0tBQ3hDOzs7OztJQUdELGFBQWE7UUFDWCxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxDQUFDO0tBQ2pDOzs7Ozs7SUFHRCxXQUFXLENBQUMsVUFBaUMsRUFBRTtRQUM3QyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUN0Qzs7Ozs7O0lBR0QsWUFBWSxDQUFDLEtBQVc7UUFDdEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDckM7Ozs7O0lBR0QsY0FBYztRQUNaLElBQUksQ0FBQyxVQUFVLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztLQUMxQzs7Ozs7SUFHRCxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0tBQ3pCOzs7Ozs7SUFHTyx3QkFBd0IsQ0FBQyxPQUFtQjtRQUNsRCxJQUFJLENBQUMsT0FBTyxJQUFJLEVBQUUsT0FBTyxZQUFZLFVBQVUsQ0FBQyxFQUFFO1lBQ2hELE1BQU0sc0JBQXNCLEVBQUUsQ0FBQztTQUNoQztLQUNGOzs7WUFsRkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSx1QkFBdUI7Z0JBQ2pDLFFBQVEsRUFBRSxrQkFBa0I7Z0JBQzVCLFNBQVMsRUFBRSxDQUFDLDBCQUEwQixDQUFDO2FBQ3hDOzs7O1lBcEJDLFVBQVU7WUFNVixnQkFBZ0I7WUFPVCwwQkFBMEI7Ozs4QkFXaEMsS0FBSyxTQUFDLHFCQUFxQjs0QkFXM0IsTUFBTTs0QkFHTixNQUFNOzs7Ozs7O0FDeENULE1BVWEsd0JBQXdCOzs7O0lBcUJuQyxZQUFtQixNQUF3QjtRQUF4QixXQUFNLEdBQU4sTUFBTSxDQUFrQjtRQVhuQyxxQkFBZ0IsR0FBRyxDQUFDLENBQUM7Ozs7UUFHckIsZUFBVSxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7Ozs7UUFHM0Isa0JBQWEsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDOzs7O1FBR3BDLGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztLQUVJOzs7Ozs7SUFoQmhELElBQ0ksZUFBZSxLQUFLLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7Ozs7O0lBQ3ZELElBQUksZUFBZSxDQUFDLEdBQVc7UUFDN0IsSUFBSSxDQUFDLGdCQUFnQixHQUFHLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ25EOzs7O0lBY0QsZUFBZTs7OztRQUliLElBQUksQ0FBQyxhQUFhO2FBQ2YsSUFBSSxDQUNILFNBQVMsQ0FBQztZQUNSLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FDbEIsS0FBSyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLENBQUMsRUFDakMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FDOUIsQ0FBQztTQUNILENBQUMsRUFDRixTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUMzQjthQUNBLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztLQUMvQzs7OztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDNUI7Ozs7SUFHRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztLQUMzQjs7OztJQUdELFlBQVk7UUFDVixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7S0FDNUI7OztZQXpERixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLG1CQUFtQjthQUM5Qjs7OztZQUpRLGdCQUFnQjs7OzhCQVV0QixLQUFLOzBCQXdDTCxZQUFZLFNBQUMsWUFBWTsyQkFLekIsWUFBWSxTQUFDLFlBQVk7Ozs7Ozs7QUM1RDVCLE1BNkJhLGdCQUFnQjs7O1lBbkI1QixRQUFRLFNBQUM7Z0JBQ1IsT0FBTyxFQUFFO29CQUNQLFlBQVk7b0JBQ1osYUFBYTtvQkFDYixVQUFVO29CQUNWLFVBQVU7aUJBQ1g7Z0JBQ0QsWUFBWSxFQUFFO29CQUNaLFVBQVU7b0JBQ1YsZ0JBQWdCO29CQUNoQix3QkFBd0I7aUJBQ3pCO2dCQUNELE9BQU8sRUFBRTtvQkFDUCxVQUFVO29CQUNWLGdCQUFnQjtvQkFDaEIsd0JBQXdCO29CQUN4QixVQUFVO2lCQUNYO2FBQ0Y7Ozs7Ozs7Ozs7Ozs7OzsifQ==