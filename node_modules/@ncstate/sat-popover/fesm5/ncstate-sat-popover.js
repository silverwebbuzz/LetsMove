import { trigger, style, animate, transition } from '@angular/animations';
import { Injectable, Component, ElementRef, EventEmitter, Inject, Input, ViewChild, ViewEncapsulation, TemplateRef, Optional, Output, NgZone, Directive, ViewContainerRef, HostListener, NgModule } from '@angular/core';
import { Subject, merge, of } from 'rxjs';
import { DOCUMENT, CommonModule } from '@angular/common';
import { FocusTrapFactory, A11yModule } from '@angular/cdk/a11y';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { __spread } from 'tslib';
import { ConnectionPositionPair, Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { ESCAPE } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import { takeUntil, take, filter, tap, delay, switchMap } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
var transformPopover = trigger('transformPopover', [
    transition(':enter', [
        style({ opacity: 0, transform: 'scale(0.3)' }),
        animate('{{openTransition}}', style({ opacity: 1, transform: 'scale(1)' }))
    ]),
    transition(':leave', [
        animate('{{closeTransition}}', style({ opacity: 0, transform: 'scale(0.5)' }))
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @enum {number} */
var NotificationAction = {
    /** Popover should open. */
    OPEN: 0,
    /** Popover should close. */
    CLOSE: 1,
    /** Popover should toggle open or closed. */
    TOGGLE: 2,
    /** Popover has new target positions. */
    REPOSITION: 3,
    /** Popover needs new configuration. */
    UPDATE_CONFIG: 4,
    /** Popover should realign itself to the anchor.  */
    REALIGN: 5,
};
NotificationAction[NotificationAction.OPEN] = 'OPEN';
NotificationAction[NotificationAction.CLOSE] = 'CLOSE';
NotificationAction[NotificationAction.TOGGLE] = 'TOGGLE';
NotificationAction[NotificationAction.REPOSITION] = 'REPOSITION';
NotificationAction[NotificationAction.UPDATE_CONFIG] = 'UPDATE_CONFIG';
NotificationAction[NotificationAction.REALIGN] = 'REALIGN';
/**
 * Event object for dispatching to anchoring service.
 */
var /**
 * Event object for dispatching to anchoring service.
 */
PopoverNotification = /** @class */ (function () {
    function PopoverNotification(action, value) {
        this.action = action;
        this.value = value;
    }
    return PopoverNotification;
}());
var PopoverNotificationService = /** @class */ (function () {
    function PopoverNotificationService() {
        this.store = new Subject();
    }
    /** Dispatch a notification to all subscribers. */
    /**
     * Dispatch a notification to all subscribers.
     * @param {?} notification
     * @return {?}
     */
    PopoverNotificationService.prototype.dispatch = /**
     * Dispatch a notification to all subscribers.
     * @param {?} notification
     * @return {?}
     */
    function (notification) {
        this.store.next(notification);
    };
    /** Stream of notification events. */
    /**
     * Stream of notification events.
     * @return {?}
     */
    PopoverNotificationService.prototype.events = /**
     * Stream of notification events.
     * @return {?}
     */
    function () {
        return this.store.asObservable();
    };
    /** Complete event stream. */
    /**
     * Complete event stream.
     * @return {?}
     */
    PopoverNotificationService.prototype.dispose = /**
     * Complete event stream.
     * @return {?}
     */
    function () {
        this.store.complete();
    };
    PopoverNotificationService.decorators = [
        { type: Injectable }
    ];
    return PopoverNotificationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
var VALID_SCROLL = [
    'noop',
    'block',
    'reposition',
    'close'
];
/** @type {?} */
var VALID_HORIZ_ALIGN = [
    'before',
    'start',
    'center',
    'end',
    'after'
];
/** @type {?} */
var VALID_VERT_ALIGN = [
    'above',
    'start',
    'center',
    'end',
    'below'
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getInvalidPopoverError() {
    return Error('SatPopoverAnchor must be provided an SatPopover component instance.');
}
/**
 * @return {?}
 */
function getUnanchoredPopoverError() {
    return Error('SatPopover is not anchored to any SatPopoverAnchor.');
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidHorizontalAlignError(alignment) {
    return Error(generateGenericError('horizontalAlign/xAlign', alignment, VALID_HORIZ_ALIGN));
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidVerticalAlignError(alignment) {
    return Error(generateGenericError('verticalAlign/yAlign', alignment, VALID_VERT_ALIGN));
}
/**
 * @param {?} strategy
 * @return {?}
 */
function getInvalidScrollStrategyError(strategy) {
    return Error(generateGenericError('scrollStrategy', strategy, VALID_SCROLL));
}
/**
 * @param {?} apiName
 * @param {?} invalid
 * @param {?} valid
 * @return {?}
 */
function generateGenericError(apiName, invalid, valid) {
    return "Invalid " + apiName + ": '" + invalid + "'. Valid options are " +
        (valid.map(function (v) { return "'" + v + "'"; }).join(', ') + ".");
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
/** @type {?} */
var DEFAULT_TRANSITION = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';
var SatPopover = /** @class */ (function () {
    function SatPopover(_focusTrapFactory, _document) {
        this._focusTrapFactory = _focusTrapFactory;
        this._document = _document;
        this._horizontalAlign = 'center';
        this._verticalAlign = 'center';
        this._forceAlignment = false;
        this._lockAlignment = false;
        this._autoFocus = true;
        this._autoFocusOverride = true;
        this._restoreFocus = true;
        this._restoreFocusOverride = true;
        this._scrollStrategy = 'reposition';
        this._hasBackdrop = false;
        this._interactiveClose = true;
        this._openTransition = DEFAULT_TRANSITION;
        this._closeTransition = DEFAULT_TRANSITION;
        /**
         * Optional backdrop class.
         */
        this.backdropClass = '';
        /**
         * Emits when the popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Emits when the popover has finished opening.
         */
        this.afterOpen = new EventEmitter();
        /**
         * Emits when the popover has finished closing.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits when the backdrop is clicked.
         */
        this.backdropClicked = new EventEmitter();
        /**
         * Emits when a keydown event is targeted to this popover's overlay.
         */
        this.overlayKeydown = new EventEmitter();
        /**
         * Classes to be added to the popover for setting the correct transform origin.
         */
        this._classList = {};
        /**
         * Whether the popover is presently open.
         */
        this._open = false;
    }
    Object.defineProperty(SatPopover.prototype, "horizontalAlign", {
        /** Alignment of the popover on the horizontal axis. */
        get: /**
         * Alignment of the popover on the horizontal axis.
         * @return {?}
         */
        function () { return this._horizontalAlign; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateHorizontalAlign(val);
            if (this._horizontalAlign !== val) {
                this._horizontalAlign = val;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "xAlign", {
        /** Alignment of the popover on the x axis. Alias for `horizontalAlign`. */
        get: /**
         * Alignment of the popover on the x axis. Alias for `horizontalAlign`.
         * @return {?}
         */
        function () { return this.horizontalAlign; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) { this.horizontalAlign = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "verticalAlign", {
        /** Alignment of the popover on the vertical axis. */
        get: /**
         * Alignment of the popover on the vertical axis.
         * @return {?}
         */
        function () { return this._verticalAlign; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateVerticalAlign(val);
            if (this._verticalAlign !== val) {
                this._verticalAlign = val;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "yAlign", {
        /** Alignment of the popover on the y axis. Alias for `verticalAlign`. */
        get: /**
         * Alignment of the popover on the y axis. Alias for `verticalAlign`.
         * @return {?}
         */
        function () { return this.verticalAlign; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) { this.verticalAlign = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "forceAlignment", {
        /** Whether the popover always opens with the specified alignment. */
        get: /**
         * Whether the popover always opens with the specified alignment.
         * @return {?}
         */
        function () { return this._forceAlignment; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var coercedVal = coerceBooleanProperty(val);
            if (this._forceAlignment !== coercedVal) {
                this._forceAlignment = coercedVal;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "lockAlignment", {
        /**
         * Whether the popover's alignment is locked after opening. This prevents the popover
         * from changing its alignement when scrolling or changing the size of the viewport.
         */
        get: /**
         * Whether the popover's alignment is locked after opening. This prevents the popover
         * from changing its alignement when scrolling or changing the size of the viewport.
         * @return {?}
         */
        function () { return this._lockAlignment; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var coercedVal = coerceBooleanProperty(val);
            if (this._lockAlignment !== coercedVal) {
                this._lockAlignment = coerceBooleanProperty(val);
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "autoFocus", {
        /** Whether the first focusable element should be focused on open. */
        get: /**
         * Whether the first focusable element should be focused on open.
         * @return {?}
         */
        function () { return this._autoFocus && this._autoFocusOverride; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._autoFocus = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "restoreFocus", {
        /** Whether the popover should return focus to the previously focused element after closing. */
        get: /**
         * Whether the popover should return focus to the previously focused element after closing.
         * @return {?}
         */
        function () { return this._restoreFocus && this._restoreFocusOverride; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._restoreFocus = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "scrollStrategy", {
        /** How the popover should handle scrolling. */
        get: /**
         * How the popover should handle scrolling.
         * @return {?}
         */
        function () { return this._scrollStrategy; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateScrollStrategy(val);
            if (this._scrollStrategy !== val) {
                this._scrollStrategy = val;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "hasBackdrop", {
        /** Whether the popover should have a backdrop (includes closing on click). */
        get: /**
         * Whether the popover should have a backdrop (includes closing on click).
         * @return {?}
         */
        function () { return this._hasBackdrop; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._hasBackdrop = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "interactiveClose", {
        /** Whether the popover should close when the user clicks the backdrop or presses ESC. */
        get: /**
         * Whether the popover should close when the user clicks the backdrop or presses ESC.
         * @return {?}
         */
        function () { return this._interactiveClose; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._interactiveClose = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "openTransition", {
        /** Custom transition to use while opening. */
        get: /**
         * Custom transition to use while opening.
         * @return {?}
         */
        function () { return this._openTransition; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._openTransition = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "closeTransition", {
        /** Custom transition to use while closing. */
        get: /**
         * Custom transition to use while closing.
         * @return {?}
         */
        function () { return this._closeTransition; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._closeTransition = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SatPopover.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._setAlignmentClasses();
    };
    /**
     * @return {?}
     */
    SatPopover.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._notifications) {
            this._notifications.dispose();
        }
    };
    /** Open this popover. */
    /**
     * Open this popover.
     * @param {?=} options
     * @return {?}
     */
    SatPopover.prototype.open = /**
     * Open this popover.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var notification = new PopoverNotification(NotificationAction.OPEN, options);
        this._dispatchActionNotification(notification);
    };
    /** Close this popover. */
    /**
     * Close this popover.
     * @param {?=} value
     * @return {?}
     */
    SatPopover.prototype.close = /**
     * Close this popover.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var notification = new PopoverNotification(NotificationAction.CLOSE, value);
        this._dispatchActionNotification(notification);
    };
    /** Toggle this popover open or closed. */
    /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    SatPopover.prototype.toggle = /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var notification = new PopoverNotification(NotificationAction.TOGGLE);
        this._dispatchActionNotification(notification);
    };
    /** Realign the popover to the anchor. */
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    SatPopover.prototype.realign = /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var notification = new PopoverNotification(NotificationAction.REALIGN);
        this._dispatchActionNotification(notification);
    };
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    SatPopover.prototype.isOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._open;
    };
    /** Gets an animation config with customized (or default) transition values. */
    /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    SatPopover.prototype._getAnimation = /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    function () {
        return {
            value: 'visible',
            params: { openTransition: this.openTransition, closeTransition: this.closeTransition }
        };
    };
    /** Callback for when the popover is finished animating in or out. */
    /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    SatPopover.prototype._onAnimationDone = /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.toState === 'visible') {
            this._trapFocus();
            this.afterOpen.emit();
        }
        else if (event.toState === 'void') {
            this._restoreFocusAndDestroyTrap();
            this.afterClose.emit();
        }
    };
    /** Apply alignment classes based on alignment inputs. */
    /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    SatPopover.prototype._setAlignmentClasses = /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    function (horizAlign, vertAlign) {
        if (horizAlign === void 0) { horizAlign = this.horizontalAlign; }
        if (vertAlign === void 0) { vertAlign = this.verticalAlign; }
        this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';
        this._classList['sat-popover-after'] = horizAlign === 'after' || horizAlign === 'start';
        this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';
        this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';
        this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';
    };
    /** Move the focus inside the focus trap and remember where to return later. */
    /**
     * Move the focus inside the focus trap and remember where to return later.
     * @return {?}
     */
    SatPopover.prototype._trapFocus = /**
     * Move the focus inside the focus trap and remember where to return later.
     * @return {?}
     */
    function () {
        this._savePreviouslyFocusedElement();
        // There won't be a focus trap element if the close animation starts before open finishes
        if (!this._focusTrapElement) {
            return;
        }
        if (!this._focusTrap && this._focusTrapElement) {
            this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
        }
        if (this.autoFocus) {
            this._focusTrap.focusInitialElementWhenReady();
        }
    };
    /** Restore focus to the element focused before the popover opened. Also destroy trap. */
    /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @return {?}
     */
    SatPopover.prototype._restoreFocusAndDestroyTrap = /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var toFocus = this._previouslyFocusedElement;
        // Must check active element is focusable for IE sake
        if (toFocus && 'focus' in toFocus && this.restoreFocus) {
            this._previouslyFocusedElement.focus();
        }
        this._previouslyFocusedElement = null;
        if (this._focusTrap) {
            this._focusTrap.destroy();
            this._focusTrap = undefined;
        }
    };
    /** Save a reference to the element focused before the popover was opened. */
    /**
     * Save a reference to the element focused before the popover was opened.
     * @return {?}
     */
    SatPopover.prototype._savePreviouslyFocusedElement = /**
     * Save a reference to the element focused before the popover was opened.
     * @return {?}
     */
    function () {
        if (this._document) {
            this._previouslyFocusedElement = (/** @type {?} */ (this._document.activeElement));
        }
    };
    /** Dispatch a notification to the notification service, if possible. */
    /**
     * Dispatch a notification to the notification service, if possible.
     * @param {?} notification
     * @return {?}
     */
    SatPopover.prototype._dispatchConfigNotification = /**
     * Dispatch a notification to the notification service, if possible.
     * @param {?} notification
     * @return {?}
     */
    function (notification) {
        if (this._notifications) {
            this._notifications.dispatch(notification);
        }
    };
    /** Dispatch a notification to the notification service and throw if unable to. */
    /**
     * Dispatch a notification to the notification service and throw if unable to.
     * @param {?} notification
     * @return {?}
     */
    SatPopover.prototype._dispatchActionNotification = /**
     * Dispatch a notification to the notification service and throw if unable to.
     * @param {?} notification
     * @return {?}
     */
    function (notification) {
        if (!this._notifications) {
            throw getUnanchoredPopoverError();
        }
        this._notifications.dispatch(notification);
    };
    /** Throws an error if the alignment is not a valid horizontalAlign. */
    /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @param {?} pos
     * @return {?}
     */
    SatPopover.prototype._validateHorizontalAlign = /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
            throw getInvalidHorizontalAlignError(pos);
        }
    };
    /** Throws an error if the alignment is not a valid verticalAlign. */
    /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @param {?} pos
     * @return {?}
     */
    SatPopover.prototype._validateVerticalAlign = /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
            throw getInvalidVerticalAlignError(pos);
        }
    };
    /** Throws an error if the scroll strategy is not a valid strategy. */
    /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @param {?} strategy
     * @return {?}
     */
    SatPopover.prototype._validateScrollStrategy = /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        if (VALID_SCROLL.indexOf(strategy) === -1) {
            throw getInvalidScrollStrategyError(strategy);
        }
    };
    SatPopover.decorators = [
        { type: Component, args: [{
                    selector: 'sat-popover',
                    encapsulation: ViewEncapsulation.None,
                    animations: [transformPopover],
                    template: "<ng-template>\n  <div class=\"sat-popover-container\"\n      #focusTrapElement\n      [ngClass]=\"_classList\"\n      [@transformPopover]=\"_getAnimation()\"\n      (@transformPopover.done)=\"_onAnimationDone($event)\">\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n",
                    styles: [".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}.sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .sat-popover-container.sat-popover-before.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}.sat-popover-container.sat-popover-center.sat-popover-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.sat-popover-container.sat-popover-center.sat-popover-below{-webkit-transform-origin:center top;transform-origin:center top}.sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-center{-webkit-transform-origin:right center;transform-origin:right center}.sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .sat-popover-container.sat-popover-after.sat-popover-below{-webkit-transform-origin:right top;transform-origin:right top}"]
                }] }
    ];
    /** @nocollapse */
    SatPopover.ctorParameters = function () { return [
        { type: FocusTrapFactory },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
    ]; };
    SatPopover.propDecorators = {
        horizontalAlign: [{ type: Input }],
        xAlign: [{ type: Input }],
        verticalAlign: [{ type: Input }],
        yAlign: [{ type: Input }],
        forceAlignment: [{ type: Input }],
        lockAlignment: [{ type: Input }],
        autoFocus: [{ type: Input }],
        restoreFocus: [{ type: Input }],
        scrollStrategy: [{ type: Input }],
        hasBackdrop: [{ type: Input }],
        interactiveClose: [{ type: Input }],
        openTransition: [{ type: Input }],
        closeTransition: [{ type: Input }],
        backdropClass: [{ type: Input }],
        opened: [{ type: Output }],
        closed: [{ type: Output }],
        afterOpen: [{ type: Output }],
        afterClose: [{ type: Output }],
        backdropClicked: [{ type: Output }],
        overlayKeydown: [{ type: Output }],
        _templateRef: [{ type: ViewChild, args: [TemplateRef,] }],
        _focusTrapElement: [{ type: ViewChild, args: ['focusTrapElement',] }]
    };
    return SatPopover;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var SatPopoverAnchoringService = /** @class */ (function () {
    function SatPopoverAnchoringService(_overlay, _ngZone, _dir) {
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new Subject();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new Subject();
        /**
         * Whether the popover is presently open.
         */
        this._popoverOpen = false;
        /**
         * Emits when the service is destroyed.
         */
        this._onDestroy = new Subject();
    }
    /**
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // Destroy popover before terminating subscriptions so that any resulting
        // detachments update 'closed state'
        this._destroyPopover();
        // Terminate subscriptions
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._onDestroy.next();
        this._onDestroy.complete();
        this.popoverOpened.complete();
        this.popoverClosed.complete();
    };
    /** Anchor a popover instance to a view and connection element. */
    /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.anchor = /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    function (popover, viewContainerRef, anchor) {
        // Destroy any previous popovers
        this._destroyPopover();
        // Assign local refs
        this._popover = popover;
        this._viewContainerRef = viewContainerRef;
        this._anchor = anchor;
        // Provide notification service as a communication channel between popover and anchor.
        // Then subscribe to notifications to take appropriate actions.
        this._popover._notifications = this._notifications = new PopoverNotificationService();
        this._subscribeToNotifications();
    };
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.isPopoverOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._popoverOpen;
    };
    /** Toggles the popover between the open and closed states. */
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.togglePopover = /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    function () {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    };
    /** Opens the popover. */
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.openPopover = /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        if (!this._popoverOpen) {
            this._applyOpenOptions(options);
            this._createOverlay();
            this._subscribeToBackdrop();
            this._subscribeToEscape();
            this._subscribeToDetachments();
            this._saveOpenedState();
        }
    };
    /** Closes the popover. */
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.closePopover = /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._overlayRef) {
            this._saveClosedState(value);
            this._overlayRef.detach();
        }
    };
    /** Realign the popover to the anchor. */
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.realignPopoverToAnchor = /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            /** @type {?} */
            var config = this._overlayRef.getConfig();
            /** @type {?} */
            var strategy = (/** @type {?} */ (config.positionStrategy));
            strategy.reapplyLastPosition();
        }
    };
    /** Get a reference to the anchor element. */
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype.getAnchorElement = /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    function () {
        return this._anchor;
    };
    /** Apply behavior properties on the popover based on the open options. */
    /**
     * Apply behavior properties on the popover based on the open options.
     * @param {?} options
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._applyOpenOptions = /**
     * Apply behavior properties on the popover based on the open options.
     * @param {?} options
     * @return {?}
     */
    function (options) {
        // Only override restoreFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        var restoreFocus = options.restoreFocus !== false;
        this._popover._restoreFocusOverride = restoreFocus;
        // Only override autoFocus as `false` if the option is explicitly `false`
        /** @type {?} */
        var autoFocus = options.autoFocus !== false;
        this._popover._autoFocusOverride = autoFocus;
    };
    /** Create an overlay to be attached to the portal. */
    /**
     * Create an overlay to be attached to the portal.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._createOverlay = /**
     * Create an overlay to be attached to the portal.
     * @return {?}
     */
    function () {
        // Create overlay if it doesn't yet exist
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);
            /** @type {?} */
            var popoverConfig = {
                horizontalAlign: this._popover.horizontalAlign,
                verticalAlign: this._popover.verticalAlign,
                hasBackdrop: this._popover.hasBackdrop,
                backdropClass: this._popover.backdropClass,
                scrollStrategy: this._popover.scrollStrategy,
                forceAlignment: this._popover.forceAlignment,
                lockAlignment: this._popover.lockAlignment,
            };
            /** @type {?} */
            var overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
            this._subscribeToPositionChanges((/** @type {?} */ (overlayConfig.positionStrategy)));
            this._overlayRef = this._overlay.create(overlayConfig);
        }
        // Actually open the popover
        this._overlayRef.attach(this._portal);
        return this._overlayRef;
    };
    /** Removes the popover from the DOM. Does NOT update open state. */
    /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._destroyPopover = /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    };
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     */
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._destroyPopoverOnceClosed = /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isPopoverOpen() && this._overlayRef) {
            this._overlayRef.detachments().pipe(take(1), takeUntil(this._onDestroy)).subscribe(function () { return _this._destroyPopover(); });
        }
        else {
            this._destroyPopover();
        }
    };
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     */
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToNotifications = /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        this._notificationsSubscription = this._notifications.events()
            .subscribe(function (event) {
            switch (event.action) {
                case NotificationAction.OPEN:
                    _this.openPopover(event.value);
                    break;
                case NotificationAction.CLOSE:
                    _this.closePopover(event.value);
                    break;
                case NotificationAction.TOGGLE:
                    _this.togglePopover();
                    break;
                case NotificationAction.REPOSITION:
                // TODO: When the overlay's position can be dynamically changed, do not destroy
                case NotificationAction.UPDATE_CONFIG:
                    _this._destroyPopoverOnceClosed();
                    break;
                case NotificationAction.REALIGN:
                    _this.realignPopoverToAnchor();
                    break;
            }
        });
    };
    /** Close popover when backdrop is clicked. */
    /**
     * Close popover when backdrop is clicked.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToBackdrop = /**
     * Close popover when backdrop is clicked.
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .backdropClick()
            .pipe(tap(function () { return _this._popover.backdropClicked.emit(); }), filter(function () { return _this._popover.interactiveClose; }), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe(function () { return _this.closePopover(); });
    };
    /** Close popover when escape keydown event occurs. */
    /**
     * Close popover when escape keydown event occurs.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToEscape = /**
     * Close popover when escape keydown event occurs.
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .keydownEvents()
            .pipe(tap(function (event) { return _this._popover.overlayKeydown.emit(event); }), filter(function (event) { return event.keyCode === ESCAPE; }), filter(function () { return _this._popover.interactiveClose; }), takeUntil(this.popoverClosed), takeUntil(this._onDestroy))
            .subscribe(function () { return _this.closePopover(); });
    };
    /** Set state back to closed when detached. */
    /**
     * Set state back to closed when detached.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToDetachments = /**
     * Set state back to closed when detached.
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .detachments()
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function () { return _this._saveClosedState(); });
    };
    /** Save the opened state of the popover and emit. */
    /**
     * Save the opened state of the popover and emit.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._saveOpenedState = /**
     * Save the opened state of the popover and emit.
     * @return {?}
     */
    function () {
        if (!this._popoverOpen) {
            this._popover._open = this._popoverOpen = true;
            this.popoverOpened.next();
            this._popover.opened.emit();
        }
    };
    /** Save the closed state of the popover and emit. */
    /**
     * Save the closed state of the popover and emit.
     * @param {?=} value
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._saveClosedState = /**
     * Save the closed state of the popover and emit.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._popoverOpen) {
            this._popover._open = this._popoverOpen = false;
            this.popoverClosed.next(value);
            this._popover.closed.emit(value);
        }
    };
    /** Gets the text direction of the containing app. */
    /**
     * Gets the text direction of the containing app.
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getDirection = /**
     * Gets the text direction of the containing app.
     * @return {?}
     */
    function () {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    };
    /** Create and return a config for creating the overlay. */
    /**
     * Create and return a config for creating the overlay.
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getOverlayConfig = /**
     * Create and return a config for creating the overlay.
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    function (config, anchor) {
        return new OverlayConfig({
            positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor),
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
            direction: this._getDirection(),
        });
    };
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     */
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @param {?} position
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._subscribeToPositionChanges = /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._positionChangeSubscription = position.positionChanges
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function (change) {
            // Position changes may occur outside the Angular zone
            _this._ngZone.run(function () {
                _this._popover._setAlignmentClasses(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
            });
        });
    };
    /** Map a scroll strategy string type to an instance of a scroll strategy. */
    /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @param {?} strategy
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getScrollStrategyInstance = /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        switch (strategy) {
            case 'block':
                return this._overlay.scrollStrategies.block();
            case 'reposition':
                return this._overlay.scrollStrategies.reposition();
            case 'close':
                return this._overlay.scrollStrategies.close();
            case 'noop':
            default:
                return this._overlay.scrollStrategies.noop();
        }
    };
    /** Create and return a position strategy based on config provided to the component instance. */
    /**
     * Create and return a position strategy based on config provided to the component instance.
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getPositionStrategy = /**
     * Create and return a position strategy based on config provided to the component instance.
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    function (horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
        // Attach the overlay at the preferred position
        /** @type {?} */
        var targetPosition = getPosition(horizontalTarget, verticalTarget);
        /** @type {?} */
        var positions = [targetPosition];
        /** @type {?} */
        var strategy = this._overlay.position()
            .flexibleConnectedTo(anchor)
            .withFlexibleDimensions(false)
            .withPush(false)
            .withViewportMargin(0)
            .withLockedPosition(lockAlignment);
        // Unless the alignment is forced, add fallbacks based on the preferred positions
        if (!forceAlignment) {
            /** @type {?} */
            var fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
            positions.push.apply(positions, __spread(fallbacks));
        }
        return strategy.withPositions(positions);
    };
    /** Get fallback positions based around target alignments. */
    /**
     * Get fallback positions based around target alignments.
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    SatPopoverAnchoringService.prototype._getFallbacks = /**
     * Get fallback positions based around target alignments.
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    function (hTarget, vTarget) {
        // Determine if the target alignments overlap the anchor
        /** @type {?} */
        var horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
        /** @type {?} */
        var verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
        // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
        // cover the anchor
        /** @type {?} */
        var possibleHorizontalAlignments = horizontalOverlapAllowed ?
            ['before', 'start', 'center', 'end', 'after'] :
            ['before', 'after'];
        /** @type {?} */
        var possibleVerticalAlignments = verticalOverlapAllowed ?
            ['above', 'start', 'center', 'end', 'below'] :
            ['above', 'below'];
        // Create fallbacks for each allowed prioritized fallback alignment combo
        /** @type {?} */
        var fallbacks = [];
        prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach(function (h) {
            prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach(function (v) {
                fallbacks.push(getPosition(h, v));
            });
        });
        // Remove the first item since it will be the target alignment and isn't considered a fallback
        return fallbacks.slice(1, fallbacks.length);
    };
    SatPopoverAnchoringService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    SatPopoverAnchoringService.ctorParameters = function () { return [
        { type: Overlay },
        { type: NgZone },
        { type: Directionality, decorators: [{ type: Optional }] }
    ]; };
    return SatPopoverAnchoringService;
}());
/**
 * Helper function to get a cdk position pair from SatPopover alignments.
 * @param {?} h
 * @param {?} v
 * @return {?}
 */
function getPosition(h, v) {
    var _a = getHorizontalConnectionPosPair(h), originX = _a.originX, overlayX = _a.overlayX;
    var _b = getVerticalConnectionPosPair(v), originY = _b.originY, overlayY = _b.overlayY;
    return new ConnectionPositionPair({ originX: originX, originY: originY }, { overlayX: overlayX, overlayY: overlayY });
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
    if (h === 'start') {
        return 'after';
    }
    if (h === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
    if (v === 'top') {
        return 'below';
    }
    if (v === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
    switch (h) {
        case 'before':
            return { originX: 'start', overlayX: 'end' };
        case 'start':
            return { originX: 'start', overlayX: 'start' };
        case 'end':
            return { originX: 'end', overlayX: 'end' };
        case 'after':
            return { originX: 'end', overlayX: 'start' };
        default:
            return { originX: 'center', overlayX: 'center' };
    }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
    switch (v) {
        case 'above':
            return { originY: 'top', overlayY: 'bottom' };
        case 'start':
            return { originY: 'top', overlayY: 'top' };
        case 'end':
            return { originY: 'bottom', overlayY: 'bottom' };
        case 'below':
            return { originY: 'bottom', overlayY: 'top' };
        default:
            return { originY: 'center', overlayY: 'center' };
    }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
    /** @type {?} */
    var targetIndex = options.indexOf(target);
    // Set the first item to be the target
    /** @type {?} */
    var reordered = [target];
    // Make left and right stacks where the highest priority item is last
    /** @type {?} */
    var left = options.slice(0, targetIndex);
    /** @type {?} */
    var right = options.slice(targetIndex + 1, options.length).reverse();
    // Alternate between stacks until one is empty
    while (left.length && right.length) {
        reordered.push(right.pop());
        reordered.push(left.pop());
    }
    // Flush out right side
    while (right.length) {
        reordered.push(right.pop());
    }
    // Flush out left side
    while (left.length) {
        reordered.push(left.pop());
    }
    return reordered;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var SatPopoverAnchor = /** @class */ (function () {
    function SatPopoverAnchor(_elementRef, _viewContainerRef, _anchoring) {
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._anchoring = _anchoring;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new EventEmitter();
        /**
         * Emits when the directive is destroyed.
         */
        this._onDestroy = new Subject();
    }
    Object.defineProperty(SatPopoverAnchor.prototype, "attachedPopover", {
        /** Reference to the popover instance. */
        get: /**
         * Reference to the popover instance.
         * @return {?}
         */
        function () { return this._attachedPopover; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._validateAttachedPopover(value);
            this._attachedPopover = value;
            // Anchor the popover to the element ref
            this._anchoring.anchor(this.attachedPopover, this._viewContainerRef, this._elementRef);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SatPopoverAnchor.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Re-emit open and close events
        /** @type {?} */
        var opened$ = this._anchoring.popoverOpened
            .pipe(tap(function () { return _this.popoverOpened.emit(); }));
        /** @type {?} */
        var closed$ = this._anchoring.popoverClosed
            .pipe(tap(function (value) { return _this.popoverClosed.emit(value); }));
        merge(opened$, closed$).pipe(takeUntil(this._onDestroy)).subscribe();
    };
    /**
     * @return {?}
     */
    SatPopoverAnchor.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    SatPopoverAnchor.prototype.isPopoverOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._anchoring.isPopoverOpen();
    };
    /** Toggles the popover between the open and closed states. */
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    SatPopoverAnchor.prototype.togglePopover = /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    function () {
        this._anchoring.togglePopover();
    };
    /** Opens the popover. */
    /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    SatPopoverAnchor.prototype.openPopover = /**
     * Opens the popover.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        this._anchoring.openPopover(options);
    };
    /** Closes the popover. */
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    SatPopoverAnchor.prototype.closePopover = /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        this._anchoring.closePopover(value);
    };
    /** Realign the popover to the anchor. */
    /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    SatPopoverAnchor.prototype.realignPopover = /**
     * Realign the popover to the anchor.
     * @return {?}
     */
    function () {
        this._anchoring.realignPopoverToAnchor();
    };
    /** Get a reference to the anchor element. */
    /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    SatPopoverAnchor.prototype.getElement = /**
     * Get a reference to the anchor element.
     * @return {?}
     */
    function () {
        return this._elementRef;
    };
    /** Throws an error if the popover instance is not provided. */
    /**
     * Throws an error if the popover instance is not provided.
     * @param {?} popover
     * @return {?}
     */
    SatPopoverAnchor.prototype._validateAttachedPopover = /**
     * Throws an error if the popover instance is not provided.
     * @param {?} popover
     * @return {?}
     */
    function (popover) {
        if (!popover || !(popover instanceof SatPopover)) {
            throw getInvalidPopoverError();
        }
    };
    SatPopoverAnchor.decorators = [
        { type: Directive, args: [{
                    selector: '[satPopoverAnchorFor]',
                    exportAs: 'satPopoverAnchor',
                    providers: [SatPopoverAnchoringService],
                },] }
    ];
    /** @nocollapse */
    SatPopoverAnchor.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: SatPopoverAnchoringService }
    ]; };
    SatPopoverAnchor.propDecorators = {
        attachedPopover: [{ type: Input, args: ['satPopoverAnchorFor',] }],
        popoverOpened: [{ type: Output }],
        popoverClosed: [{ type: Output }]
    };
    return SatPopoverAnchor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var SatPopoverHoverDirective = /** @class */ (function () {
    function SatPopoverHoverDirective(anchor) {
        this.anchor = anchor;
        this._satPopoverHover = 0;
        /**
         * Emits when the directive is destroyed.
         */
        this._onDestroy = new Subject();
        /**
         * Emits when the user's mouse enters the element.
         */
        this._onMouseEnter = new Subject();
        /**
         * Emits when the user's mouse leaves the element.
         */
        this._onMouseLeave = new Subject();
    }
    Object.defineProperty(SatPopoverHoverDirective.prototype, "satPopoverHover", {
        /**
         * Amount of time to delay (ms) after hovering starts before
         * the popover opens. Defaults to 0ms.
         */
        get: /**
         * Amount of time to delay (ms) after hovering starts before
         * the popover opens. Defaults to 0ms.
         * @return {?}
         */
        function () { return this._satPopoverHover; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._satPopoverHover = coerceNumberProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SatPopoverHoverDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Whenever the user hovers this host element, delay the configured
        // amount of time and open the popover. Terminate if the mouse leaves
        // the host element before the delay is complete.
        this._onMouseEnter
            .pipe(switchMap(function () {
            return of(null).pipe(delay(_this._satPopoverHover || 0), takeUntil(_this._onMouseLeave));
        }), takeUntil(this._onDestroy))
            .subscribe(function () { return _this.anchor.openPopover(); });
    };
    /**
     * @return {?}
     */
    SatPopoverHoverDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    /**
     * @return {?}
     */
    SatPopoverHoverDirective.prototype.showPopover = /**
     * @return {?}
     */
    function () {
        this._onMouseEnter.next();
    };
    /**
     * @return {?}
     */
    SatPopoverHoverDirective.prototype.closePopover = /**
     * @return {?}
     */
    function () {
        this._onMouseLeave.next();
        this.anchor.closePopover();
    };
    SatPopoverHoverDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[satPopoverHover]'
                },] }
    ];
    /** @nocollapse */
    SatPopoverHoverDirective.ctorParameters = function () { return [
        { type: SatPopoverAnchor }
    ]; };
    SatPopoverHoverDirective.propDecorators = {
        satPopoverHover: [{ type: Input }],
        showPopover: [{ type: HostListener, args: ['mouseenter',] }],
        closePopover: [{ type: HostListener, args: ['mouseleave',] }]
    };
    return SatPopoverHoverDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var SatPopoverModule = /** @class */ (function () {
    function SatPopoverModule() {
    }
    SatPopoverModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        OverlayModule,
                        A11yModule,
                        BidiModule,
                    ],
                    declarations: [
                        SatPopover,
                        SatPopoverAnchor,
                        SatPopoverHoverDirective,
                    ],
                    exports: [
                        SatPopover,
                        SatPopoverAnchor,
                        SatPopoverHoverDirective,
                        BidiModule,
                    ]
                },] }
    ];
    return SatPopoverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { SatPopoverModule, SatPopoverAnchor, SatPopoverAnchoringService, SatPopover, SatPopoverHoverDirective, transformPopover as a };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmNzdGF0ZS1zYXQtcG9wb3Zlci5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQG5jc3RhdGUvc2F0LXBvcG92ZXIvcG9wb3Zlci9wb3BvdmVyLmFuaW1hdGlvbnMudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvbm90aWZpY2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvdHlwZXMudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci5lcnJvcnMudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci5jb21wb25lbnQudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci1hbmNob3Jpbmcuc2VydmljZS50cyIsIm5nOi8vQG5jc3RhdGUvc2F0LXBvcG92ZXIvcG9wb3Zlci9wb3BvdmVyLWFuY2hvci5kaXJlY3RpdmUudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci1ob3Zlci5kaXJlY3RpdmUudHMiLCJuZzovL0BuY3N0YXRlL3NhdC1wb3BvdmVyL3BvcG92ZXIvcG9wb3Zlci5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgdHJpZ2dlcixcbiAgc3RhdGUsXG4gIHN0eWxlLFxuICBhbmltYXRlLFxuICB0cmFuc2l0aW9uLFxuICBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGFcbn0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1Qb3BvdmVyOiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEgPSB0cmlnZ2VyKCd0cmFuc2Zvcm1Qb3BvdmVyJywgW1xuICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXG4gICAgc3R5bGUoe29wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDAuMyknfSksXG4gICAgYW5pbWF0ZSgne3tvcGVuVHJhbnNpdGlvbn19JyxcbiAgICAgIHN0eWxlKHtvcGFjaXR5OiAxLCB0cmFuc2Zvcm06ICdzY2FsZSgxKSd9KSlcbiAgXSksXG4gIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICBhbmltYXRlKCd7e2Nsb3NlVHJhbnNpdGlvbn19JyxcbiAgICAgIHN0eWxlKHtvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICdzY2FsZSgwLjUpJ30pKVxuICBdKVxuXSk7XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qKiBFbnVtZXJhdGVkIGFjdGlvbnMgZm9yIGEgcG9wb3ZlciB0byBwZXJmb3JtLiAqL1xuZXhwb3J0IGVudW0gTm90aWZpY2F0aW9uQWN0aW9uIHtcbiAgLyoqIFBvcG92ZXIgc2hvdWxkIG9wZW4uICovXG4gIE9QRU4sXG4gIC8qKiBQb3BvdmVyIHNob3VsZCBjbG9zZS4gKi9cbiAgQ0xPU0UsXG4gIC8qKiBQb3BvdmVyIHNob3VsZCB0b2dnbGUgb3BlbiBvciBjbG9zZWQuICovXG4gIFRPR0dMRSxcbiAgLyoqIFBvcG92ZXIgaGFzIG5ldyB0YXJnZXQgcG9zaXRpb25zLiAqL1xuICBSRVBPU0lUSU9OLFxuICAvKiogUG9wb3ZlciBuZWVkcyBuZXcgY29uZmlndXJhdGlvbi4gKi9cbiAgVVBEQVRFX0NPTkZJRyxcbiAgLyoqIFBvcG92ZXIgc2hvdWxkIHJlYWxpZ24gaXRzZWxmIHRvIHRoZSBhbmNob3IuICAqL1xuICBSRUFMSUdOLFxufVxuXG4vKiogRXZlbnQgb2JqZWN0IGZvciBkaXNwYXRjaGluZyB0byBhbmNob3Jpbmcgc2VydmljZS4gKi9cbmV4cG9ydCBjbGFzcyBQb3BvdmVyTm90aWZpY2F0aW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgLyoqIEFjdGlvbiB0byBwZXJmb3JtLiAqL1xuICAgIHB1YmxpYyBhY3Rpb246IE5vdGlmaWNhdGlvbkFjdGlvbixcbiAgICAvKiogT3B0aW9uYWwgcGF5bG9hZC4gKi9cbiAgICBwdWJsaWMgdmFsdWU/OiBhbnlcbiAgKSB7IH1cbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlIHtcblxuICBwcml2YXRlIHN0b3JlID0gbmV3IFN1YmplY3Q8UG9wb3Zlck5vdGlmaWNhdGlvbj4oKTtcblxuICAvKiogRGlzcGF0Y2ggYSBub3RpZmljYXRpb24gdG8gYWxsIHN1YnNjcmliZXJzLiAqL1xuICBkaXNwYXRjaChub3RpZmljYXRpb246IFBvcG92ZXJOb3RpZmljYXRpb24pIHtcbiAgICB0aGlzLnN0b3JlLm5leHQobm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIC8qKiBTdHJlYW0gb2Ygbm90aWZpY2F0aW9uIGV2ZW50cy4gKi9cbiAgZXZlbnRzKCk6IE9ic2VydmFibGU8UG9wb3Zlck5vdGlmaWNhdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqIENvbXBsZXRlIGV2ZW50IHN0cmVhbS4gKi9cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnN0b3JlLmNvbXBsZXRlKCk7XG4gIH1cblxufVxuIiwiZXhwb3J0IHR5cGUgU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5ID0gJ25vb3AnIHwgJ2Jsb2NrJyB8ICdyZXBvc2l0aW9uJyB8ICdjbG9zZSc7XG5leHBvcnQgY29uc3QgVkFMSURfU0NST0xMOiBTYXRQb3BvdmVyU2Nyb2xsU3RyYXRlZ3lbXSA9IFtcbiAgJ25vb3AnLFxuICAnYmxvY2snLFxuICAncmVwb3NpdGlvbicsXG4gICdjbG9zZSdcbl07XG5cbmV4cG9ydCB0eXBlIFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24gPSAnYmVmb3JlJyB8ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnIHwgJ2FmdGVyJztcbmV4cG9ydCBjb25zdCBWQUxJRF9IT1JJWl9BTElHTjogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbltdID0gW1xuICAnYmVmb3JlJyxcbiAgJ3N0YXJ0JyxcbiAgJ2NlbnRlcicsXG4gICdlbmQnLFxuICAnYWZ0ZXInXG5dO1xuXG5leHBvcnQgdHlwZSBTYXRQb3BvdmVyVmVydGljYWxBbGlnbiA9ICdhYm92ZScgIHwgJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgfCAnYmVsb3cnO1xuZXhwb3J0IGNvbnN0IFZBTElEX1ZFUlRfQUxJR046IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduW10gPSBbXG4gICdhYm92ZScsXG4gICdzdGFydCcsXG4gICdjZW50ZXInLFxuICAnZW5kJyxcbiAgJ2JlbG93J1xuXTtcblxuZXhwb3J0IGludGVyZmFjZSBTYXRQb3BvdmVyT3Blbk9wdGlvbnMge1xuICAvKipcbiAgICogV2hldGhlciB0aGUgcG9wb3ZlciBzaG91bGQgcmV0dXJuIGZvY3VzIHRvIHRoZSBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudCBhZnRlclxuICAgKiBjbG9zaW5nLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgKi9cbiAgcmVzdG9yZUZvY3VzPzogYm9vbGVhbjtcblxuICAvKiogV2hldGhlciB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgc2hvdWxkIGJlIGZvY3VzZWQgb24gb3Blbi4gRGVmYXVsdHMgdG8gdHJ1ZS4gKi9cbiAgYXV0b0ZvY3VzPzogYm9vbGVhbjtcbn1cbiIsImltcG9ydCB7IFZBTElEX0hPUklaX0FMSUdOLCBWQUxJRF9WRVJUX0FMSUdOLCBWQUxJRF9TQ1JPTEwgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludmFsaWRQb3BvdmVyRXJyb3IoKTogRXJyb3Ige1xuICByZXR1cm4gRXJyb3IoJ1NhdFBvcG92ZXJBbmNob3IgbXVzdCBiZSBwcm92aWRlZCBhbiBTYXRQb3BvdmVyIGNvbXBvbmVudCBpbnN0YW5jZS4nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuYW5jaG9yZWRQb3BvdmVyRXJyb3IoKTogRXJyb3Ige1xuICByZXR1cm4gRXJyb3IoJ1NhdFBvcG92ZXIgaXMgbm90IGFuY2hvcmVkIHRvIGFueSBTYXRQb3BvdmVyQW5jaG9yLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW52YWxpZEhvcml6b250YWxBbGlnbkVycm9yKGFsaWdubWVudCk6IEVycm9yIHtcbiAgcmV0dXJuIEVycm9yKGdlbmVyYXRlR2VuZXJpY0Vycm9yKCdob3Jpem9udGFsQWxpZ24veEFsaWduJywgYWxpZ25tZW50LCBWQUxJRF9IT1JJWl9BTElHTikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW52YWxpZFZlcnRpY2FsQWxpZ25FcnJvcihhbGlnbm1lbnQpOiBFcnJvciB7XG4gIHJldHVybiBFcnJvcihnZW5lcmF0ZUdlbmVyaWNFcnJvcigndmVydGljYWxBbGlnbi95QWxpZ24nLCBhbGlnbm1lbnQsIFZBTElEX1ZFUlRfQUxJR04pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludmFsaWRTY3JvbGxTdHJhdGVneUVycm9yKHN0cmF0ZWd5KTogRXJyb3Ige1xuICByZXR1cm4gRXJyb3IoZ2VuZXJhdGVHZW5lcmljRXJyb3IoJ3Njcm9sbFN0cmF0ZWd5Jywgc3RyYXRlZ3ksIFZBTElEX1NDUk9MTCkpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUdlbmVyaWNFcnJvcihhcGlOYW1lOiBzdHJpbmcsIGludmFsaWQ6IGFueSwgdmFsaWQ6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBJbnZhbGlkICR7YXBpTmFtZX06ICcke2ludmFsaWR9Jy4gVmFsaWQgb3B0aW9ucyBhcmUgYCArXG4gICAgYCR7dmFsaWQubWFwKHYgPT4gYCcke3Z9J2ApLmpvaW4oJywgJyl9LmA7XG59XG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgVmlld0NoaWxkLFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgVGVtcGxhdGVSZWYsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFuaW1hdGlvbkV2ZW50IH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBGb2N1c1RyYXAsIEZvY3VzVHJhcEZhY3RvcnkgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuXG5pbXBvcnQgeyB0cmFuc2Zvcm1Qb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyLmFuaW1hdGlvbnMnO1xuaW1wb3J0IHtcbiAgTm90aWZpY2F0aW9uQWN0aW9uLFxuICBQb3BvdmVyTm90aWZpY2F0aW9uLFxuICBQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZSxcbn0gZnJvbSAnLi9ub3RpZmljYXRpb24uc2VydmljZSc7XG5pbXBvcnQge1xuICBnZXRVbmFuY2hvcmVkUG9wb3ZlckVycm9yLFxuICBnZXRJbnZhbGlkSG9yaXpvbnRhbEFsaWduRXJyb3IsXG4gIGdldEludmFsaWRWZXJ0aWNhbEFsaWduRXJyb3IsXG4gIGdldEludmFsaWRTY3JvbGxTdHJhdGVneUVycm9yLFxufSBmcm9tICcuL3BvcG92ZXIuZXJyb3JzJztcbmltcG9ydCB7XG4gIFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneSxcbiAgU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbixcbiAgU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24sXG4gIFZBTElEX1NDUk9MTCxcbiAgVkFMSURfSE9SSVpfQUxJR04sXG4gIFZBTElEX1ZFUlRfQUxJR04sXG4gIFNhdFBvcG92ZXJPcGVuT3B0aW9ucyxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIFNlZSBodHRwOi8vY3ViaWMtYmV6aWVyLmNvbS8jLjI1LC44LC4yNSwxIGZvciByZWZlcmVuY2UuXG5jb25zdCBERUZBVUxUX1RSQU5TSVRJT04gID0gJzIwMG1zIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnc2F0LXBvcG92ZXInLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBhbmltYXRpb25zOiBbdHJhbnNmb3JtUG9wb3Zlcl0sXG4gIHN0eWxlVXJsczogWycuL3BvcG92ZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgdGVtcGxhdGVVcmw6ICcuL3BvcG92ZXIuY29tcG9uZW50Lmh0bWwnLFxufSlcbmV4cG9ydCBjbGFzcyBTYXRQb3BvdmVyIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIGhvcml6b250YWwgYXhpcy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGhvcml6b250YWxBbGlnbigpIHsgcmV0dXJuIHRoaXMuX2hvcml6b250YWxBbGlnbjsgfVxuICBzZXQgaG9yaXpvbnRhbEFsaWduKHZhbDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbikge1xuICAgIHRoaXMuX3ZhbGlkYXRlSG9yaXpvbnRhbEFsaWduKHZhbCk7XG4gICAgaWYgKHRoaXMuX2hvcml6b250YWxBbGlnbiAhPT0gdmFsKSB7XG4gICAgICB0aGlzLl9ob3Jpem9udGFsQWxpZ24gPSB2YWw7XG4gICAgICB0aGlzLl9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uUkVQT1NJVElPTikpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9ob3Jpem9udGFsQWxpZ246IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24gPSAnY2VudGVyJztcblxuICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB4IGF4aXMuIEFsaWFzIGZvciBgaG9yaXpvbnRhbEFsaWduYC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHhBbGlnbigpIHsgcmV0dXJuIHRoaXMuaG9yaXpvbnRhbEFsaWduOyB9XG4gIHNldCB4QWxpZ24odmFsOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduKSB7IHRoaXMuaG9yaXpvbnRhbEFsaWduID0gdmFsOyB9XG5cbiAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgdmVydGljYWwgYXhpcy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHZlcnRpY2FsQWxpZ24oKSB7IHJldHVybiB0aGlzLl92ZXJ0aWNhbEFsaWduOyB9XG4gIHNldCB2ZXJ0aWNhbEFsaWduKHZhbDogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24pIHtcbiAgICB0aGlzLl92YWxpZGF0ZVZlcnRpY2FsQWxpZ24odmFsKTtcbiAgICBpZiAodGhpcy5fdmVydGljYWxBbGlnbiAhPT0gdmFsKSB7XG4gICAgICB0aGlzLl92ZXJ0aWNhbEFsaWduID0gdmFsO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlJFUE9TSVRJT04pKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfdmVydGljYWxBbGlnbjogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24gPSAnY2VudGVyJztcblxuICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB5IGF4aXMuIEFsaWFzIGZvciBgdmVydGljYWxBbGlnbmAuICovXG4gIEBJbnB1dCgpXG4gIGdldCB5QWxpZ24oKSB7IHJldHVybiB0aGlzLnZlcnRpY2FsQWxpZ247IH1cbiAgc2V0IHlBbGlnbih2YWw6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduKSB7IHRoaXMudmVydGljYWxBbGlnbiA9IHZhbDsgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGFsd2F5cyBvcGVucyB3aXRoIHRoZSBzcGVjaWZpZWQgYWxpZ25tZW50LiAqL1xuICBASW5wdXQoKVxuICBnZXQgZm9yY2VBbGlnbm1lbnQoKSB7IHJldHVybiB0aGlzLl9mb3JjZUFsaWdubWVudDsgfVxuICBzZXQgZm9yY2VBbGlnbm1lbnQodmFsOiBib29sZWFuKSB7XG4gICAgY29uc3QgY29lcmNlZFZhbCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICAgIGlmICh0aGlzLl9mb3JjZUFsaWdubWVudCAhPT0gY29lcmNlZFZhbCkge1xuICAgICAgdGhpcy5fZm9yY2VBbGlnbm1lbnQgPSBjb2VyY2VkVmFsO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hDb25maWdOb3RpZmljYXRpb24obmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLlJFUE9TSVRJT04pKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfZm9yY2VBbGlnbm1lbnQgPSBmYWxzZTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcG9wb3ZlcidzIGFsaWdubWVudCBpcyBsb2NrZWQgYWZ0ZXIgb3BlbmluZy4gVGhpcyBwcmV2ZW50cyB0aGUgcG9wb3ZlclxuICAgKiBmcm9tIGNoYW5naW5nIGl0cyBhbGlnbmVtZW50IHdoZW4gc2Nyb2xsaW5nIG9yIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBsb2NrQWxpZ25tZW50KCkgeyByZXR1cm4gdGhpcy5fbG9ja0FsaWdubWVudDsgfVxuICBzZXQgbG9ja0FsaWdubWVudCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBjb2VyY2VkVmFsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gICAgaWYgKHRoaXMuX2xvY2tBbGlnbm1lbnQgIT09IGNvZXJjZWRWYWwpIHtcbiAgICAgIHRoaXMuX2xvY2tBbGlnbm1lbnQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OKSk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2xvY2tBbGlnbm1lbnQgPSBmYWxzZTtcblxuICAvKiogV2hldGhlciB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgc2hvdWxkIGJlIGZvY3VzZWQgb24gb3Blbi4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGF1dG9Gb2N1cygpIHsgcmV0dXJuIHRoaXMuX2F1dG9Gb2N1cyAmJiB0aGlzLl9hdXRvRm9jdXNPdmVycmlkZTsgfVxuICBzZXQgYXV0b0ZvY3VzKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX2F1dG9Gb2N1cyA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICB9XG4gIHByaXZhdGUgX2F1dG9Gb2N1cyA9IHRydWU7XG4gIF9hdXRvRm9jdXNPdmVycmlkZSA9IHRydWU7XG5cbiAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBzaG91bGQgcmV0dXJuIGZvY3VzIHRvIHRoZSBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudCBhZnRlciBjbG9zaW5nLiAqL1xuIEBJbnB1dCgpXG4gIGdldCByZXN0b3JlRm9jdXMoKSB7IHJldHVybiB0aGlzLl9yZXN0b3JlRm9jdXMgJiYgdGhpcy5fcmVzdG9yZUZvY3VzT3ZlcnJpZGU7IH1cbiAgc2V0IHJlc3RvcmVGb2N1cyh2YWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZXN0b3JlRm9jdXMgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgfVxuICBwcml2YXRlIF9yZXN0b3JlRm9jdXMgPSB0cnVlO1xuICBfcmVzdG9yZUZvY3VzT3ZlcnJpZGUgPSB0cnVlO1xuXG4gIC8qKiBIb3cgdGhlIHBvcG92ZXIgc2hvdWxkIGhhbmRsZSBzY3JvbGxpbmcuICovXG4gIEBJbnB1dCgpXG4gIGdldCBzY3JvbGxTdHJhdGVneSgpIHsgcmV0dXJuIHRoaXMuX3Njcm9sbFN0cmF0ZWd5OyB9XG4gIHNldCBzY3JvbGxTdHJhdGVneSh2YWw6IFNhdFBvcG92ZXJTY3JvbGxTdHJhdGVneSkge1xuICAgIHRoaXMuX3ZhbGlkYXRlU2Nyb2xsU3RyYXRlZ3kodmFsKTtcbiAgICBpZiAodGhpcy5fc2Nyb2xsU3RyYXRlZ3kgIT09IHZhbCkge1xuICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kgPSB2YWw7XG4gICAgICB0aGlzLl9kaXNwYXRjaENvbmZpZ05vdGlmaWNhdGlvbihuZXcgUG9wb3Zlck5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25BY3Rpb24uVVBEQVRFX0NPTkZJRykpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9zY3JvbGxTdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5ID0gJ3JlcG9zaXRpb24nO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBoYXZlIGEgYmFja2Ryb3AgKGluY2x1ZGVzIGNsb3Npbmcgb24gY2xpY2spLiAqL1xuICBASW5wdXQoKVxuICBnZXQgaGFzQmFja2Ryb3AoKSB7IHJldHVybiB0aGlzLl9oYXNCYWNrZHJvcDsgfVxuICBzZXQgaGFzQmFja2Ryb3AodmFsOiBib29sZWFuKSB7XG4gICAgdGhpcy5faGFzQmFja2Ryb3AgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgfVxuICBwcml2YXRlIF9oYXNCYWNrZHJvcCA9IGZhbHNlO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBjbG9zZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFja2Ryb3Agb3IgcHJlc3NlcyBFU0MuICovXG4gIEBJbnB1dCgpXG4gIGdldCBpbnRlcmFjdGl2ZUNsb3NlKCkgeyByZXR1cm4gdGhpcy5faW50ZXJhY3RpdmVDbG9zZTsgfVxuICBzZXQgaW50ZXJhY3RpdmVDbG9zZSh2YWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9pbnRlcmFjdGl2ZUNsb3NlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gIH1cbiAgcHJpdmF0ZSBfaW50ZXJhY3RpdmVDbG9zZSA9IHRydWU7XG5cbiAgLyoqIEN1c3RvbSB0cmFuc2l0aW9uIHRvIHVzZSB3aGlsZSBvcGVuaW5nLiAqL1xuICBASW5wdXQoKVxuICBnZXQgb3BlblRyYW5zaXRpb24oKSB7IHJldHVybiB0aGlzLl9vcGVuVHJhbnNpdGlvbjsgfVxuICBzZXQgb3BlblRyYW5zaXRpb24odmFsOiBzdHJpbmcpIHtcbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLl9vcGVuVHJhbnNpdGlvbiA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfb3BlblRyYW5zaXRpb24gPSBERUZBVUxUX1RSQU5TSVRJT047XG5cbiAgLyoqIEN1c3RvbSB0cmFuc2l0aW9uIHRvIHVzZSB3aGlsZSBjbG9zaW5nLiAqL1xuICBASW5wdXQoKVxuICBnZXQgY2xvc2VUcmFuc2l0aW9uKCkgeyByZXR1cm4gdGhpcy5fY2xvc2VUcmFuc2l0aW9uOyB9XG4gIHNldCBjbG9zZVRyYW5zaXRpb24odmFsOiBzdHJpbmcpIHtcbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLl9jbG9zZVRyYW5zaXRpb24gPSB2YWw7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2Nsb3NlVHJhbnNpdGlvbiA9IERFRkFVTFRfVFJBTlNJVElPTjtcblxuICAvKiogT3B0aW9uYWwgYmFja2Ryb3AgY2xhc3MuICovXG4gIEBJbnB1dCgpIGJhY2tkcm9wQ2xhc3MgPSAnJztcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIEBPdXRwdXQoKSBvcGVuZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkLiAqL1xuICBAT3V0cHV0KCkgY2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIG9wZW5pbmcuICovXG4gIEBPdXRwdXQoKSBhZnRlck9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIGNsb3NpbmcuICovXG4gIEBPdXRwdXQoKSBhZnRlckNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLiAqL1xuICBAT3V0cHV0KCkgYmFja2Ryb3BDbGlja2VkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIGEga2V5ZG93biBldmVudCBpcyB0YXJnZXRlZCB0byB0aGlzIHBvcG92ZXIncyBvdmVybGF5LiAqL1xuICBAT3V0cHV0KCkgb3ZlcmxheUtleWRvd24gPSBuZXcgRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+KCk7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0ZW1wbGF0ZSBzbyBpdCBjYW4gYmUgcGxhY2VkIHdpdGhpbiBhIHBvcnRhbC4gKi9cbiAgQFZpZXdDaGlsZChUZW1wbGF0ZVJlZikgX3RlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIC8qKiBDbGFzc2VzIHRvIGJlIGFkZGVkIHRvIHRoZSBwb3BvdmVyIGZvciBzZXR0aW5nIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBvcmlnaW4uICovXG4gIF9jbGFzc0xpc3Q6IGFueSA9IHt9O1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBfb3BlbiA9IGZhbHNlO1xuXG4gIC8qKiBJbnN0YW5jZSBvZiBub3RpZmljYXRpb24gc2VydmljZS4gV2lsbCBiZSB1bmRlZmluZWQgdW50aWwgYXR0YWNoZWQgdG8gYW4gYW5jaG9yLiAqL1xuICBfbm90aWZpY2F0aW9uczogUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2U7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0byBidWlsZCBhIGZvY3VzIHRyYXAgYXJvdW5kLiAqL1xuICBAVmlld0NoaWxkKCdmb2N1c1RyYXBFbGVtZW50JylcbiAgcHJpdmF0ZSBfZm9jdXNUcmFwRWxlbWVudDogRWxlbWVudFJlZjtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIG9wZW5pbmcuICovXG4gIHByaXZhdGUgX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudDogSFRNTEVsZW1lbnQ7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byBhIGZvY3VzIHRyYXAgYXJvdW5kIHRoZSBwb3BvdmVyLiAqL1xuICBwcml2YXRlIF9mb2N1c1RyYXA6IEZvY3VzVHJhcDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9mb2N1c1RyYXBGYWN0b3J5OiBGb2N1c1RyYXBGYWN0b3J5LFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnlcbiAgKSB7IH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9zZXRBbGlnbm1lbnRDbGFzc2VzKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fbm90aWZpY2F0aW9ucykge1xuICAgICAgdGhpcy5fbm90aWZpY2F0aW9ucy5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIE9wZW4gdGhpcyBwb3BvdmVyLiAqL1xuICBvcGVuKG9wdGlvbnM6IFNhdFBvcG92ZXJPcGVuT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uQWN0aW9uLk9QRU4sIG9wdGlvbnMpO1xuICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvKiogQ2xvc2UgdGhpcyBwb3BvdmVyLiAqL1xuICBjbG9zZSh2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5DTE9TRSwgdmFsdWUpO1xuICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvKiogVG9nZ2xlIHRoaXMgcG9wb3ZlciBvcGVuIG9yIGNsb3NlZC4gKi9cbiAgdG9nZ2xlKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5UT0dHTEUpO1xuICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICByZWFsaWduKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyBQb3BvdmVyTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkFjdGlvbi5SRUFMSUdOKTtcbiAgICB0aGlzLl9kaXNwYXRjaEFjdGlvbk5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICB9XG5cbiAgLyoqIEdldHMgd2hldGhlciB0aGUgcG9wb3ZlciBpcyBwcmVzZW50bHkgb3Blbi4gKi9cbiAgaXNPcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICB9XG5cbiAgLyoqIEdldHMgYW4gYW5pbWF0aW9uIGNvbmZpZyB3aXRoIGN1c3RvbWl6ZWQgKG9yIGRlZmF1bHQpIHRyYW5zaXRpb24gdmFsdWVzLiAqL1xuICBfZ2V0QW5pbWF0aW9uKCk6IHsgdmFsdWU6IGFueSwgcGFyYW1zOiBhbnkgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiAndmlzaWJsZScsXG4gICAgICBwYXJhbXM6IHsgb3BlblRyYW5zaXRpb246IHRoaXMub3BlblRyYW5zaXRpb24sIGNsb3NlVHJhbnNpdGlvbjogdGhpcy5jbG9zZVRyYW5zaXRpb24gfVxuICAgIH07XG4gIH1cblxuICAvKiogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIHBvcG92ZXIgaXMgZmluaXNoZWQgYW5pbWF0aW5nIGluIG9yIG91dC4gKi9cbiAgX29uQW5pbWF0aW9uRG9uZShldmVudDogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB0aGlzLl90cmFwRm9jdXMoKTtcbiAgICAgIHRoaXMuYWZ0ZXJPcGVuLmVtaXQoKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICd2b2lkJykge1xuICAgICAgdGhpcy5fcmVzdG9yZUZvY3VzQW5kRGVzdHJveVRyYXAoKTtcbiAgICAgIHRoaXMuYWZ0ZXJDbG9zZS5lbWl0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEFwcGx5IGFsaWdubWVudCBjbGFzc2VzIGJhc2VkIG9uIGFsaWdubWVudCBpbnB1dHMuICovXG4gIF9zZXRBbGlnbm1lbnRDbGFzc2VzKGhvcml6QWxpZ24gPSB0aGlzLmhvcml6b250YWxBbGlnbiwgdmVydEFsaWduID0gdGhpcy52ZXJ0aWNhbEFsaWduKSB7XG4gICAgdGhpcy5fY2xhc3NMaXN0WydzYXQtcG9wb3Zlci1iZWZvcmUnXSA9IGhvcml6QWxpZ24gPT09ICdiZWZvcmUnIHx8IGhvcml6QWxpZ24gPT09ICdlbmQnO1xuICAgIHRoaXMuX2NsYXNzTGlzdFsnc2F0LXBvcG92ZXItYWZ0ZXInXSAgPSBob3JpekFsaWduID09PSAnYWZ0ZXInIHx8IGhvcml6QWxpZ24gPT09ICdzdGFydCc7XG5cbiAgICB0aGlzLl9jbGFzc0xpc3RbJ3NhdC1wb3BvdmVyLWFib3ZlJ10gPSB2ZXJ0QWxpZ24gPT09ICdhYm92ZScgfHwgdmVydEFsaWduID09PSAnZW5kJztcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ3NhdC1wb3BvdmVyLWJlbG93J10gPSB2ZXJ0QWxpZ24gPT09ICdiZWxvdycgfHwgdmVydEFsaWduID09PSAnc3RhcnQnO1xuXG4gICAgdGhpcy5fY2xhc3NMaXN0WydzYXQtcG9wb3Zlci1jZW50ZXInXSA9IGhvcml6QWxpZ24gPT09ICdjZW50ZXInIHx8IHZlcnRBbGlnbiA9PT0gJ2NlbnRlcic7XG4gIH1cblxuICAvKiogTW92ZSB0aGUgZm9jdXMgaW5zaWRlIHRoZSBmb2N1cyB0cmFwIGFuZCByZW1lbWJlciB3aGVyZSB0byByZXR1cm4gbGF0ZXIuICovXG4gIHByaXZhdGUgX3RyYXBGb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLl9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk7XG5cbiAgICAvLyBUaGVyZSB3b24ndCBiZSBhIGZvY3VzIHRyYXAgZWxlbWVudCBpZiB0aGUgY2xvc2UgYW5pbWF0aW9uIHN0YXJ0cyBiZWZvcmUgb3BlbiBmaW5pc2hlc1xuICAgIGlmICghdGhpcy5fZm9jdXNUcmFwRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKHRoaXMuX2ZvY3VzVHJhcEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXV0b0ZvY3VzKSB7XG4gICAgICB0aGlzLl9mb2N1c1RyYXAuZm9jdXNJbml0aWFsRWxlbWVudFdoZW5SZWFkeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZXN0b3JlIGZvY3VzIHRvIHRoZSBlbGVtZW50IGZvY3VzZWQgYmVmb3JlIHRoZSBwb3BvdmVyIG9wZW5lZC4gQWxzbyBkZXN0cm95IHRyYXAuICovXG4gIHByaXZhdGUgX3Jlc3RvcmVGb2N1c0FuZERlc3Ryb3lUcmFwKCk6IHZvaWQge1xuICAgIGNvbnN0IHRvRm9jdXMgPSB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQ7XG5cbiAgICAvLyBNdXN0IGNoZWNrIGFjdGl2ZSBlbGVtZW50IGlzIGZvY3VzYWJsZSBmb3IgSUUgc2FrZVxuICAgIGlmICh0b0ZvY3VzICYmICdmb2N1cycgaW4gdG9Gb2N1cyAmJiB0aGlzLnJlc3RvcmVGb2N1cykge1xuICAgICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl9mb2N1c1RyYXApIHtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcC5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9mb2N1c1RyYXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgZm9jdXNlZCBiZWZvcmUgdGhlIHBvcG92ZXIgd2FzIG9wZW5lZC4gKi9cbiAgcHJpdmF0ZSBfc2F2ZVByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgIHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgLyoqIERpc3BhdGNoIGEgbm90aWZpY2F0aW9uIHRvIHRoZSBub3RpZmljYXRpb24gc2VydmljZSwgaWYgcG9zc2libGUuICovXG4gIHByaXZhdGUgX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogUG9wb3Zlck5vdGlmaWNhdGlvbikge1xuICAgIGlmICh0aGlzLl9ub3RpZmljYXRpb25zKSB7XG4gICAgICB0aGlzLl9ub3RpZmljYXRpb25zLmRpc3BhdGNoKG5vdGlmaWNhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqIERpc3BhdGNoIGEgbm90aWZpY2F0aW9uIHRvIHRoZSBub3RpZmljYXRpb24gc2VydmljZSBhbmQgdGhyb3cgaWYgdW5hYmxlIHRvLiAqL1xuICBwcml2YXRlIF9kaXNwYXRjaEFjdGlvbk5vdGlmaWNhdGlvbihub3RpZmljYXRpb246IFBvcG92ZXJOb3RpZmljYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuX25vdGlmaWNhdGlvbnMpIHtcbiAgICAgIHRocm93IGdldFVuYW5jaG9yZWRQb3BvdmVyRXJyb3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ub3RpZmljYXRpb25zLmRpc3BhdGNoKG5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBhbGlnbm1lbnQgaXMgbm90IGEgdmFsaWQgaG9yaXpvbnRhbEFsaWduLiAqL1xuICBwcml2YXRlIF92YWxpZGF0ZUhvcml6b250YWxBbGlnbihwb3M6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24pOiB2b2lkIHtcbiAgICBpZiAoVkFMSURfSE9SSVpfQUxJR04uaW5kZXhPZihwb3MpID09PSAtMSkge1xuICAgICAgdGhyb3cgZ2V0SW52YWxpZEhvcml6b250YWxBbGlnbkVycm9yKHBvcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYWxpZ25tZW50IGlzIG5vdCBhIHZhbGlkIHZlcnRpY2FsQWxpZ24uICovXG4gIHByaXZhdGUgX3ZhbGlkYXRlVmVydGljYWxBbGlnbihwb3M6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduKTogdm9pZCB7XG4gICAgaWYgKFZBTElEX1ZFUlRfQUxJR04uaW5kZXhPZihwb3MpID09PSAtMSkge1xuICAgICAgdGhyb3cgZ2V0SW52YWxpZFZlcnRpY2FsQWxpZ25FcnJvcihwb3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNjcm9sbCBzdHJhdGVneSBpcyBub3QgYSB2YWxpZCBzdHJhdGVneS4gKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdGVTY3JvbGxTdHJhdGVneShzdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5KTogdm9pZCB7XG4gICAgaWYgKFZBTElEX1NDUk9MTC5pbmRleE9mKHN0cmF0ZWd5KSA9PT0gLTEpIHtcbiAgICAgIHRocm93IGdldEludmFsaWRTY3JvbGxTdHJhdGVneUVycm9yKHN0cmF0ZWd5KTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEVsZW1lbnRSZWYsXG4gIEluamVjdGFibGUsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIsXG4gIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSxcbiAgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsXG4gIE92ZXJsYXksXG4gIE92ZXJsYXlDb25maWcsXG4gIE92ZXJsYXlSZWYsXG4gIFNjcm9sbFN0cmF0ZWd5LFxuICBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MsXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5LCBEaXJlY3Rpb259IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwsIHRha2UsIGZpbHRlciwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBTYXRQb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbiAgU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5LFxuICBTYXRQb3BvdmVyT3Blbk9wdGlvbnMsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5pbXBvcnQgeyBQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZSwgTm90aWZpY2F0aW9uQWN0aW9uIH0gZnJvbSAnLi9ub3RpZmljYXRpb24uc2VydmljZSc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBwcm92aWRlZCBieSB0aGUgcG9wb3ZlciBmb3IgdGhlIGFuY2hvcmluZyBzZXJ2aWNlXG4gKiB0byBidWlsZCB0aGUgY29ycmVjdCBvdmVybGF5IGNvbmZpZy5cbiAqL1xuaW50ZXJmYWNlIFBvcG92ZXJDb25maWcge1xuICBob3Jpem9udGFsQWxpZ246IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ247XG4gIHZlcnRpY2FsQWxpZ246IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduO1xuICBoYXNCYWNrZHJvcDogYm9vbGVhbjtcbiAgYmFja2Ryb3BDbGFzczogc3RyaW5nO1xuICBzY3JvbGxTdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5O1xuICBmb3JjZUFsaWdubWVudDogYm9vbGVhbjtcbiAgbG9ja0FsaWdubWVudDogYm9vbGVhbjtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIHBvcG92ZXJPcGVuZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgcG9wb3ZlckNsb3NlZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSBjb250YWluaW5nIHRoZSBwb3BvdmVyIGNvbXBvbmVudC4gKi9cbiAgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHBvcG92ZXIuICovXG4gIHByaXZhdGUgX3BvcG92ZXI6IFNhdFBvcG92ZXI7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdmlldyBjb250YWluZXIgZm9yIHRoZSBwb3BvdmVyIHRlbXBsYXRlLiAqL1xuICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGFuY2hvciBlbGVtZW50LiAqL1xuICBwcml2YXRlIF9hbmNob3I6IEVsZW1lbnRSZWY7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byBhIHRlbXBsYXRlIHBvcnRhbCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGF0dGFjaGVkLiAqL1xuICBwcml2YXRlIF9wb3J0YWw6IFRlbXBsYXRlUG9ydGFsPGFueT47XG5cbiAgLyoqIENvbW11bmljYXRpb25zIGNoYW5uZWwgd2l0aCB0aGUgcG9wb3Zlci4gKi9cbiAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uczogUG9wb3Zlck5vdGlmaWNhdGlvblNlcnZpY2U7XG5cbiAgLyoqIFNpbmdsZSBzdWJzY3JpcHRpb24gdG8gbm90aWZpY2F0aW9ucyBzZXJ2aWNlIGV2ZW50cy4gKi9cbiAgcHJpdmF0ZSBfbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKiBTaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHBvc2l0aW9uIGNoYW5nZXMuICovXG4gIHByaXZhdGUgX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIHByaXZhdGUgX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHNlcnZpY2UgaXMgZGVzdHJveWVkLiAqL1xuICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyOiBEaXJlY3Rpb25hbGl0eVxuICApIHsgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIC8vIERlc3Ryb3kgcG9wb3ZlciBiZWZvcmUgdGVybWluYXRpbmcgc3Vic2NyaXB0aW9ucyBzbyB0aGF0IGFueSByZXN1bHRpbmdcbiAgICAvLyBkZXRhY2htZW50cyB1cGRhdGUgJ2Nsb3NlZCBzdGF0ZSdcbiAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgLy8gVGVybWluYXRlIHN1YnNjcmlwdGlvbnNcbiAgICBpZiAodGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG5cbiAgICB0aGlzLnBvcG92ZXJPcGVuZWQuY29tcGxldGUoKTtcbiAgICB0aGlzLnBvcG92ZXJDbG9zZWQuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBBbmNob3IgYSBwb3BvdmVyIGluc3RhbmNlIHRvIGEgdmlldyBhbmQgY29ubmVjdGlvbiBlbGVtZW50LiAqL1xuICBhbmNob3IocG9wb3ZlcjogU2F0UG9wb3Zlciwgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgYW5jaG9yOiBFbGVtZW50UmVmKTogdm9pZCB7XG4gICAgLy8gRGVzdHJveSBhbnkgcHJldmlvdXMgcG9wb3ZlcnNcbiAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgLy8gQXNzaWduIGxvY2FsIHJlZnNcbiAgICB0aGlzLl9wb3BvdmVyID0gcG9wb3ZlcjtcbiAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICB0aGlzLl9hbmNob3IgPSBhbmNob3I7XG5cbiAgICAvLyBQcm92aWRlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlIGFzIGEgY29tbXVuaWNhdGlvbiBjaGFubmVsIGJldHdlZW4gcG9wb3ZlciBhbmQgYW5jaG9yLlxuICAgIC8vIFRoZW4gc3Vic2NyaWJlIHRvIG5vdGlmaWNhdGlvbnMgdG8gdGFrZSBhcHByb3ByaWF0ZSBhY3Rpb25zLlxuICAgIHRoaXMuX3BvcG92ZXIuX25vdGlmaWNhdGlvbnMgPSB0aGlzLl9ub3RpZmljYXRpb25zID0gbmV3IFBvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlKCk7XG4gICAgdGhpcy5fc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zKCk7XG4gIH1cblxuICAvKiogR2V0cyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICBpc1BvcG92ZXJPcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9wb3BvdmVyT3BlbjtcbiAgfVxuXG4gIC8qKiBUb2dnbGVzIHRoZSBwb3BvdmVyIGJldHdlZW4gdGhlIG9wZW4gYW5kIGNsb3NlZCBzdGF0ZXMuICovXG4gIHRvZ2dsZVBvcG92ZXIoKTogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuID8gdGhpcy5jbG9zZVBvcG92ZXIoKSA6IHRoaXMub3BlblBvcG92ZXIoKTtcbiAgfVxuXG4gIC8qKiBPcGVucyB0aGUgcG9wb3Zlci4gKi9cbiAgb3BlblBvcG92ZXIob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zID0ge30pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICB0aGlzLl9hcHBseU9wZW5PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9CYWNrZHJvcCgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9Fc2NhcGUoKTtcbiAgICAgIHRoaXMuX3N1YnNjcmliZVRvRGV0YWNobWVudHMoKTtcbiAgICAgIHRoaXMuX3NhdmVPcGVuZWRTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDbG9zZXMgdGhlIHBvcG92ZXIuICovXG4gIGNsb3NlUG9wb3Zlcih2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9zYXZlQ2xvc2VkU3RhdGUodmFsdWUpO1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICB9XG4gIH1cblxuICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICByZWFsaWduUG9wb3ZlclRvQW5jaG9yKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLl9vdmVybGF5UmVmLmdldENvbmZpZygpO1xuICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb25maWcucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgICBzdHJhdGVneS5yZWFwcGx5TGFzdFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuICovXG4gIGdldEFuY2hvckVsZW1lbnQoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgfVxuXG4gIC8qKiBBcHBseSBiZWhhdmlvciBwcm9wZXJ0aWVzIG9uIHRoZSBwb3BvdmVyIGJhc2VkIG9uIHRoZSBvcGVuIG9wdGlvbnMuICovXG4gIHByaXZhdGUgX2FwcGx5T3Blbk9wdGlvbnMob3B0aW9uczogU2F0UG9wb3Zlck9wZW5PcHRpb25zKTogdm9pZCB7XG4gICAgLy8gT25seSBvdmVycmlkZSByZXN0b3JlRm9jdXMgYXMgYGZhbHNlYCBpZiB0aGUgb3B0aW9uIGlzIGV4cGxpY2l0bHkgYGZhbHNlYFxuICAgIGNvbnN0IHJlc3RvcmVGb2N1cyA9IG9wdGlvbnMucmVzdG9yZUZvY3VzICE9PSBmYWxzZTtcbiAgICB0aGlzLl9wb3BvdmVyLl9yZXN0b3JlRm9jdXNPdmVycmlkZSA9IHJlc3RvcmVGb2N1cztcblxuICAgIC8vIE9ubHkgb3ZlcnJpZGUgYXV0b0ZvY3VzIGFzIGBmYWxzZWAgaWYgdGhlIG9wdGlvbiBpcyBleHBsaWNpdGx5IGBmYWxzZWBcbiAgICBjb25zdCBhdXRvRm9jdXMgPSBvcHRpb25zLmF1dG9Gb2N1cyAhPT0gZmFsc2U7XG4gICAgdGhpcy5fcG9wb3Zlci5fYXV0b0ZvY3VzT3ZlcnJpZGUgPSBhdXRvRm9jdXM7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuIG92ZXJsYXkgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHBvcnRhbC4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcbiAgICAvLyBDcmVhdGUgb3ZlcmxheSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX3BvcG92ZXIuX3RlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcblxuICAgICAgY29uc3QgcG9wb3ZlckNvbmZpZyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbEFsaWduOiB0aGlzLl9wb3BvdmVyLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5fcG9wb3Zlci52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBoYXNCYWNrZHJvcDogdGhpcy5fcG9wb3Zlci5oYXNCYWNrZHJvcCxcbiAgICAgICAgYmFja2Ryb3BDbGFzczogdGhpcy5fcG9wb3Zlci5iYWNrZHJvcENsYXNzLFxuICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fcG9wb3Zlci5zY3JvbGxTdHJhdGVneSxcbiAgICAgICAgZm9yY2VBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgIGxvY2tBbGlnbm1lbnQ6IHRoaXMuX3BvcG92ZXIubG9ja0FsaWdubWVudCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKHBvcG92ZXJDb25maWcsIHRoaXMuX2FuY2hvcik7XG5cbiAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKFxuICAgICAgICBvdmVybGF5Q29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgICApO1xuXG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheUNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgb3BlbiB0aGUgcG9wb3ZlclxuICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gIH1cblxuXG4gIC8qKiBSZW1vdmVzIHRoZSBwb3BvdmVyIGZyb20gdGhlIERPTS4gRG9lcyBOT1QgdXBkYXRlIG9wZW4gc3RhdGUuICovXG4gIHByaXZhdGUgX2Rlc3Ryb3lQb3BvdmVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcG9wb3ZlciBpbW1lZGlhdGVseSBpZiBpdCBpcyBjbG9zZWQsIG9yIHdhaXRzIHVudGlsIGl0XG4gICAqIGhhcyBiZWVuIGNsb3NlZCB0byBkZXN0cm95IGl0LlxuICAgKi9cbiAgcHJpdmF0ZSBfZGVzdHJveVBvcG92ZXJPbmNlQ2xvc2VkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzUG9wb3Zlck9wZW4oKSAmJiB0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaG1lbnRzKCkucGlwZShcbiAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2Rlc3Ryb3lQb3BvdmVyKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZXN0cm95UG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGFwcHJvcHJpYXRlIGFuY2hvciBtZXRob2Qgd2hlbiBhbiBldmVudCBpcyBkaXNwYXRjaGVkIHRocm91Z2hcbiAgICogdGhlIG5vdGlmaWNhdGlvbiBzZXJ2aWNlLlxuICAgKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9ub3RpZmljYXRpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbiA9IHRoaXMuX25vdGlmaWNhdGlvbnMuZXZlbnRzKClcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmFjdGlvbikge1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLk9QRU46XG4gICAgICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLkNMT1NFOlxuICAgICAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoZXZlbnQudmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBOb3RpZmljYXRpb25BY3Rpb24uVE9HR0xFOlxuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3BvdmVyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE5vdGlmaWNhdGlvbkFjdGlvbi5SRVBPU0lUSU9OOlxuICAgICAgICAgICAgLy8gVE9ETzogV2hlbiB0aGUgb3ZlcmxheSdzIHBvc2l0aW9uIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkLCBkbyBub3QgZGVzdHJveVxuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLlVQREFURV9DT05GSUc6XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95UG9wb3Zlck9uY2VDbG9zZWQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTm90aWZpY2F0aW9uQWN0aW9uLlJFQUxJR046XG4gICAgICAgICAgICB0aGlzLnJlYWxpZ25Qb3BvdmVyVG9BbmNob3IoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBDbG9zZSBwb3BvdmVyIHdoZW4gYmFja2Ryb3AgaXMgY2xpY2tlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcCgpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuYmFja2Ryb3BDbGljaygpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKCgpID0+IHRoaXMuX3BvcG92ZXIuYmFja2Ryb3BDbGlja2VkLmVtaXQoKSksXG4gICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl9wb3BvdmVyLmludGVyYWN0aXZlQ2xvc2UpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyQ2xvc2VkKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2VQb3BvdmVyKCkpO1xuICB9XG5cbiAgLyoqIENsb3NlIHBvcG92ZXIgd2hlbiBlc2NhcGUga2V5ZG93biBldmVudCBvY2N1cnMuICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvRXNjYXBlKCk6IHZvaWQge1xuICAgIHRoaXMuX292ZXJsYXlSZWZcbiAgICAgIC5rZXlkb3duRXZlbnRzKClcbiAgICAgIC5waXBlKFxuICAgICAgICB0YXAoZXZlbnQgPT4gdGhpcy5fcG9wb3Zlci5vdmVybGF5S2V5ZG93bi5lbWl0KGV2ZW50KSksXG4gICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudC5rZXlDb2RlID09PSBFU0NBUEUpLFxuICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fcG9wb3Zlci5pbnRlcmFjdGl2ZUNsb3NlKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMucG9wb3ZlckNsb3NlZCksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlUG9wb3ZlcigpKTtcbiAgfVxuXG4gIC8qKiBTZXQgc3RhdGUgYmFjayB0byBjbG9zZWQgd2hlbiBkZXRhY2hlZC4gKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9EZXRhY2htZW50cygpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAuZGV0YWNobWVudHMoKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3NhdmVDbG9zZWRTdGF0ZSgpKTtcbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVPcGVuZWRTdGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuKSB7XG4gICAgICB0aGlzLl9wb3BvdmVyLl9vcGVuID0gdGhpcy5fcG9wb3Zlck9wZW4gPSB0cnVlO1xuXG4gICAgICB0aGlzLnBvcG92ZXJPcGVuZWQubmV4dCgpO1xuICAgICAgdGhpcy5fcG9wb3Zlci5vcGVuZWQuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBjbG9zZWQgc3RhdGUgb2YgdGhlIHBvcG92ZXIgYW5kIGVtaXQuICovXG4gIHByaXZhdGUgX3NhdmVDbG9zZWRTdGF0ZSh2YWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wb3BvdmVyT3Blbikge1xuICAgICAgdGhpcy5fcG9wb3Zlci5fb3BlbiA9IHRoaXMuX3BvcG92ZXJPcGVuID0gZmFsc2U7XG5cbiAgICAgIHRoaXMucG9wb3ZlckNsb3NlZC5uZXh0KHZhbHVlKTtcbiAgICAgIHRoaXMuX3BvcG92ZXIuY2xvc2VkLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gIHByaXZhdGUgX2dldERpcmVjdGlvbigpOiBEaXJlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gIH1cblxuICAvKiogQ3JlYXRlIGFuZCByZXR1cm4gYSBjb25maWcgZm9yIGNyZWF0aW5nIHRoZSBvdmVybGF5LiAqL1xuICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnKGNvbmZpZzogUG9wb3ZlckNvbmZpZywgYW5jaG9yOiBFbGVtZW50UmVmKTogT3ZlcmxheUNvbmZpZyB7XG4gICAgcmV0dXJuIG5ldyBPdmVybGF5Q29uZmlnKHtcbiAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMuX2dldFBvc2l0aW9uU3RyYXRlZ3koXG4gICAgICAgIGNvbmZpZy5ob3Jpem9udGFsQWxpZ24sXG4gICAgICAgIGNvbmZpZy52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBjb25maWcuZm9yY2VBbGlnbm1lbnQsXG4gICAgICAgIGNvbmZpZy5sb2NrQWxpZ25tZW50LFxuICAgICAgICBhbmNob3IsXG4gICAgICApLFxuICAgICAgaGFzQmFja2Ryb3A6IGNvbmZpZy5oYXNCYWNrZHJvcCxcbiAgICAgIGJhY2tkcm9wQ2xhc3M6IGNvbmZpZy5iYWNrZHJvcENsYXNzIHx8ICdjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCcsXG4gICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZShjb25maWcuc2Nyb2xsU3RyYXRlZ3kpLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLl9nZXREaXJlY3Rpb24oKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldCB0aGUgY29ycmVjdCBhbGlnbm1lbnQgY2xhc3NlcyxcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYW5pbWF0aW9uIG9yaWdpbiBpcyBjb3JyZWN0LCBldmVuIHdpdGggYSBmYWxsYmFjayBwb3NpdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKHBvc2l0aW9uOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSBwb3NpdGlvbi5wb3NpdGlvbkNoYW5nZXNcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgICAvLyBQb3NpdGlvbiBjaGFuZ2VzIG1heSBvY2N1ciBvdXRzaWRlIHRoZSBBbmd1bGFyIHpvbmVcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcG9wb3Zlci5fc2V0QWxpZ25tZW50Q2xhc3NlcyhcbiAgICAgICAgICAgIGdldEhvcml6b250YWxQb3BvdmVyQWxpZ25tZW50KGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WCksXG4gICAgICAgICAgICBnZXRWZXJ0aWNhbFBvcG92ZXJBbGlnbm1lbnQoY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm92ZXJsYXlZKSxcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqIE1hcCBhIHNjcm9sbCBzdHJhdGVneSBzdHJpbmcgdHlwZSB0byBhbiBpbnN0YW5jZSBvZiBhIHNjcm9sbCBzdHJhdGVneS4gKi9cbiAgcHJpdmF0ZSBfZ2V0U2Nyb2xsU3RyYXRlZ3lJbnN0YW5jZShzdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5KTogU2Nyb2xsU3RyYXRlZ3kge1xuICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5ibG9jaygpO1xuICAgICAgY2FzZSAncmVwb3NpdGlvbic6XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xuICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmNsb3NlKCk7XG4gICAgICBjYXNlICdub29wJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMubm9vcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDcmVhdGUgYW5kIHJldHVybiBhIHBvc2l0aW9uIHN0cmF0ZWd5IGJhc2VkIG9uIGNvbmZpZyBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLiAqL1xuICBwcml2YXRlIF9nZXRQb3NpdGlvblN0cmF0ZWd5KFxuICAgIGhvcml6b250YWxUYXJnZXQ6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sXG4gICAgdmVydGljYWxUYXJnZXQ6IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduLFxuICAgIGZvcmNlQWxpZ25tZW50OiBib29sZWFuLFxuICAgIGxvY2tBbGlnbm1lbnQ6IGJvb2xlYW4sXG4gICAgYW5jaG9yOiBFbGVtZW50UmVmLFxuICApOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIC8vIEF0dGFjaCB0aGUgb3ZlcmxheSBhdCB0aGUgcHJlZmVycmVkIHBvc2l0aW9uXG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihob3Jpem9udGFsVGFyZ2V0LCB2ZXJ0aWNhbFRhcmdldCk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW3RhcmdldFBvc2l0aW9uXTtcblxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyhhbmNob3IpXG4gICAgICAud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSlcbiAgICAgIC53aXRoUHVzaChmYWxzZSlcbiAgICAgIC53aXRoVmlld3BvcnRNYXJnaW4oMClcbiAgICAgIC53aXRoTG9ja2VkUG9zaXRpb24obG9ja0FsaWdubWVudCk7XG5cbiAgICAvLyBVbmxlc3MgdGhlIGFsaWdubWVudCBpcyBmb3JjZWQsIGFkZCBmYWxsYmFja3MgYmFzZWQgb24gdGhlIHByZWZlcnJlZCBwb3NpdGlvbnNcbiAgICBpZiAoIWZvcmNlQWxpZ25tZW50KSB7XG4gICAgICBjb25zdCBmYWxsYmFja3MgPSB0aGlzLl9nZXRGYWxsYmFja3MoaG9yaXpvbnRhbFRhcmdldCwgdmVydGljYWxUYXJnZXQpO1xuICAgICAgcG9zaXRpb25zLnB1c2goLi4uZmFsbGJhY2tzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyYXRlZ3kud2l0aFBvc2l0aW9ucyhwb3NpdGlvbnMpO1xuICB9XG5cbiAgLyoqIEdldCBmYWxsYmFjayBwb3NpdGlvbnMgYmFzZWQgYXJvdW5kIHRhcmdldCBhbGlnbm1lbnRzLiAqL1xuICBwcml2YXRlIF9nZXRGYWxsYmFja3MoXG4gICAgaFRhcmdldDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbixcbiAgICB2VGFyZ2V0OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnblxuICApOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10ge1xuICAgIC8vIERldGVybWluZSBpZiB0aGUgdGFyZ2V0IGFsaWdubWVudHMgb3ZlcmxhcCB0aGUgYW5jaG9yXG4gICAgY29uc3QgaG9yaXpvbnRhbE92ZXJsYXBBbGxvd2VkID0gaFRhcmdldCAhPT0gJ2JlZm9yZScgJiYgaFRhcmdldCAhPT0gJ2FmdGVyJztcbiAgICBjb25zdCB2ZXJ0aWNhbE92ZXJsYXBBbGxvd2VkID0gdlRhcmdldCAhPT0gJ2Fib3ZlJyAmJiB2VGFyZ2V0ICE9PSAnYmVsb3cnO1xuXG4gICAgLy8gSWYgYSB0YXJnZXQgYWxpZ25tZW50IGRvZXNuJ3QgY292ZXIgdGhlIGFuY2hvciwgZG9uJ3QgbGV0IGFueSBvZiB0aGUgZmFsbGJhY2sgYWxpZ25tZW50c1xuICAgIC8vIGNvdmVyIHRoZSBhbmNob3JcbiAgICBjb25zdCBwb3NzaWJsZUhvcml6b250YWxBbGlnbm1lbnRzOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduW10gPVxuICAgICAgaG9yaXpvbnRhbE92ZXJsYXBBbGxvd2VkID9cbiAgICAgICAgWydiZWZvcmUnLCAnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCcsICdhZnRlciddIDpcbiAgICAgICAgWydiZWZvcmUnLCAnYWZ0ZXInXTtcbiAgICBjb25zdCBwb3NzaWJsZVZlcnRpY2FsQWxpZ25tZW50czogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ25bXSA9XG4gICAgICB2ZXJ0aWNhbE92ZXJsYXBBbGxvd2VkID9cbiAgICAgICAgWydhYm92ZScsICdzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2JlbG93J10gOlxuICAgICAgICBbJ2Fib3ZlJywgJ2JlbG93J107XG5cbiAgICAvLyBDcmVhdGUgZmFsbGJhY2tzIGZvciBlYWNoIGFsbG93ZWQgcHJpb3JpdGl6ZWQgZmFsbGJhY2sgYWxpZ25tZW50IGNvbWJvXG4gICAgY29uc3QgZmFsbGJhY2tzOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10gPSBbXTtcbiAgICBwcmlvcml0aXplQXJvdW5kVGFyZ2V0KGhUYXJnZXQsIHBvc3NpYmxlSG9yaXpvbnRhbEFsaWdubWVudHMpLmZvckVhY2goaCA9PiB7XG4gICAgICBwcmlvcml0aXplQXJvdW5kVGFyZ2V0KHZUYXJnZXQsIHBvc3NpYmxlVmVydGljYWxBbGlnbm1lbnRzKS5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBmYWxsYmFja3MucHVzaChnZXRQb3NpdGlvbihoLCB2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgaXRlbSBzaW5jZSBpdCB3aWxsIGJlIHRoZSB0YXJnZXQgYWxpZ25tZW50IGFuZCBpc24ndCBjb25zaWRlcmVkIGEgZmFsbGJhY2tcbiAgICByZXR1cm4gZmFsbGJhY2tzLnNsaWNlKDEsIGZhbGxiYWNrcy5sZW5ndGgpO1xuICB9XG5cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBjZGsgcG9zaXRpb24gcGFpciBmcm9tIFNhdFBvcG92ZXIgYWxpZ25tZW50cy4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKFxuICBoOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLFxuICB2OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbixcbik6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIge1xuICBjb25zdCB7b3JpZ2luWCwgb3ZlcmxheVh9ID0gZ2V0SG9yaXpvbnRhbENvbm5lY3Rpb25Qb3NQYWlyKGgpO1xuICBjb25zdCB7b3JpZ2luWSwgb3ZlcmxheVl9ID0gZ2V0VmVydGljYWxDb25uZWN0aW9uUG9zUGFpcih2KTtcbiAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUG9zaXRpb25QYWlyKHtvcmlnaW5YLCBvcmlnaW5ZfSwge292ZXJsYXlYLCBvdmVybGF5WX0pO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQuICovXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsUG9wb3ZlckFsaWdubWVudChoOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyk6IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24ge1xuICBpZiAoaCA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnYWZ0ZXInO1xuICB9XG5cbiAgaWYgKGggPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdiZWZvcmUnO1xuICB9XG5cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb3ZlcmxheSBjb25uZWN0aW9uIHBvc2l0aW9uIHRvIGVxdWl2YWxlbnQgcG9wb3ZlciBhbGlnbm1lbnQuICovXG5mdW5jdGlvbiBnZXRWZXJ0aWNhbFBvcG92ZXJBbGlnbm1lbnQodjogVmVydGljYWxDb25uZWN0aW9uUG9zKTogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ24ge1xuICBpZiAodiA9PT0gJ3RvcCcpIHtcbiAgICByZXR1cm4gJ2JlbG93JztcbiAgfVxuXG4gIGlmICh2ID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAnYWJvdmUnO1xuICB9XG5cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYWxpZ25tZW50IHRvIG9yaWdpbi9vdmVybGF5IHBvc2l0aW9uIHBhaXIuICovXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsQ29ubmVjdGlvblBvc1BhaXIoaDogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbik6XG4gICAge29yaWdpblg6IEhvcml6b250YWxDb25uZWN0aW9uUG9zLCBvdmVybGF5WDogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3N9IHtcbiAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ3N0YXJ0Jywgb3ZlcmxheVg6ICdlbmQnfTtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICByZXR1cm4ge29yaWdpblg6ICdzdGFydCcsIG92ZXJsYXlYOiAnc3RhcnQnfTtcbiAgICBjYXNlICdlbmQnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5YOiAnZW5kJywgb3ZlcmxheVg6ICdlbmQnfTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4ge29yaWdpblg6ICdlbmQnLCBvdmVybGF5WDogJ3N0YXJ0J307XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7b3JpZ2luWDogJ2NlbnRlcicsIG92ZXJsYXlYOiAnY2VudGVyJ307XG4gIH1cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGFsaWdubWVudCB0byBvcmlnaW4vb3ZlcmxheSBwb3NpdGlvbiBwYWlyLiAqL1xuZnVuY3Rpb24gZ2V0VmVydGljYWxDb25uZWN0aW9uUG9zUGFpcih2OiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbik6XG4gICAge29yaWdpblk6IFZlcnRpY2FsQ29ubmVjdGlvblBvcywgb3ZlcmxheVk6IFZlcnRpY2FsQ29ubmVjdGlvblBvc30ge1xuICBzd2l0Y2ggKHYpIHtcbiAgICBjYXNlICdhYm92ZSc6XG4gICAgICByZXR1cm4ge29yaWdpblk6ICd0b3AnLCBvdmVybGF5WTogJ2JvdHRvbSd9O1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHJldHVybiB7b3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlZOiAndG9wJ307XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIHJldHVybiB7b3JpZ2luWTogJ2JvdHRvbScsIG92ZXJsYXlZOiAnYm90dG9tJ307XG4gICAgY2FzZSAnYmVsb3cnOlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVk6ICd0b3AnfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtvcmlnaW5ZOiAnY2VudGVyJywgb3ZlcmxheVk6ICdjZW50ZXInfTtcbiAgfVxufVxuXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gb3JkZXJlZCBhcnJheSBvcHRpb25zIGFuZCByZXR1cm5zIGEgcmVvcmRlcmRlZFxuICogYXJyYXkgYXJvdW5kIHRoZSB0YXJnZXQgaXRlbS4gZS5nLjpcbiAqXG4gKiB0YXJnZXQ6IDM7IG9wdGlvbnM6IFsxLCAyLCAzLCA0LCA1LCA2LCA3XTtcbiAqXG4gKiByZXR1cm46IFszLCA0LCAyLCA1LCAxLCA2LCA3XVxuICovXG5mdW5jdGlvbiBwcmlvcml0aXplQXJvdW5kVGFyZ2V0PFQ+KHRhcmdldDogVCwgb3B0aW9uczogVFtdKTogVFtdIHtcbiAgY29uc3QgdGFyZ2V0SW5kZXggPSBvcHRpb25zLmluZGV4T2YodGFyZ2V0KTtcblxuICAvLyBTZXQgdGhlIGZpcnN0IGl0ZW0gdG8gYmUgdGhlIHRhcmdldFxuICBjb25zdCByZW9yZGVyZWQgPSBbdGFyZ2V0XTtcblxuICAvLyBNYWtlIGxlZnQgYW5kIHJpZ2h0IHN0YWNrcyB3aGVyZSB0aGUgaGlnaGVzdCBwcmlvcml0eSBpdGVtIGlzIGxhc3RcbiAgY29uc3QgbGVmdCA9IG9wdGlvbnMuc2xpY2UoMCwgdGFyZ2V0SW5kZXgpO1xuICBjb25zdCByaWdodCA9IG9wdGlvbnMuc2xpY2UodGFyZ2V0SW5kZXggKyAxLCBvcHRpb25zLmxlbmd0aCkucmV2ZXJzZSgpO1xuXG4gIC8vIEFsdGVybmF0ZSBiZXR3ZWVuIHN0YWNrcyB1bnRpbCBvbmUgaXMgZW1wdHlcbiAgd2hpbGUgKGxlZnQubGVuZ3RoICYmIHJpZ2h0Lmxlbmd0aCkge1xuICAgIHJlb3JkZXJlZC5wdXNoKHJpZ2h0LnBvcCgpKTtcbiAgICByZW9yZGVyZWQucHVzaChsZWZ0LnBvcCgpKTtcbiAgfVxuXG4gIC8vIEZsdXNoIG91dCByaWdodCBzaWRlXG4gIHdoaWxlIChyaWdodC5sZW5ndGgpIHtcbiAgICByZW9yZGVyZWQucHVzaChyaWdodC5wb3AoKSk7XG4gIH1cblxuICAvLyBGbHVzaCBvdXQgbGVmdCBzaWRlXG4gIHdoaWxlIChsZWZ0Lmxlbmd0aCkge1xuICAgIHJlb3JkZXJlZC5wdXNoKGxlZnQucG9wKCkpO1xuICB9XG5cbiAgcmV0dXJuIHJlb3JkZXJlZDtcbn1cbiIsImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25Jbml0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIG1lcmdlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgU2F0UG9wb3ZlciB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgZ2V0SW52YWxpZFBvcG92ZXJFcnJvciB9IGZyb20gJy4vcG9wb3Zlci5lcnJvcnMnO1xuaW1wb3J0IHsgU2F0UG9wb3ZlckFuY2hvcmluZ1NlcnZpY2UgfSBmcm9tICcuL3BvcG92ZXItYW5jaG9yaW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2F0UG9wb3Zlck9wZW5PcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tzYXRQb3BvdmVyQW5jaG9yRm9yXScsXG4gIGV4cG9ydEFzOiAnc2F0UG9wb3ZlckFuY2hvcicsXG4gIHByb3ZpZGVyczogW1NhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgU2F0UG9wb3ZlckFuY2hvciBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBwb3BvdmVyIGluc3RhbmNlLiAqL1xuICBASW5wdXQoJ3NhdFBvcG92ZXJBbmNob3JGb3InKVxuICBnZXQgYXR0YWNoZWRQb3BvdmVyKCkgeyByZXR1cm4gdGhpcy5fYXR0YWNoZWRQb3BvdmVyOyB9XG4gIHNldCBhdHRhY2hlZFBvcG92ZXIodmFsdWU6IFNhdFBvcG92ZXIpIHtcbiAgICB0aGlzLl92YWxpZGF0ZUF0dGFjaGVkUG9wb3Zlcih2YWx1ZSk7XG4gICAgdGhpcy5fYXR0YWNoZWRQb3BvdmVyID0gdmFsdWU7XG4gICAgLy8gQW5jaG9yIHRoZSBwb3BvdmVyIHRvIHRoZSBlbGVtZW50IHJlZlxuICAgIHRoaXMuX2FuY2hvcmluZy5hbmNob3IodGhpcy5hdHRhY2hlZFBvcG92ZXIsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYsIHRoaXMuX2VsZW1lbnRSZWYpO1xuICB9XG4gIHByaXZhdGUgX2F0dGFjaGVkUG9wb3ZlcjogU2F0UG9wb3ZlcjtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gIEBPdXRwdXQoKSBwb3BvdmVyT3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgQE91dHB1dCgpIHBvcG92ZXJDbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZC4gKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHVibGljIF9hbmNob3Jpbmc6IFNhdFBvcG92ZXJBbmNob3JpbmdTZXJ2aWNlLFxuICApIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIC8vIFJlLWVtaXQgb3BlbiBhbmQgY2xvc2UgZXZlbnRzXG4gICAgY29uc3Qgb3BlbmVkJCA9IHRoaXMuX2FuY2hvcmluZy5wb3BvdmVyT3BlbmVkXG4gICAgICAucGlwZSh0YXAoKCkgPT4gdGhpcy5wb3BvdmVyT3BlbmVkLmVtaXQoKSkpO1xuICAgIGNvbnN0IGNsb3NlZCQgPSB0aGlzLl9hbmNob3JpbmcucG9wb3ZlckNsb3NlZFxuICAgICAgLnBpcGUodGFwKHZhbHVlID0+IHRoaXMucG9wb3ZlckNsb3NlZC5lbWl0KHZhbHVlKSkpO1xuICAgIG1lcmdlKG9wZW5lZCQsIGNsb3NlZCQpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBHZXRzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gIGlzUG9wb3Zlck9wZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcmluZy5pc1BvcG92ZXJPcGVuKCk7XG4gIH1cblxuICAvKiogVG9nZ2xlcyB0aGUgcG9wb3ZlciBiZXR3ZWVuIHRoZSBvcGVuIGFuZCBjbG9zZWQgc3RhdGVzLiAqL1xuICB0b2dnbGVQb3BvdmVyKCk6IHZvaWQge1xuICAgIHRoaXMuX2FuY2hvcmluZy50b2dnbGVQb3BvdmVyKCk7XG4gIH1cblxuICAvKiogT3BlbnMgdGhlIHBvcG92ZXIuICovXG4gIG9wZW5Qb3BvdmVyKG9wdGlvbnM6IFNhdFBvcG92ZXJPcGVuT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgdGhpcy5fYW5jaG9yaW5nLm9wZW5Qb3BvdmVyKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqIENsb3NlcyB0aGUgcG9wb3Zlci4gKi9cbiAgY2xvc2VQb3BvdmVyKHZhbHVlPzogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fYW5jaG9yaW5nLmNsb3NlUG9wb3Zlcih2YWx1ZSk7XG4gIH1cblxuICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICByZWFsaWduUG9wb3ZlcigpOiB2b2lkIHtcbiAgICB0aGlzLl9hbmNob3JpbmcucmVhbGlnblBvcG92ZXJUb0FuY2hvcigpO1xuICB9XG5cbiAgLyoqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuICovXG4gIGdldEVsZW1lbnQoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWY7XG4gIH1cblxuICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwb3BvdmVyIGluc3RhbmNlIGlzIG5vdCBwcm92aWRlZC4gKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdGVBdHRhY2hlZFBvcG92ZXIocG9wb3ZlcjogU2F0UG9wb3Zlcik6IHZvaWQge1xuICAgIGlmICghcG9wb3ZlciB8fCAhKHBvcG92ZXIgaW5zdGFuY2VvZiBTYXRQb3BvdmVyKSkge1xuICAgICAgdGhyb3cgZ2V0SW52YWxpZFBvcG92ZXJFcnJvcigpO1xuICAgIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29lcmNlTnVtYmVyUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgb2YsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlbGF5LCBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgU2F0UG9wb3ZlckFuY2hvciB9IGZyb20gJy4vcG9wb3Zlci1hbmNob3IuZGlyZWN0aXZlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3NhdFBvcG92ZXJIb3Zlcl0nXG59KVxuZXhwb3J0IGNsYXNzIFNhdFBvcG92ZXJIb3ZlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSAobXMpIGFmdGVyIGhvdmVyaW5nIHN0YXJ0cyBiZWZvcmVcbiAgICogdGhlIHBvcG92ZXIgb3BlbnMuIERlZmF1bHRzIHRvIDBtcy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBzYXRQb3BvdmVySG92ZXIoKSB7IHJldHVybiB0aGlzLl9zYXRQb3BvdmVySG92ZXI7IH1cbiAgc2V0IHNhdFBvcG92ZXJIb3Zlcih2YWw6IG51bWJlcikge1xuICAgIHRoaXMuX3NhdFBvcG92ZXJIb3ZlciA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbCk7XG4gIH1cbiAgcHJpdmF0ZSBfc2F0UG9wb3ZlckhvdmVyID0gMDtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZC4gKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3QoKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGVudGVycyB0aGUgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfb25Nb3VzZUVudGVyID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGxlYXZlcyB0aGUgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfb25Nb3VzZUxlYXZlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgYW5jaG9yOiBTYXRQb3BvdmVyQW5jaG9yKSB7IH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgLy8gV2hlbmV2ZXIgdGhlIHVzZXIgaG92ZXJzIHRoaXMgaG9zdCBlbGVtZW50LCBkZWxheSB0aGUgY29uZmlndXJlZFxuICAgIC8vIGFtb3VudCBvZiB0aW1lIGFuZCBvcGVuIHRoZSBwb3BvdmVyLiBUZXJtaW5hdGUgaWYgdGhlIG1vdXNlIGxlYXZlc1xuICAgIC8vIHRoZSBob3N0IGVsZW1lbnQgYmVmb3JlIHRoZSBkZWxheSBpcyBjb21wbGV0ZS5cbiAgICB0aGlzLl9vbk1vdXNlRW50ZXJcbiAgICAgIC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvZihudWxsKS5waXBlKFxuICAgICAgICAgICAgZGVsYXkodGhpcy5fc2F0UG9wb3ZlckhvdmVyIHx8IDApLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uTW91c2VMZWF2ZSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmFuY2hvci5vcGVuUG9wb3ZlcigpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJylcbiAgc2hvd1BvcG92ZXIoKSB7XG4gICAgdGhpcy5fb25Nb3VzZUVudGVyLm5leHQoKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKVxuICBjbG9zZVBvcG92ZXIoKSB7XG4gICAgdGhpcy5fb25Nb3VzZUxlYXZlLm5leHQoKTtcbiAgICB0aGlzLmFuY2hvci5jbG9zZVBvcG92ZXIoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBPdmVybGF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQTExeU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IEJpZGlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5cbmltcG9ydCB7IFNhdFBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFNhdFBvcG92ZXJBbmNob3IgfSBmcm9tICcuL3BvcG92ZXItYW5jaG9yLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTYXRQb3BvdmVySG92ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3BvcG92ZXItaG92ZXIuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBPdmVybGF5TW9kdWxlLFxuICAgIEExMXlNb2R1bGUsXG4gICAgQmlkaU1vZHVsZSxcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbXG4gICAgU2F0UG9wb3ZlcixcbiAgICBTYXRQb3BvdmVyQW5jaG9yLFxuICAgIFNhdFBvcG92ZXJIb3ZlckRpcmVjdGl2ZSxcbiAgXSxcbiAgZXhwb3J0czogW1xuICAgIFNhdFBvcG92ZXIsXG4gICAgU2F0UG9wb3ZlckFuY2hvcixcbiAgICBTYXRQb3BvdmVySG92ZXJEaXJlY3RpdmUsXG4gICAgQmlkaU1vZHVsZSxcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBTYXRQb3BvdmVyTW9kdWxlIHsgfVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFTQSxJQUFhLGdCQUFnQixHQUE2QixPQUFPLENBQUMsa0JBQWtCLEVBQUU7SUFDcEYsVUFBVSxDQUFDLFFBQVEsRUFBRTtRQUNuQixLQUFLLENBQUMsRUFBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUMsQ0FBQztR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