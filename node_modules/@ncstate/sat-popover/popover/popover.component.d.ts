import { EventEmitter, TemplateRef, OnDestroy, OnInit } from '@angular/core';
import { AnimationEvent } from '@angular/animations';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { PopoverNotificationService } from './notification.service';
import { SatPopoverScrollStrategy, SatPopoverHorizontalAlign, SatPopoverVerticalAlign, SatPopoverOpenOptions } from './types';
import * as ɵngcc0 from '@angular/core';
export declare class SatPopover implements OnInit, OnDestroy {
    private _focusTrapFactory;
    private _document;
    /** Alignment of the popover on the horizontal axis. */
    horizontalAlign: SatPopoverHorizontalAlign;
    private _horizontalAlign;
    /** Alignment of the popover on the x axis. Alias for `horizontalAlign`. */
    xAlign: SatPopoverHorizontalAlign;
    /** Alignment of the popover on the vertical axis. */
    verticalAlign: SatPopoverVerticalAlign;
    private _verticalAlign;
    /** Alignment of the popover on the y axis. Alias for `verticalAlign`. */
    yAlign: SatPopoverVerticalAlign;
    /** Whether the popover always opens with the specified alignment. */
    forceAlignment: boolean;
    private _forceAlignment;
    /**
     * Whether the popover's alignment is locked after opening. This prevents the popover
     * from changing its alignement when scrolling or changing the size of the viewport.
     */
    lockAlignment: boolean;
    private _lockAlignment;
    /** Whether the first focusable element should be focused on open. */
    autoFocus: boolean;
    private _autoFocus;
    _autoFocusOverride: boolean;
    /** Whether the popover should return focus to the previously focused element after closing. */
    restoreFocus: boolean;
    private _restoreFocus;
    _restoreFocusOverride: boolean;
    /** How the popover should handle scrolling. */
    scrollStrategy: SatPopoverScrollStrategy;
    private _scrollStrategy;
    /** Whether the popover should have a backdrop (includes closing on click). */
    hasBackdrop: boolean;
    private _hasBackdrop;
    /** Whether the popover should close when the user clicks the backdrop or presses ESC. */
    interactiveClose: boolean;
    private _interactiveClose;
    /** Custom transition to use while opening. */
    openTransition: string;
    private _openTransition;
    /** Custom transition to use while closing. */
    closeTransition: string;
    private _closeTransition;
    /** Optional backdrop class. */
    backdropClass: string;
    /** Emits when the popover is opened. */
    opened: EventEmitter<void>;
    /** Emits when the popover is closed. */
    closed: EventEmitter<any>;
    /** Emits when the popover has finished opening. */
    afterOpen: EventEmitter<void>;
    /** Emits when the popover has finished closing. */
    afterClose: EventEmitter<void>;
    /** Emits when the backdrop is clicked. */
    backdropClicked: EventEmitter<void>;
    /** Emits when a keydown event is targeted to this popover's overlay. */
    overlayKeydown: EventEmitter<KeyboardEvent>;
    /** Reference to template so it can be placed within a portal. */
    _templateRef: TemplateRef<any>;
    /** Classes to be added to the popover for setting the correct transform origin. */
    _classList: any;
    /** Whether the popover is presently open. */
    _open: boolean;
    /** Instance of notification service. Will be undefined until attached to an anchor. */
    _notifications: PopoverNotificationService;
    /** Reference to the element to build a focus trap around. */
    private _focusTrapElement;
    /** Reference to the element that was focused before opening. */
    private _previouslyFocusedElement;
    /** Reference to a focus trap around the popover. */
    private _focusTrap;
    constructor(_focusTrapFactory: FocusTrapFactory, _document: any);
    ngOnInit(): void;
    ngOnDestroy(): void;
    /** Open this popover. */
    open(options?: SatPopoverOpenOptions): void;
    /** Close this popover. */
    close(value?: any): void;
    /** Toggle this popover open or closed. */
    toggle(): void;
    /** Realign the popover to the anchor. */
    realign(): void;
    /** Gets whether the popover is presently open. */
    isOpen(): boolean;
    /** Gets an animation config with customized (or default) transition values. */
    _getAnimation(): {
        value: any;
        params: any;
    };
    /** Callback for when the popover is finished animating in or out. */
    _onAnimationDone(event: AnimationEvent): void;
    /** Apply alignment classes based on alignment inputs. */
    _setAlignmentClasses(horizAlign?: SatPopoverHorizontalAlign, vertAlign?: SatPopoverVerticalAlign): void;
    /** Move the focus inside the focus trap and remember where to return later. */
    private _trapFocus;
    /** Restore focus to the element focused before the popover opened. Also destroy trap. */
    private _restoreFocusAndDestroyTrap;
    /** Save a reference to the element focused before the popover was opened. */
    private _savePreviouslyFocusedElement;
    /** Dispatch a notification to the notification service, if possible. */
    private _dispatchConfigNotification;
    /** Dispatch a notification to the notification service and throw if unable to. */
    private _dispatchActionNotification;
    /** Throws an error if the alignment is not a valid horizontalAlign. */
    private _validateHorizontalAlign;
    /** Throws an error if the alignment is not a valid verticalAlign. */
    private _validateVerticalAlign;
    /** Throws an error if the scroll strategy is not a valid strategy. */
    private _validateScrollStrategy;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SatPopover, [null, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<SatPopover, "sat-popover", never, { "backdropClass": "backdropClass"; "horizontalAlign": "horizontalAlign"; "xAlign": "xAlign"; "verticalAlign": "verticalAlign"; "yAlign": "yAlign"; "forceAlignment": "forceAlignment"; "lockAlignment": "lockAlignment"; "autoFocus": "autoFocus"; "restoreFocus": "restoreFocus"; "scrollStrategy": "scrollStrategy"; "hasBackdrop": "hasBackdrop"; "interactiveClose": "interactiveClose"; "openTransition": "openTransition"; "closeTransition": "closeTransition"; }, { "opened": "opened"; "closed": "closed"; "afterOpen": "afterOpen"; "afterClose": "afterClose"; "backdropClicked": "backdropClicked"; "overlayKeydown": "overlayKeydown"; }, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsicG9wb3Zlci5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIsIFRlbXBsYXRlUmVmLCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEZvY3VzVHJhcEZhY3RvcnkgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBQb3BvdmVyTm90aWZpY2F0aW9uU2VydmljZSB9IGZyb20gJy4vbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5LCBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduLCBTYXRQb3BvdmVyVmVydGljYWxBbGlnbiwgU2F0UG9wb3Zlck9wZW5PcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBTYXRQb3BvdmVyIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX2ZvY3VzVHJhcEZhY3Rvcnk7XG4gICAgcHJpdmF0ZSBfZG9jdW1lbnQ7XG4gICAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgaG9yaXpvbnRhbCBheGlzLiAqL1xuICAgIGhvcml6b250YWxBbGlnbjogU2F0UG9wb3Zlckhvcml6b250YWxBbGlnbjtcbiAgICBwcml2YXRlIF9ob3Jpem9udGFsQWxpZ247XG4gICAgLyoqIEFsaWdubWVudCBvZiB0aGUgcG9wb3ZlciBvbiB0aGUgeCBheGlzLiBBbGlhcyBmb3IgYGhvcml6b250YWxBbGlnbmAuICovXG4gICAgeEFsaWduOiBTYXRQb3BvdmVySG9yaXpvbnRhbEFsaWduO1xuICAgIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHBvcG92ZXIgb24gdGhlIHZlcnRpY2FsIGF4aXMuICovXG4gICAgdmVydGljYWxBbGlnbjogU2F0UG9wb3ZlclZlcnRpY2FsQWxpZ247XG4gICAgcHJpdmF0ZSBfdmVydGljYWxBbGlnbjtcbiAgICAvKiogQWxpZ25tZW50IG9mIHRoZSBwb3BvdmVyIG9uIHRoZSB5IGF4aXMuIEFsaWFzIGZvciBgdmVydGljYWxBbGlnbmAuICovXG4gICAgeUFsaWduOiBTYXRQb3BvdmVyVmVydGljYWxBbGlnbjtcbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBhbHdheXMgb3BlbnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFsaWdubWVudC4gKi9cbiAgICBmb3JjZUFsaWdubWVudDogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9mb3JjZUFsaWdubWVudDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBwb3BvdmVyJ3MgYWxpZ25tZW50IGlzIGxvY2tlZCBhZnRlciBvcGVuaW5nLiBUaGlzIHByZXZlbnRzIHRoZSBwb3BvdmVyXG4gICAgICogZnJvbSBjaGFuZ2luZyBpdHMgYWxpZ25lbWVudCB3aGVuIHNjcm9sbGluZyBvciBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgbG9ja0FsaWdubWVudDogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9sb2NrQWxpZ25tZW50O1xuICAgIC8qKiBXaGV0aGVyIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBzaG91bGQgYmUgZm9jdXNlZCBvbiBvcGVuLiAqL1xuICAgIGF1dG9Gb2N1czogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9hdXRvRm9jdXM7XG4gICAgX2F1dG9Gb2N1c092ZXJyaWRlOiBib29sZWFuO1xuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCByZXR1cm4gZm9jdXMgdG8gdGhlIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IGFmdGVyIGNsb3NpbmcuICovXG4gICAgcmVzdG9yZUZvY3VzOiBib29sZWFuO1xuICAgIHByaXZhdGUgX3Jlc3RvcmVGb2N1cztcbiAgICBfcmVzdG9yZUZvY3VzT3ZlcnJpZGU6IGJvb2xlYW47XG4gICAgLyoqIEhvdyB0aGUgcG9wb3ZlciBzaG91bGQgaGFuZGxlIHNjcm9sbGluZy4gKi9cbiAgICBzY3JvbGxTdHJhdGVneTogU2F0UG9wb3ZlclNjcm9sbFN0cmF0ZWd5O1xuICAgIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5O1xuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBoYXZlIGEgYmFja2Ryb3AgKGluY2x1ZGVzIGNsb3Npbmcgb24gY2xpY2spLiAqL1xuICAgIGhhc0JhY2tkcm9wOiBib29sZWFuO1xuICAgIHByaXZhdGUgX2hhc0JhY2tkcm9wO1xuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBjbG9zZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFja2Ryb3Agb3IgcHJlc3NlcyBFU0MuICovXG4gICAgaW50ZXJhY3RpdmVDbG9zZTogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9pbnRlcmFjdGl2ZUNsb3NlO1xuICAgIC8qKiBDdXN0b20gdHJhbnNpdGlvbiB0byB1c2Ugd2hpbGUgb3BlbmluZy4gKi9cbiAgICBvcGVuVHJhbnNpdGlvbjogc3RyaW5nO1xuICAgIHByaXZhdGUgX29wZW5UcmFuc2l0aW9uO1xuICAgIC8qKiBDdXN0b20gdHJhbnNpdGlvbiB0byB1c2Ugd2hpbGUgY2xvc2luZy4gKi9cbiAgICBjbG9zZVRyYW5zaXRpb246IHN0cmluZztcbiAgICBwcml2YXRlIF9jbG9zZVRyYW5zaXRpb247XG4gICAgLyoqIE9wdGlvbmFsIGJhY2tkcm9wIGNsYXNzLiAqL1xuICAgIGJhY2tkcm9wQ2xhc3M6IHN0cmluZztcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQuICovXG4gICAgb3BlbmVkOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkLiAqL1xuICAgIGNsb3NlZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIG9wZW5pbmcuICovXG4gICAgYWZ0ZXJPcGVuOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGZpbmlzaGVkIGNsb3NpbmcuICovXG4gICAgYWZ0ZXJDbG9zZTogRXZlbnRFbWl0dGVyPHZvaWQ+O1xuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLiAqL1xuICAgIGJhY2tkcm9wQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHZvaWQ+O1xuICAgIC8qKiBFbWl0cyB3aGVuIGEga2V5ZG93biBldmVudCBpcyB0YXJnZXRlZCB0byB0aGlzIHBvcG92ZXIncyBvdmVybGF5LiAqL1xuICAgIG92ZXJsYXlLZXlkb3duOiBFdmVudEVtaXR0ZXI8S2V5Ym9hcmRFdmVudD47XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0ZW1wbGF0ZSBzbyBpdCBjYW4gYmUgcGxhY2VkIHdpdGhpbiBhIHBvcnRhbC4gKi9cbiAgICBfdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqIENsYXNzZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHBvcG92ZXIgZm9yIHNldHRpbmcgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIG9yaWdpbi4gKi9cbiAgICBfY2xhc3NMaXN0OiBhbnk7XG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgcHJlc2VudGx5IG9wZW4uICovXG4gICAgX29wZW46IGJvb2xlYW47XG4gICAgLyoqIEluc3RhbmNlIG9mIG5vdGlmaWNhdGlvbiBzZXJ2aWNlLiBXaWxsIGJlIHVuZGVmaW5lZCB1bnRpbCBhdHRhY2hlZCB0byBhbiBhbmNob3IuICovXG4gICAgX25vdGlmaWNhdGlvbnM6IFBvcG92ZXJOb3RpZmljYXRpb25TZXJ2aWNlO1xuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdG8gYnVpbGQgYSBmb2N1cyB0cmFwIGFyb3VuZC4gKi9cbiAgICBwcml2YXRlIF9mb2N1c1RyYXBFbGVtZW50O1xuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBiZWZvcmUgb3BlbmluZy4gKi9cbiAgICBwcml2YXRlIF9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQ7XG4gICAgLyoqIFJlZmVyZW5jZSB0byBhIGZvY3VzIHRyYXAgYXJvdW5kIHRoZSBwb3BvdmVyLiAqL1xuICAgIHByaXZhdGUgX2ZvY3VzVHJhcDtcbiAgICBjb25zdHJ1Y3RvcihfZm9jdXNUcmFwRmFjdG9yeTogRm9jdXNUcmFwRmFjdG9yeSwgX2RvY3VtZW50OiBhbnkpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKiogT3BlbiB0aGlzIHBvcG92ZXIuICovXG4gICAgb3BlbihvcHRpb25zPzogU2F0UG9wb3Zlck9wZW5PcHRpb25zKTogdm9pZDtcbiAgICAvKiogQ2xvc2UgdGhpcyBwb3BvdmVyLiAqL1xuICAgIGNsb3NlKHZhbHVlPzogYW55KTogdm9pZDtcbiAgICAvKiogVG9nZ2xlIHRoaXMgcG9wb3ZlciBvcGVuIG9yIGNsb3NlZC4gKi9cbiAgICB0b2dnbGUoKTogdm9pZDtcbiAgICAvKiogUmVhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgYW5jaG9yLiAqL1xuICAgIHJlYWxpZ24oKTogdm9pZDtcbiAgICAvKiogR2V0cyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHByZXNlbnRseSBvcGVuLiAqL1xuICAgIGlzT3BlbigpOiBib29sZWFuO1xuICAgIC8qKiBHZXRzIGFuIGFuaW1hdGlvbiBjb25maWcgd2l0aCBjdXN0b21pemVkIChvciBkZWZhdWx0KSB0cmFuc2l0aW9uIHZhbHVlcy4gKi9cbiAgICBfZ2V0QW5pbWF0aW9uKCk6IHtcbiAgICAgICAgdmFsdWU6IGFueTtcbiAgICAgICAgcGFyYW1zOiBhbnk7XG4gICAgfTtcbiAgICAvKiogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIHBvcG92ZXIgaXMgZmluaXNoZWQgYW5pbWF0aW5nIGluIG9yIG91dC4gKi9cbiAgICBfb25BbmltYXRpb25Eb25lKGV2ZW50OiBBbmltYXRpb25FdmVudCk6IHZvaWQ7XG4gICAgLyoqIEFwcGx5IGFsaWdubWVudCBjbGFzc2VzIGJhc2VkIG9uIGFsaWdubWVudCBpbnB1dHMuICovXG4gICAgX3NldEFsaWdubWVudENsYXNzZXMoaG9yaXpBbGlnbj86IFNhdFBvcG92ZXJIb3Jpem9udGFsQWxpZ24sIHZlcnRBbGlnbj86IFNhdFBvcG92ZXJWZXJ0aWNhbEFsaWduKTogdm9pZDtcbiAgICAvKiogTW92ZSB0aGUgZm9jdXMgaW5zaWRlIHRoZSBmb2N1cyB0cmFwIGFuZCByZW1lbWJlciB3aGVyZSB0byByZXR1cm4gbGF0ZXIuICovXG4gICAgcHJpdmF0ZSBfdHJhcEZvY3VzO1xuICAgIC8qKiBSZXN0b3JlIGZvY3VzIHRvIHRoZSBlbGVtZW50IGZvY3VzZWQgYmVmb3JlIHRoZSBwb3BvdmVyIG9wZW5lZC4gQWxzbyBkZXN0cm95IHRyYXAuICovXG4gICAgcHJpdmF0ZSBfcmVzdG9yZUZvY3VzQW5kRGVzdHJveVRyYXA7XG4gICAgLyoqIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgZm9jdXNlZCBiZWZvcmUgdGhlIHBvcG92ZXIgd2FzIG9wZW5lZC4gKi9cbiAgICBwcml2YXRlIF9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50O1xuICAgIC8qKiBEaXNwYXRjaCBhIG5vdGlmaWNhdGlvbiB0byB0aGUgbm90aWZpY2F0aW9uIHNlcnZpY2UsIGlmIHBvc3NpYmxlLiAqL1xuICAgIHByaXZhdGUgX2Rpc3BhdGNoQ29uZmlnTm90aWZpY2F0aW9uO1xuICAgIC8qKiBEaXNwYXRjaCBhIG5vdGlmaWNhdGlvbiB0byB0aGUgbm90aWZpY2F0aW9uIHNlcnZpY2UgYW5kIHRocm93IGlmIHVuYWJsZSB0by4gKi9cbiAgICBwcml2YXRlIF9kaXNwYXRjaEFjdGlvbk5vdGlmaWNhdGlvbjtcbiAgICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBhbGlnbm1lbnQgaXMgbm90IGEgdmFsaWQgaG9yaXpvbnRhbEFsaWduLiAqL1xuICAgIHByaXZhdGUgX3ZhbGlkYXRlSG9yaXpvbnRhbEFsaWduO1xuICAgIC8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGFsaWdubWVudCBpcyBub3QgYSB2YWxpZCB2ZXJ0aWNhbEFsaWduLiAqL1xuICAgIHByaXZhdGUgX3ZhbGlkYXRlVmVydGljYWxBbGlnbjtcbiAgICAvKiogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzY3JvbGwgc3RyYXRlZ3kgaXMgbm90IGEgdmFsaWQgc3RyYXRlZ3kuICovXG4gICAgcHJpdmF0ZSBfdmFsaWRhdGVTY3JvbGxTdHJhdGVneTtcbn1cbiJdfQ==